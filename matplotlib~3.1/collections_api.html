
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Collections - Matplotlib 3.1 - W3cubDocs</title>
  
  <meta name="description" content=" Classes for the efficient drawing of large collections of objects that share most properties, e.g., a large number of line segments or polygons. ">
  <meta name="keywords" content="matplotlib, collections, matplotlib~3.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/matplotlib~3.1/collections_api.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/matplotlib~3.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~3.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 3.1</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="matplotlib-collections">matplotlib.collections</h1> <div class="graphviz"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAwAAAAEICAMAAADfk2P4AAAAolBMVEX////39/fz8/MAAACrq6vv7++jo6OXl5eHh4e/v7/t7e3V1dW7u7sICAjCwsLNzc2oqKiEhIT6+vrJycmZmZmLi4ugoKDn5+fx8fEYGBhKSkqcnJzh4eGOjo53d3enp6c6OjotLS1FRUWRkZF0dHSvr6/+/v7r6+vHx8cjIyMODg6UlJS0tLRbW1vY2NhsbGzc3NxSUlJjY2PMzMzS0tKfn59nb+DoAAAX0UlEQVR42uyd2XqqMBSFo3AEFbVa1DpWxOKAiuP7v9pJglMraFAUkfVf9UtCsot7wWZwSQgAAAAAAAAgDEZl5eVx8DGBR1HcvH6MCj4mAAEA8AwBZNWses+EWvX3bFeGiywHAYAIBeCVoNa45pHKRwGMJMnYXBBAZjzpWsLLQQAgKgH4JLDmNP36XQE4qW7Zf/uSkc9V58LLQQDg4QLI9QuNYa/QTPGM/NcvGHPW1JMKWZW3a7OGkcs2pAEbPds02/xv2s/HarPxQOUtWjU/a9MzwFhzZyODESlrdaOxyhzmGWTYJH7L8Y4pWw4CAM8SgFqukHInNcjwjFQlSSqzJvp3VuXt2vKr+90a5NngtEEyZf73fqzWTGdV3qL1nRQ9A5D9bKQ9q/Stsp1yMod5DC4Av+V4x4wtBwGApwlA5QLo7jKynHKbil1XAN0MLW3kFlnYKzp4SxN2zP+m/Xws7aWbsRZttazvBcBmI2SlKmQvAHcex8j/q879luNbzvhyEACIpgRqFiSZNeXGk30JxDLSkSYmWSz79Ei/7LG/aT8fywXAe7VqfZlnAtjNRiv+RprQEmj2c5ynNp4MLL/l3BIIAgCRXASHz5RfNnz187dOAAGAGAsg02gTkpIKAwIBgCSeAe4GAgAQAADPF0DKggDAewugXLuAMxn3mhdHPIMVPibwKKyUL3VNUSfS2MmlogYfE3gquWJL1/XMOm2NV0PsDpCk1N+apllb7w+6SH+QEOraVtcVeY16AyQu9RXT7Mj5CnYFSBSVBTvq23Lewr4ACUv9KT3qm9MFUh8kLvV1irbArgAJS/28TA/6tlbHrgDJIpWX6UG/peGeJkgY/9Y1etRvFb+wK0CyyK0zrNYvprErQMJSnz3M1TN4ogUSmPq63qkh9UF05DsRWSirs5lTtr16tkKBf7+cKbT9iXSKHy94g10JcdQzGcpIJwgAAgDxFsCtbsteW523hWeurJyvdYdNdBiu0BDAewrA44NnVpol3xQ6WC0f2h5hrnxdAB5T53oFafr7HwnPFRoCeEMBeCfGyLHKZX8B7K2W920PMVe+LACfhLa7lV9dobpCQwAxFgDz+SPCbsvsDDDkY7iL8o9Ctt9ZdS0VlhVtNu7S3s1uLm61rHqYK4/Ygn9mFxbA+jjqxCKRpuVp3MQrcEMtsS4WKo10GqorNAQQYwEwq2Nxt+WR8zXT+BhuIrsTwNyQpLnWTDOjzf1c3GpZ9TBXnrAF/8wuLICG4eR3o05coulcp3F7BU7qtf6KdrFQ7WY6XFdoCCDOAlArRNxtmebNosnH8ITRnPSKCkDt1PsbOmwvAO61zKyWSx7mynzBv7Pvclq/Qm0sFca7n2I8cYlmAjiJ2ytwQiq6QbtYqJ0qCdcVGgJ4oxLogtvyYsnzplliY7iLcqrXYAIoNcbNgwD2ZQmzWiYe5so6W/DP7MJnAGM18imBTuImHoFX6UVvkXaxUPcCCM0VGgJ4i4vgoFxxUZ4G95i9LgCLPOI5wL2u0BBAAgVwzUWZWy2HLgDyCAHc7QoNASTyDBA+eBIMIAAIAEAAEAB4uAA+hx4o3e2oPYwIUyhwe/hqzCGAGFKXvWhKUmHckqNhJBT4p/xytJFO70Aqa9vlgmFjT4DEUVm3THNtkcoMvgwgacmftc0WbDdBIhlmTGWD5AeJZNEyWzAgBMm85J2aZhZO+yCZZf/U1BfYDSCRWEVFmWM3gGSSt9Ui9gJIaPbrdhG3fEAyGbY6WWQ/SGjhr5kZPOQFCaWtqxvsBZBMUrIqX73hn/6IgNIt/87o4+XA26AvTKmjiDzsbX/kns9NL57auVdjge8DvOzB/0P0urc9jSA85WkbPfbuAgTwmtSVjvDJGQKAAN6Movod4FWfMwEEc0t/pB/6lY2C26NrVRLkP4M9egz5ypjBbvtcF4C3W/oT/NADC+Car/sfAfzqY5ZxThH26PFm09kGved/RQB+bunP8EM/wSI32qOPHOtn5ieA0z5XALBHjzHWtKMFf+C7F8CJ5aaYW/pVP3Sv7W8VgDHTrNvs0R3y42iz8dZ1/8zP2nwLPoT3HSzeuQBU2KPH977PbY+89gI4cR0XcUsn1/3QvbbfLTrQA8LcoVdngQrYo1OpFjStmXY7+k7KDY0P4X0Hi3faLBVV2KPH9L7P1rzxG14HARxdx4Xc0q/7oXtuf+MZYGysNspZoAL26DTSvEEb3I7Vsu6GxofwvlOLd14CwR49fsxt/eafnvYpgS64pZPFUsgP3Wv7WwVQIuQ2e3R6YJ+otGHXUV/m+RauAFjfqcU7vQiGPXr8Sn+tqt3xruf9zwEe4oce1kYPBQKInspH9b633e4WwOP80CEAcO3KV7bvfR8rhCfBFgQAouBraw7vngSvQkAAMb3xo3TC+KLLQQDt6mcKAoAAYsLijhs/v8ipiotakCYNR3kKP7dE+q28GvYnEjEaNtVpmF/yTX9ubVsxJv01di2IQfqbodXtlcXUNPVWMU3/Xk2xa8HrM1LDSdS6tjVNcwqLUBAnimr27jn+Fbe6bsswRgfxS//RXdtX8jVT1zPrFHYliB/aHQ99ebFv2rzYByCWtf+N92hosa/rKPZBzNP/htofxT54DzadgOnPin3TRLEP3oG8HeDGJy32acGDYh+8CwtbFixhUOyDt6Nt/gik/79iyzRR7IP3S/9a5VqxL+so9kHEWOlHUFdr/y50lzKdTkfJ1s97xNWQjgz8TuU78VnOPIBt7WJ31/brKQsHvspEhYKseScBvNZ7xMoDRkYXI4AAIAAQLwEEs1gOusk1l+PbBXBD3Oe2mUK2zRBAsgTglxGCbsSrDVl1idZ127gAhr2CNL3Xe1a5JW4e87HjzCBayLYZAkiQAPyPh6JuxDWTzGakO3V7uADsbuXRZwDvuE9iPh11bBaybYYA3lEAgSyWGaKuyu1lfbBK9b/oENrjehsbaolmlyNJfb7VyaxCybWZrb3sBr0tkXkUsruCG3NW1WbjDB20t2jmzQK2zRDAGwsgkMXyUQACrso9+UfXeruDq9tUr/Vr7PBaTPOtTmYtawKY0qTnlK/HTQ5R9N0VDgJoptmgg0Vz5vifXLJthgDeWQBBLJZ3dYOYq/KsOcz3ByybaM/OZ7aiO1nVyqbcrU5m7SwE+JAazY55PW5yjMJdwY05yyxn2aC9RTNvXgnYNkMAiSmBLlssu8W9oKtyyyDW5IflI+3hTVX2M0VZtStJY74VnzVAcs3LOb8S6NwSmUdR2MXNY+YCyO1KILYBb65ft22GAJJwERwtYsllETwHANEJYMh+kmQYcXJBACCxZwAIAEAAEACAACAAcB+b7i/XYNXo9XqrR3sTz7qmT0+A16Ejc1beImvely9DKiwf/q10fBkMvCJp2dwux/qzlsPXgcELkZrqrTohxfaT14UhBIgeSzNb7QjXhyUQiJC6YuZfIQ6YwoEI+Ox8vFTGwRYUPLH2+ekUX/OshEsD8Pj0n6rzV44PPw0AHnr0f+30P700wI/DgLDTX6624xQvLg1AmIzicfT3uDTAD0SCu8m/6KVvgEuD3U8EAxD8MFp9hx+WPrk0aHZQGAHhxGl13uhycqgptjKWet/4YIEQ2ap3Ad1SIqT7dcuJrLx/h7owaYyd50SaQQbFu/rx/b3qSL/m8ZG7YaP29HAWyD0tUnwbJs5Ysl4h7yeAZwIBxJj5pTv/516bRMxu+dpAkYnCEUBQg+i/VtUi20MA8b34teUgn6yQUfJIkqS+6pk5gRyXHyQA74iNzS8BCLpcQwAxp6QOye0C8Dk0jhy/I7yf47L3TI8QgHfIIyfVLe+6uQBEXa4hgHgf/lvXCuZzq8FLRsk7Q+eDAFg60fY2az86LnNvwumvicgf8+gQBBDI2JqeAcZbqbCs7K2qRV2uIYA4sylffXlg98meuC1fMkreGTqzEmi1F8AynRmw9qPjMp9p9WuiM/Po+wUQyNiaSXZuSNJ8b1Ut7HINAcT35k9LJpaoAI5uyxeNkl275V9nACYA1n50XObm0atfE52ZR4cggCDG1ixitVPvb/ZW1cIu1xBAXKmXFwKjvEsgP6NkZui8WPIzgHFSAv1v71zUE9WhKAxKEZXBQlGsgjda1ILWenn/VxsStCoiAhYRWP93TqdGtDFksRPcWVmR8qPjsnUcAh3eiPGbR//5ECjc2JoIoPU+720PVtWRXa4hgJzi2JF2dr77zN7a/y4MfA8AUoI1Zg86sxAAeD6WQjcPZxYCAOkMfzr5OLMQAEgBxZ4xEAAEUFa0QZyVg0brjF5vMeDfWg9CSCQAs/V4TPSrvFCPt0xKfzulPqpW3z/eHoaS4AMqbxmgo2PlA6svJo4cnG3z669FF60I8sp0oCfs/KrKk5e2JDQiyC0bI8GYYtW3becFjQdyj/Ma9xUVUTU5jHlAMYb/8YYv1sY2d5jcgYLACnE6s9ax7ZmCVgNFQZejj2SWNZPDoB8UiVY76t3/pm06uPSDYvHJRTpMqZv2G+wEQdGmv5GSfyzJEHCXHxRw+itHmP42d6aEaz8oIF3h5oTWHfe/oaFAIYc/mnzD9HnKY9YLIvJiJ/YP3mZT42b47R+WM4e3N5RwHm8MbSc0trUzs7JulUEAy8S5lIqaSYVn/bDoUDf7kdYGZLDco55wq6bsVqbUIIDnE4Dzef05XRVaz3tuIYCnZJVYAFYWAuhIIUMfTnnmcwsBIALcPf81m1eeaRmqds+5jeyRfq133zYc/ysBxPVGv1JfBg7p1yLAWctY805geRYRwDJWwRf/T1W07u1Vvo8XZDj+7S+PZTiemgCuuLkH9e9YVu7ljAC/7bD/RfzuBZZnEAGU4OzPZl+d/kGvuu2RTgVwFnZiGY4nEEDFuimAiFX1jrxm5X4lGJQqAmyIk7a4mFeJVzZx2CY+4S6LbU93i52Rr/zxEYCVp39y8T89t9c90t0Cv+P4PgLQEp8zOnXbvOGMnkAA9ng9C6jqhbf5sarc0c2d+d4wgkMPpLVwj6QVjuAJX8YIQJ20xV6Ftgxx2PauCpUxw8tuMeMrf3wEqARkPy/7/YRbqd/0SHf/8zuOHwRAvcbPndGp3/INZ/S6ocZlXa1+jYSLql54mx+rOjm6ufPLtTWx6IG0FuRV/LG+YZ7wZYwA1ElbbHte2cRhm/iEM8zObaM5McP0lT88AjQuvv5NevE/E8BVj3SvV505jh8EQEp8zuieAMKd0RNEAHO+cKzLql54m59U9eiNzjC91/2B9Bn3SFrhdQRP+BJGAOqk7X566pVNHLbdX1Y/zMS9oPzIrgBOyzOIAJrsu8W5NFXtjve76ZH+O644eqSTy6q9F4DPGd0bAoU7oycQwIsSWNULb/NjVf/tvdHdqn4w3JfmHUhrQU4cqbB22xO+5HeBot6TeaAAtPP0B0uMc8//SeZ3+B4gF3eBYtyU+SD5In1xyaZeSV047f/dodHM4bmFAAoZAZSVxJH5ms1tKg/p/0vbvm+79Jeftg4BQAD3R4CzIZCibYgQzDa36abX/92xj3PnIpfpdl79mq8hAAjgzggQPAkOFMJdXjy6eejyLzsh6dinsqzzXo4vNxu/97aIABDA/uaCmThdfBMqj1MhjEYcIyf9M8cXftyoq3z56TaOatJb6s7m96YRWU/JPT673pwmO0NGZusBsKbuD1D0ekcdV/+NvhPPNWJfsdiV2FG9iYm0wtIwkDXsfPLNt9P/O8JhlCPpLFodPA1WcE5XrATkKEnABkxvwdOSJAE5Xr4xtrUCuRVA8OU9Xr4xBACeXwCxEpB9+cZBScBO2dJ3Qb4FECsB2ZdvHJQEvChb+i7IuQDiJCD78o2DkoAXZcteBIUaAoUnIPvyjYOSgB0IAORyEpzPPwEABABALCraY3qn0GygscHzob+PfwaD9P9OWxp6uRA7Z6thawAQxLKZHpcJOJY2e3U75Lz6vhDS/2y/QYbVDlmgF+lwrPtIaWaEhv6XOQMpNU780r18TNO0uQ25FI/XGjMYJoQ//qaGHvgaFGQaTS8z1DQ6YrPLMOJ80F2aUja00f+KPBedbUn+vZeILDZPF0iS0FB5SUhLOPym9QUn7MjQNZmWtnV2tdq6Wp3/cMVrfJD5ObBmZu2zNf37N9ZPLCFaxp0rggfz3jcvQgAQQAiR0pSJW9b5gbO0tow5WxTf5c17di5puHOAZf3iAycwXBbbsd8DAnhWATRG/6pOgABm1aX7vx5NAFJqeyb5bLEkYXfXgpfbAgg2XB5vLwVw4reMfO38CsAeKIGnbjaRme9JRAHM0ts0zG8Mp9WuOKX/hQCuGS6zA/n0aSqAU79l5GvnSAAkoUb8eZ+oXwt6dsdCi5r6UZPounDwih58/CiLhb5/+D7W6Y/fh7t9hnLaEYBhpn5rUOXTSGwOdxBAmOGyPzObRID5jnxw92naVPTJU7/lENPmBgTwZAIgOcXiT3ctv4zonrtaZzInV1lqEl0XDl7Rsw9B3i107+FPhf+gP34fjvcZyqlHAGIOfbE3sK4K27sEEGa47M/Mpn6z+9ahL2Q8l+gTv+UQ0+YhBPBsAhAUEsMNh1l7AxxFrRJfY2oSXRcOXtGzD/2ru9C9h78C+H043mcopx8B3ArKl18jWaKwq9whgBDDZX9mNhUA/eDu09QCmj556rccZtoMATzjEGgvgNUP03ZneBKJ69Qkui4cvKJnJPgvdO+hG8pX9Mfvw90+Q/kBEYBsEBM07G8M22JSAYQZLp9nZhPD5e+9hbb7tDcEoh37xG85xLQZAnjySXDk235iyJeZUso7Z1tXtubeGPY0kQBy1PggBwKYpb51PD8LLu++xtorAwKAANJASl0AzOvV4c7WtJcQAMjyHKQfAdwIxF8fIUmmrUEAoMgRwL3St0PGOixnDisQAAhhkJ6ZsLx6xAfQ5dA0iClvOsrNt8jKbxn9D9xNd3Djnk/TFKTQAyysFgM55sqO8WfTAaOmo6FAQbHC9+bwpgOfpgoNgIIyjPLtL+sIxhJtBYqIZEc6zI0DtRVaCxSPlRwxC451THuGWS8oGhU5+hC/aZtcBU0GijUV7sTZxXCl2n1MCECh+HyNdbgiGUIf3lSgOLTkuKsip5xpi9hCEhSEqZDAJaip2rYEEYAiwLYTmQRZzb5pcFQ8DcyOQZ5xOklfqXGqyuvyuINGBDlmeekXEUcEk+q/yQqtCHI8DLITL0RwjNp8Ph717DRzoAc4RSBdOD7pC6cPqB1WAYDUh0FCBQIAJaYib/9EAIl8ohmGvwhBJ/YZEAB4APxrKgII0oM6/1qzPgH4fbQhAPBgmvL0rwUQHA0242VjLfsF4PPRhgDAo1FqYkIBUKvDc4/nGSkK9okmhriN0WeN2Q2pT7Y2el/zM89Hm7y0Rg6DJzR4PJLBJhIAdXs+93j+IkXBPtEnAqB20bLJfvN7H23y0jk5DJ7QIANehLdEAhA8AZx4PNOiYJ9odwj0sm6L35X1kNpF7wXg+WgT0xZyGCxxQSaINhtfAP4hUO9fVSVFAT7Rqx8yCa6uLdYd+AypXfR+CMQQH23y0ndiJw0BgIyCgPkWWwDxJ9yjbvSDIQDwUByTTVsAsYAAwGPpmiIEAMpMK+KKeQgAFBOlz1sQACgxujCLIAD+M32QDg0yoX57HMRqD6CBUwGyGQd1VKx9B2VmagzhighKPRUwOEgAlJntjf1iACg4UruORgAlxtrWHAyEQKkHQm1OQSuAEqPV2tg0DJQZljckjIRAmXkz7RVaAZQYxTF2UzQDKDEvvNnHdACUmcqnWWuR+UAD94ZAScdCm7660wdjkflMyxdaQC4eeO7BEDeqfi3MtN6e76KJwXMzHk8mPQsCACXGv2aRGsIlfrcTV1AIABRDAJd6YKsu7+SJEF9oCADkXwBXg8HY+yfEFxoCADkSADFI3Psjur2e+DwvSdGo+o8J8Ih2BSAu5h9uBLjuCw0BgBwJgHhE7y2i3R5PfJ5lUkQiQIBHNBFAr0KGQNd9oSEAkCcBCMrBIpoIgPg8kyJpwAR5RBMBtOkc4LovNAQA8jsE6v2rcqSoMf9igjyijwJgrvlCQwAgj5PgPwMCABAAABAAABAAABAAAE8nACUlIACQB2b9tMBqGwAAAOAJ+A+Cmhblc05krwAAAABJRU5ErkJggg==" alt="Inheritance diagram of matplotlib.collections" usemap="#inheritance829eaf436e" class="inheritance graphviz"></div> <map id="inheritance829eaf436e" name="inheritance829eaf436e"> <area shape="rect" id="node1" href="artist_api.html#matplotlib.artist.Artist" target="_top" title="Abstract base class for objects that render into a FigureCanvas." alt="" coords="20,155,78,170"> <area shape="rect" id="node9" href="#matplotlib.collections.Collection" target="_top" title="Base class for Collections.  Must be subclassed to be usable." alt="" coords="124,170,224,186"> <area shape="rect" id="node2" href="cm_api.html#matplotlib.cm.ScalarMappable" target="_top" title="This is a mixin class to support scalar data to RGBA mapping." alt="" coords="3,185,95,201"> <area shape="rect" id="node3" href="#matplotlib.collections.AsteriskPolygonCollection" target="_top" title="Draw a collection of regular asterisks with *numsides* points." alt="" coords="601,3,765,19"> <area shape="rect" id="node4" href="#matplotlib.collections.RegularPolyCollection" target="_top" title="Draw a collection of regular polygons with *numsides*." alt="" coords="425,34,571,49"> <area shape="rect" id="node16" href="#matplotlib.collections.StarPolygonCollection" target="_top" title="Draw a collection of regular stars with *numsides* points." alt="" coords="610,34,756,49"> <area shape="rect" id="node5" href="#matplotlib.collections.BrokenBarHCollection" target="_top" title="A collection of horizontal bars spanning *yrange* with a sequence of" alt="" coords="610,64,756,79"> <area shape="rect" id="node6" href="#matplotlib.collections.PolyCollection" target="_top" title="collections.PolyCollection" alt="" coords="440,64,556,79"> <area shape="rect" id="node7" href="#matplotlib.collections.CircleCollection" target="_top" title="A collection of circles, drawn using splines." alt="" coords="437,94,559,110"> <area shape="rect" id="node14" href="#matplotlib.collections.PathCollection" target="_top" title="This is the most basic :class:`Collection` subclass." alt="" coords="440,124,556,140"> <area shape="rect" id="node10" href="#matplotlib.collections.EllipseCollection" target="_top" title="A collection of ellipses, drawn using splines." alt="" coords="262,124,387,140"> <area shape="rect" id="node12" href="#matplotlib.collections.LineCollection" target="_top" title="All parameters must be sequences or scalars; if scalars, they will" alt="" coords="267,155,382,170"> <area shape="rect" id="node13" href="#matplotlib.collections.PatchCollection" target="_top" title="A generic collection of patches." alt="" coords="264,185,384,201"> <area shape="rect" id="node15" href="#matplotlib.collections.QuadMesh" target="_top" title="Class for the efficient drawing of a quadrilateral mesh." alt="" coords="274,215,375,231"> <area shape="rect" id="node17" href="#matplotlib.collections.TriMesh" target="_top" title="Class for the efficient drawing of a triangular mesh using Gouraud shading." alt="" coords="280,246,369,261"> <area shape="rect" id="node11" href="#matplotlib.collections.EventCollection" target="_top" title="A collection of discrete events." alt="" coords="437,155,559,170"> </map><p id="module-matplotlib.collections">Classes for the efficient drawing of large collections of objects that share most properties, e.g., a large number of line segments or polygons.</p> <p>The classes are not meant to be as flexible as their single element counterparts (e.g., you may not be able to select all line styles) but they are meant to be fast for common use cases (e.g., a large set of solid line segments).</p> <dl class="class"> <dt id="matplotlib.collections.AsteriskPolygonCollection">
<code>class matplotlib.collections.AsteriskPolygonCollection(numsides, rotation=0, sizes=(1, ), **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#AsteriskPolygonCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection" title="matplotlib.collections.RegularPolyCollection"><code>matplotlib.collections.RegularPolyCollection</code></a></p> <p>Draw a collection of regular asterisks with <em>numsides</em> points.</p> <dl class="docutils"> <dt><em>numsides</em></dt> <dd>the number of sides of the polygon</dd> <dt><em>rotation</em></dt> <dd>the rotation of the polygon in radians</dd> <dt><em>sizes</em></dt> <dd>
<p class="first">gives the area of the circle circumscribing the regular polygon in points^2</p> <p>Valid Collection keyword arguments:</p>  <ul class="simple"> <li>
<em>edgecolors</em>: None</li> <li>
<em>facecolors</em>: None</li> <li>
<em>linewidths</em>: None</li> <li>
<em>antialiaseds</em>: None</li> <li>
<em>offsets</em>: None</li> <li>
<em>transOffset</em>: transforms.IdentityTransform()</li> <li>
<em>norm</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> <li>
<em>cmap</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> </ul>  <p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after rendering (default no offsets)</p> <p class="last">If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em> are None, they default to their <a class="reference internal" href="matplotlib_configuration_api#matplotlib.rcParams" title="matplotlib.rcParams"><code>matplotlib.rcParams</code></a> patch setting, in sequence form.</p> </dd> </dl> <p>Example: see <a class="reference internal" href="https://matplotlib.org/3.1.1/gallery/event_handling/lasso_demo.html"><span class="doc">Lasso Demo</span></a> for a complete example:</p> <pre data-language="python">offsets = np.random.rand(20,2)
facecolors = [cm.jet(x) for x in np.random.rand(20)]
black = (0,0,0,1)

collection = RegularPolyCollection(
    numsides=5, # a pentagon
    rotation=0, sizes=(50,),
    facecolors=facecolors,
    edgecolors=(black,),
    linewidths=(1,),
    offsets=offsets,
    transOffset=ax.transData,
    )
</pre> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.remove_callback" title="matplotlib.collections.AsteriskPolygonCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.remove_callback" title="matplotlib.collections.AsteriskPolygonCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.AsteriskPolygonCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.AsteriskPolygonCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.draw">
<code>draw(self, renderer)</code> </dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.get_cursor_data" title="matplotlib.collections.AsteriskPolygonCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_contains" title="matplotlib.collections.AsteriskPolygonCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.format_cursor_data" title="matplotlib.collections.AsteriskPolygonCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.format_cursor_data" title="matplotlib.collections.AsteriskPolygonCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.get_linestyle" title="matplotlib.collections.AsteriskPolygonCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.get_edgecolor" title="matplotlib.collections.AsteriskPolygonCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.get_edgecolor" title="matplotlib.collections.AsteriskPolygonCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.get_facecolor" title="matplotlib.collections.AsteriskPolygonCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.get_facecolor" title="matplotlib.collections.AsteriskPolygonCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.get_linestyle" title="matplotlib.collections.AsteriskPolygonCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.get_linewidth" title="matplotlib.collections.AsteriskPolygonCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.get_linestyle" title="matplotlib.collections.AsteriskPolygonCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.get_linewidth" title="matplotlib.collections.AsteriskPolygonCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_numsides">
<code>get_numsides(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_paths">
<code>get_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_picker" title="matplotlib.collections.AsteriskPolygonCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.pick" title="matplotlib.collections.AsteriskPolygonCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_rotation">
<code>get_rotation(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_sizes">
<code>get_sizes(self)</code> </dt> <dd>
<p>Returns the sizes of the elements in the collection. The value represents the 'area' of the element.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : array</code> </dt> <dd>
<p class="first last">The 'area' of each element.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_snap" title="matplotlib.collections.AsteriskPolygonCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_transform" title="matplotlib.collections.AsteriskPolygonCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.AsteriskPolygonCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.add_callback" title="matplotlib.collections.AsteriskPolygonCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.remove_callback" title="matplotlib.collections.AsteriskPolygonCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.pickable" title="matplotlib.collections.AsteriskPolygonCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.pick" title="matplotlib.collections.AsteriskPolygonCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.add_callback" title="matplotlib.collections.AsteriskPolygonCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_antialiased" title="matplotlib.collections.AsteriskPolygonCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_antialiased" title="matplotlib.collections.AsteriskPolygonCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.contains" title="matplotlib.collections.AsteriskPolygonCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_linestyle" title="matplotlib.collections.AsteriskPolygonCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_edgecolor" title="matplotlib.collections.AsteriskPolygonCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_edgecolor" title="matplotlib.collections.AsteriskPolygonCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_facecolor" title="matplotlib.collections.AsteriskPolygonCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_facecolor" title="matplotlib.collections.AsteriskPolygonCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_linestyle" title="matplotlib.collections.AsteriskPolygonCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_linewidth" title="matplotlib.collections.AsteriskPolygonCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_linestyle" title="matplotlib.collections.AsteriskPolygonCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.AsteriskPolygonCollection.set_linewidth" title="matplotlib.collections.AsteriskPolygonCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_paths">
<code>set_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_sizes">
<code>set_sizes(self, sizes, dpi=72.0)</code> </dt> <dd>
<p>Set the sizes of each member of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : ndarray or None</code> </dt> <dd>
<p class="first last">The size to set for each element of the collection. The value is the 'area' of the element.</p> </dd> <dt>
<code>dpi : float</code> </dt> <dd>
<p class="first last">The dpi of the canvas. Defaults to 72.0.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.AsteriskPolygonCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.AsteriskPolygonCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.AsteriskPolygonCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.AsteriskPolygonCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.BrokenBarHCollection">
<code>class matplotlib.collections.BrokenBarHCollection(xranges, yrange, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#BrokenBarHCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code>matplotlib.collections.PolyCollection</code></a></p> <p>A collection of horizontal bars spanning <em>yrange</em> with a sequence of <em>xranges</em>.</p> <dl class="docutils"> <dt><em>xranges</em></dt> <dd>sequence of (<em>xmin</em>, <em>xwidth</em>)</dd> <dt><em>yrange</em></dt> <dd>
<p class="first"><em>ymin</em>, <em>ywidth</em></p> <p>Valid Collection keyword arguments:</p>  <ul class="simple"> <li>
<em>edgecolors</em>: None</li> <li>
<em>facecolors</em>: None</li> <li>
<em>linewidths</em>: None</li> <li>
<em>antialiaseds</em>: None</li> <li>
<em>offsets</em>: None</li> <li>
<em>transOffset</em>: transforms.IdentityTransform()</li> <li>
<em>norm</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> <li>
<em>cmap</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> </ul>  <p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after rendering (default no offsets)</p> <p class="last">If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em> are None, they default to their <a class="reference internal" href="matplotlib_configuration_api#matplotlib.rcParams" title="matplotlib.rcParams"><code>matplotlib.rcParams</code></a> patch setting, in sequence form.</p> </dd> </dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.remove_callback" title="matplotlib.collections.BrokenBarHCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.remove_callback" title="matplotlib.collections.BrokenBarHCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.BrokenBarHCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.BrokenBarHCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.draw">
<code>draw(self, renderer)</code> </dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.get_cursor_data" title="matplotlib.collections.BrokenBarHCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_contains" title="matplotlib.collections.BrokenBarHCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.format_cursor_data" title="matplotlib.collections.BrokenBarHCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.format_cursor_data" title="matplotlib.collections.BrokenBarHCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.get_linestyle" title="matplotlib.collections.BrokenBarHCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.get_edgecolor" title="matplotlib.collections.BrokenBarHCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.get_edgecolor" title="matplotlib.collections.BrokenBarHCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.get_facecolor" title="matplotlib.collections.BrokenBarHCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.get_facecolor" title="matplotlib.collections.BrokenBarHCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.get_linestyle" title="matplotlib.collections.BrokenBarHCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.get_linewidth" title="matplotlib.collections.BrokenBarHCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.get_linestyle" title="matplotlib.collections.BrokenBarHCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.get_linewidth" title="matplotlib.collections.BrokenBarHCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_paths">
<code>get_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_picker" title="matplotlib.collections.BrokenBarHCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.pick" title="matplotlib.collections.BrokenBarHCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_sizes">
<code>get_sizes(self)</code> </dt> <dd>
<p>Returns the sizes of the elements in the collection. The value represents the 'area' of the element.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : array</code> </dt> <dd>
<p class="first last">The 'area' of each element.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_snap" title="matplotlib.collections.BrokenBarHCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_transform" title="matplotlib.collections.BrokenBarHCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.BrokenBarHCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.add_callback" title="matplotlib.collections.BrokenBarHCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.remove_callback" title="matplotlib.collections.BrokenBarHCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.pickable" title="matplotlib.collections.BrokenBarHCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.pick" title="matplotlib.collections.BrokenBarHCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.add_callback" title="matplotlib.collections.BrokenBarHCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_antialiased" title="matplotlib.collections.BrokenBarHCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_antialiased" title="matplotlib.collections.BrokenBarHCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.contains" title="matplotlib.collections.BrokenBarHCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_linestyle" title="matplotlib.collections.BrokenBarHCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_edgecolor" title="matplotlib.collections.BrokenBarHCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_edgecolor" title="matplotlib.collections.BrokenBarHCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_facecolor" title="matplotlib.collections.BrokenBarHCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_facecolor" title="matplotlib.collections.BrokenBarHCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_linestyle" title="matplotlib.collections.BrokenBarHCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_linewidth" title="matplotlib.collections.BrokenBarHCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_linestyle" title="matplotlib.collections.BrokenBarHCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection.set_linewidth" title="matplotlib.collections.BrokenBarHCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_paths">
<code>set_paths(self, verts, closed=True)</code> </dt> <dd>
<p>This allows one to delay initialization of the vertices.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_sizes">
<code>set_sizes(self, sizes, dpi=72.0)</code> </dt> <dd>
<p>Set the sizes of each member of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : ndarray or None</code> </dt> <dd>
<p class="first last">The size to set for each element of the collection. The value is the 'area' of the element.</p> </dd> <dt>
<code>dpi : float</code> </dt> <dd>
<p class="first last">The dpi of the canvas. Defaults to 72.0.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_verts">
<code>set_verts(self, verts, closed=True)</code> </dt> <dd>
<p>This allows one to delay initialization of the vertices.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_verts_and_codes">
<code>set_verts_and_codes(self, verts, codes)</code> </dt> <dd>
<p>This allows one to initialize vertices with path codes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.collections.BrokenBarHCollection.span_where">
<code>static span_where(x, ymin, ymax, where, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#BrokenBarHCollection.span_where"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a BrokenBarHCollection to plot horizontal bars from over the regions in <em>x</em> where <em>where</em> is True. The bars range on the y-axis from <em>ymin</em> to <em>ymax</em></p> <p>A <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection" title="matplotlib.collections.BrokenBarHCollection"><code>BrokenBarHCollection</code></a> is returned. <em>kwargs</em> are passed on to the collection.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.BrokenBarHCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.BrokenBarHCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.BrokenBarHCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.BrokenBarHCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.CircleCollection">
<code>class matplotlib.collections.CircleCollection(sizes, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#CircleCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.collections._CollectionWithSizes</code></p> <p>A collection of circles, drawn using splines.</p> <p><em>sizes</em> Gives the area of the circle in points^2</p> <p>Valid Collection keyword arguments:</p>  <ul class="simple"> <li>
<em>edgecolors</em>: None</li> <li>
<em>facecolors</em>: None</li> <li>
<em>linewidths</em>: None</li> <li>
<em>antialiaseds</em>: None</li> <li>
<em>offsets</em>: None</li> <li>
<em>transOffset</em>: transforms.IdentityTransform()</li> <li>
<em>norm</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> <li>
<em>cmap</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> </ul>  <p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after rendering (default no offsets)</p> <p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em> are None, they default to their <a class="reference internal" href="matplotlib_configuration_api#matplotlib.rcParams" title="matplotlib.rcParams"><code>matplotlib.rcParams</code></a> patch setting, in sequence form.</p> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.CircleCollection.remove_callback" title="matplotlib.collections.CircleCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.CircleCollection.remove_callback" title="matplotlib.collections.CircleCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.CircleCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.CircleCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.draw">
<code>draw(self, renderer)</code> </dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.CircleCollection.get_cursor_data" title="matplotlib.collections.CircleCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_contains" title="matplotlib.collections.CircleCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.CircleCollection.format_cursor_data" title="matplotlib.collections.CircleCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.CircleCollection.format_cursor_data" title="matplotlib.collections.CircleCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.get_linestyle" title="matplotlib.collections.CircleCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.get_edgecolor" title="matplotlib.collections.CircleCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.get_edgecolor" title="matplotlib.collections.CircleCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.get_facecolor" title="matplotlib.collections.CircleCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.get_facecolor" title="matplotlib.collections.CircleCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.get_linestyle" title="matplotlib.collections.CircleCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.get_linewidth" title="matplotlib.collections.CircleCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.get_linestyle" title="matplotlib.collections.CircleCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.get_linewidth" title="matplotlib.collections.CircleCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_paths">
<code>get_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_picker" title="matplotlib.collections.CircleCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.CircleCollection.pick" title="matplotlib.collections.CircleCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_sizes">
<code>get_sizes(self)</code> </dt> <dd>
<p>Returns the sizes of the elements in the collection. The value represents the 'area' of the element.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : array</code> </dt> <dd>
<p class="first last">The 'area' of each element.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_snap" title="matplotlib.collections.CircleCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_transform" title="matplotlib.collections.CircleCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.CircleCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.CircleCollection.add_callback" title="matplotlib.collections.CircleCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.CircleCollection.remove_callback" title="matplotlib.collections.CircleCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.CircleCollection.pickable" title="matplotlib.collections.CircleCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.CircleCollection.pick" title="matplotlib.collections.CircleCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.CircleCollection.add_callback" title="matplotlib.collections.CircleCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_antialiased" title="matplotlib.collections.CircleCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_antialiased" title="matplotlib.collections.CircleCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.CircleCollection.contains" title="matplotlib.collections.CircleCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_linestyle" title="matplotlib.collections.CircleCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_edgecolor" title="matplotlib.collections.CircleCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_edgecolor" title="matplotlib.collections.CircleCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_facecolor" title="matplotlib.collections.CircleCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_facecolor" title="matplotlib.collections.CircleCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_linestyle" title="matplotlib.collections.CircleCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_linewidth" title="matplotlib.collections.CircleCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_linestyle" title="matplotlib.collections.CircleCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.CircleCollection.set_linewidth" title="matplotlib.collections.CircleCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_paths">
<code>set_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_sizes">
<code>set_sizes(self, sizes, dpi=72.0)</code> </dt> <dd>
<p>Set the sizes of each member of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : ndarray or None</code> </dt> <dd>
<p class="first last">The size to set for each element of the collection. The value is the 'area' of the element.</p> </dd> <dt>
<code>dpi : float</code> </dt> <dd>
<p class="first last">The dpi of the canvas. Defaults to 72.0.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.CircleCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.CircleCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.CircleCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.CircleCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.Collection">
<code>class matplotlib.collections.Collection(edgecolors=None, facecolors=None, linewidths=None, linestyles='solid', capstyle=None, joinstyle=None, antialiaseds=None, offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5.0, hatch=None, urls=None, offset_position='screen', zorder=1, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>matplotlib.artist.Artist</code></a>, <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a></p> <p>Base class for Collections. Must be subclassed to be usable.</p> <p>All properties in a collection must be sequences or scalars; if scalars, they will be converted to sequences. The property of the ith element of the collection is:</p> <pre data-language="python">prop[i % len(props)]
</pre> <p>Exceptions are <em>capstyle</em> and <em>joinstyle</em> properties, these can only be set globally for the whole collection.</p> <p>Keyword arguments and default values:</p>  <ul class="simple"> <li>
<em>edgecolors</em>: None</li> <li>
<em>facecolors</em>: None</li> <li>
<em>linewidths</em>: None</li> <li>
<em>capstyle</em>: None</li> <li>
<em>joinstyle</em>: None</li> <li>
<em>antialiaseds</em>: None</li> <li>
<em>offsets</em>: None</li> <li>
<em>transOffset</em>: transforms.IdentityTransform()</li> <li>
<em>offset_position</em>: 'screen' (default) or 'data'</li> <li>
<em>norm</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> <li>
<em>cmap</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> <li>
<em>hatch</em>: None</li> <li>
<em>zorder</em>: 1</li> </ul>  <p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after rendering (default no offsets). If offset_position is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em> are None, they default to their <a class="reference internal" href="matplotlib_configuration_api#matplotlib.rcParams" title="matplotlib.rcParams"><code>matplotlib.rcParams</code></a> patch setting, in sequence form.</p> <p>The use of <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>ScalarMappable</code></a> is optional. If the <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>ScalarMappable</code></a> matrix _A is not None (i.e., a call to set_array has been made), at draw time a call to scalar mappable will be made to set the face colors.</p> <p>Create a Collection</p> <p>%(Collection)s</p> <dl class="method"> <dt id="matplotlib.collections.Collection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.Collection.remove_callback" title="matplotlib.collections.Collection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.Collection.remove_callback" title="matplotlib.collections.Collection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.Collection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.Collection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.contains">
<code>contains(self, mouseevent)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.contains"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.draw">
<code>draw(self, renderer)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.draw"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.Collection.get_cursor_data" title="matplotlib.collections.Collection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_capstyle">
<code>get_capstyle(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_capstyle"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.Collection.set_contains" title="matplotlib.collections.Collection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.Collection.format_cursor_data" title="matplotlib.collections.Collection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.Collection.format_cursor_data" title="matplotlib.collections.Collection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.get_linestyle" title="matplotlib.collections.Collection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_datalim">
<code>get_datalim(self, transData)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_datalim"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.get_edgecolor" title="matplotlib.collections.Collection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_edgecolor">
<code>get_edgecolor(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_edgecolor"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.get_edgecolor" title="matplotlib.collections.Collection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_facecolor">
<code>get_facecolor(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_facecolor"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.get_facecolor" title="matplotlib.collections.Collection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.get_facecolor" title="matplotlib.collections.Collection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_fill">
<code>get_fill(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_fill"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_hatch">
<code>get_hatch(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_hatch"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_joinstyle">
<code>get_joinstyle(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_joinstyle"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_linestyle">
<code>get_linestyle(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_linestyle"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.get_linestyle" title="matplotlib.collections.Collection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_linewidth">
<code>get_linewidth(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_linewidth"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.get_linewidth" title="matplotlib.collections.Collection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.get_linestyle" title="matplotlib.collections.Collection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.get_linewidth" title="matplotlib.collections.Collection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_offset_position">
<code>get_offset_position(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_offset_position"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_offset_transform">
<code>get_offset_transform(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_offset_transform"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_offsets">
<code>get_offsets(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_offsets"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_paths">
<code>get_paths(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_paths"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.Collection.set_picker" title="matplotlib.collections.Collection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.Collection.pick" title="matplotlib.collections.Collection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_pickradius">
<code>get_pickradius(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_pickradius"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.Collection.set_snap" title="matplotlib.collections.Collection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_transforms">
<code>get_transforms(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_transforms"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_urls">
<code>get_urls(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_urls"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_window_extent">
<code>get_window_extent(self, renderer)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.get_window_extent"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.Collection.set_transform" title="matplotlib.collections.Collection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.Collection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.Collection.add_callback" title="matplotlib.collections.Collection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.Collection.remove_callback" title="matplotlib.collections.Collection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.Collection.pickable" title="matplotlib.collections.Collection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.Collection.pick" title="matplotlib.collections.Collection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.Collection.add_callback" title="matplotlib.collections.Collection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_antialiased" title="matplotlib.collections.Collection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_alpha">
<code>set_alpha(self, alpha)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_alpha"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_antialiased">
<code>set_antialiased(self, aa)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_antialiased"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_antialiased" title="matplotlib.collections.Collection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_capstyle">
<code>set_capstyle(self, cs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_capstyle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_color">
<code>set_color(self, c)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_color"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.Collection.contains" title="matplotlib.collections.Collection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_linestyle" title="matplotlib.collections.Collection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_edgecolor">
<code>set_edgecolor(self, c)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_edgecolor"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_facecolor">
<code>set_facecolor(self, c)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_facecolor"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_facecolor" title="matplotlib.collections.Collection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_facecolor" title="matplotlib.collections.Collection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_hatch">
<code>set_hatch(self, hatch)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_hatch"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_joinstyle">
<code>set_joinstyle(self, js)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_joinstyle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_linestyle">
<code>set_linestyle(self, ls)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_linestyle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_linestyle" title="matplotlib.collections.Collection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_linewidth">
<code>set_linewidth(self, lw)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_linewidth"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_linewidth" title="matplotlib.collections.Collection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_linestyle" title="matplotlib.collections.Collection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.Collection.set_linewidth" title="matplotlib.collections.Collection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_offset_position"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_offsets">
<code>set_offsets(self, offsets)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_offsets"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_paths">
<code>set_paths(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_paths"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_pickradius">
<code>set_pickradius(self, pr)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_pickradius"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_urls">
<code>set_urls(self, urls)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.set_urls"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.Collection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.Collection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.update_from">
<code>update_from(self, other)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.update_from"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.Collection.update_scalarmappable">
<code>update_scalarmappable(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#Collection.update_scalarmappable"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.Collection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.EllipseCollection">
<code>class matplotlib.collections.EllipseCollection(widths, heights, angles, units='points', **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EllipseCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><code>matplotlib.collections.Collection</code></a></p> <p>A collection of ellipses, drawn using splines.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>widths : array-like</code> </dt> <dd>
<p class="first last">The lengths of the first axes (e.g., major axis lengths).</p> </dd> <dt>
<code>heights : array-like</code> </dt> <dd>
<p class="first last">The lengths of second axes.</p> </dd> <dt>
<code>angles : array-like</code> </dt> <dd>
<p class="first last">The angles of the first axes, degrees CCW from the x-axis.</p> </dd> <dt>
<code>units : {'points', 'inches', 'dots', 'width', 'height', 'x', 'y', 'xy'}</code> </dt> <dd>
<p class="first last">The units in which majors and minors are given; 'width' and 'height' refer to the dimensions of the axes, while 'x' and 'y' refer to the <em>offsets</em> data units. 'xy' differs from all others in that the angle as plotted varies with the aspect ratio, and equals the specified angle only when the aspect ratio is unity. Hence it behaves the same as the <a class="reference internal" href="_as_gen/matplotlib.patches.ellipse#matplotlib.patches.Ellipse" title="matplotlib.patches.Ellipse"><code>Ellipse</code></a> with <code>axes.transData</code> as its transform.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Other Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>**kwargs</strong></dt> <dd>
<p class="first">Additional kwargs inherited from the base <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><code>Collection</code></a>.</p> <p>Valid Collection keyword arguments:</p>  <ul class="simple"> <li>
<em>edgecolors</em>: None</li> <li>
<em>facecolors</em>: None</li> <li>
<em>linewidths</em>: None</li> <li>
<em>antialiaseds</em>: None</li> <li>
<em>offsets</em>: None</li> <li>
<em>transOffset</em>: transforms.IdentityTransform()</li> <li>
<em>norm</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> <li>
<em>cmap</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> </ul>  <p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after rendering (default no offsets)</p> <p class="last">If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em> are None, they default to their <a class="reference internal" href="matplotlib_configuration_api#matplotlib.rcParams" title="matplotlib.rcParams"><code>matplotlib.rcParams</code></a> patch setting, in sequence form.</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.EllipseCollection.remove_callback" title="matplotlib.collections.EllipseCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EllipseCollection.remove_callback" title="matplotlib.collections.EllipseCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EllipseCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EllipseCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.draw">
<code>draw(self, renderer)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EllipseCollection.draw"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EllipseCollection.get_cursor_data" title="matplotlib.collections.EllipseCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_contains" title="matplotlib.collections.EllipseCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.EllipseCollection.format_cursor_data" title="matplotlib.collections.EllipseCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EllipseCollection.format_cursor_data" title="matplotlib.collections.EllipseCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.get_linestyle" title="matplotlib.collections.EllipseCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.get_edgecolor" title="matplotlib.collections.EllipseCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.get_edgecolor" title="matplotlib.collections.EllipseCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.get_facecolor" title="matplotlib.collections.EllipseCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.get_facecolor" title="matplotlib.collections.EllipseCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.get_linestyle" title="matplotlib.collections.EllipseCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.get_linewidth" title="matplotlib.collections.EllipseCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.get_linestyle" title="matplotlib.collections.EllipseCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.get_linewidth" title="matplotlib.collections.EllipseCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_paths">
<code>get_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_picker" title="matplotlib.collections.EllipseCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.EllipseCollection.pick" title="matplotlib.collections.EllipseCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_snap" title="matplotlib.collections.EllipseCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_transform" title="matplotlib.collections.EllipseCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EllipseCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EllipseCollection.add_callback" title="matplotlib.collections.EllipseCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.EllipseCollection.remove_callback" title="matplotlib.collections.EllipseCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.EllipseCollection.pickable" title="matplotlib.collections.EllipseCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.EllipseCollection.pick" title="matplotlib.collections.EllipseCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EllipseCollection.add_callback" title="matplotlib.collections.EllipseCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_antialiased" title="matplotlib.collections.EllipseCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_antialiased" title="matplotlib.collections.EllipseCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.EllipseCollection.contains" title="matplotlib.collections.EllipseCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_linestyle" title="matplotlib.collections.EllipseCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_edgecolor" title="matplotlib.collections.EllipseCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_edgecolor" title="matplotlib.collections.EllipseCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_facecolor" title="matplotlib.collections.EllipseCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_facecolor" title="matplotlib.collections.EllipseCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_linestyle" title="matplotlib.collections.EllipseCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_linewidth" title="matplotlib.collections.EllipseCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_linestyle" title="matplotlib.collections.EllipseCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EllipseCollection.set_linewidth" title="matplotlib.collections.EllipseCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_paths">
<code>set_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EllipseCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EllipseCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EllipseCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EllipseCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.EventCollection">
<code>class matplotlib.collections.EventCollection(positions, orientation=None, lineoffset=0, linelength=1, linewidth=None, color=None, linestyle='solid', antialiased=None, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.collections.LineCollection" title="matplotlib.collections.LineCollection"><code>matplotlib.collections.LineCollection</code></a></p> <p>A collection of discrete events.</p> <p>The events are given by a 1-dimensional array, usually the position of something along an axis, such as time or length. They do not have an amplitude and are displayed as vertical or horizontal parallel bars.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>positions : 1D array-like object</code> </dt> <dd>
<p class="first last">Each value is an event.</p> </dd> <dt>
<code>orientation : {None, 'horizontal', 'vertical'}, optional</code> </dt> <dd>
<p class="first last">The orientation of the <strong>collection</strong> (the event bars are along the orthogonal direction). Defaults to 'horizontal' if not specified or None.</p> </dd> <dt>
<code>lineoffset : scalar, optional, default: 0</code> </dt> <dd>
<p class="first last">The offset of the center of the markers from the origin, in the direction orthogonal to <em>orientation</em>.</p> </dd> <dt>
<code>linelength : scalar, optional, default: 1</code> </dt> <dd>
<p class="first last">The total height of the marker (i.e. the marker stretches from <code>lineoffset - linelength/2</code> to <code>lineoffset + linelength/2</code>).</p> </dd> <dt>
<code>linewidth : scalar or None, optional, default: None</code> </dt> <dd>
<p class="first last">If it is None, defaults to its rcParams setting, in sequence form.</p> </dd> <dt>
<code>color : color, sequence of colors or None, optional, default: None</code> </dt> <dd>
<p class="first last">If it is None, defaults to its rcParams setting, in sequence form.</p> </dd> <dt>
<code>linestyle : str or tuple, optional, default: 'solid'</code> </dt> <dd>
<p class="first">Valid strings are ['solid', 'dashed', 'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples should be of the form:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p class="last">where <em>onoffseq</em> is an even length tuple of on and off ink in points.</p> </dd> <dt>
<code>antialiased : {None, 1, 2}, optional</code> </dt> <dd>
<p class="first last">If it is None, defaults to its rcParams setting, in sequence form.</p> </dd> <dt>
<code>**kwargs : optional</code> </dt> <dd>
<p class="first last">Other keyword arguments are line collection properties. See <a class="reference internal" href="#matplotlib.collections.LineCollection" title="matplotlib.collections.LineCollection"><code>LineCollection</code></a> for a list of the valid properties.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>(<a class="reference external" href="https://matplotlib.org/3.1.1/gallery/lines_bars_and_markers/eventcollection_demo.py">Source code</a>, <a class="reference external" href="https://matplotlib.org/3.1.1/gallery/lines_bars_and_markers/eventcollection_demo.png">png</a>, <a class="reference external" href="https://matplotlib.org/3.1.1/gallery/lines_bars_and_markers/eventcollection_demo.pdf">pdf</a>)</p> <div class="figure"> <img alt="../_images/eventcollection_demo.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAHCCAMAAADsLfJ9AAABXFBMVEX////+/v5fX19/f38fd7T/+fX2+fzx8fEAAAD/fw4EBAT//v4ICAg2NjYfHx/6/P35+fn/lTc/Pz//9u7f398PDw9OTk42hby/v79BjL/k5OT/ghT/hRoofLcvgbkaGhp0dHTt9Pno6uuvr6+UlJSfn59gn8r/yJj/r2kuLi5sbGwkerZKkcKPj4//5MwmJib//PuoqKi3t7f/jix4rdLGxsb09vj/iiL/7t/F2+uJuNiWv9zo8ffY2NihxuD/zqP/u4Db6fNrpc3xeA1mZmbJycn/oEx5eXk8PDz/wo3/27uAstX/1a//8uf/6dW20ua91+n/4MTx6+aJiYn/mkJXmccVFRWrzOP/tXMdcKrh7fXs7Oz/q2CFhYVISEj/pVdXV1fU1NTV5vGrq6vM4O4od6zR4/CZmZnQ0NDw8PCjo6OgoKCnp6cwdaKcnJzMzMxPYW3apHHJhUTPhUABzI9JAAAap0lEQVR42uyd/1caxxqHB9AwgwsKAqVAC41YhRZBaNA2sZhev6Axtl4t8RwUtT23IPHm/v+/3ZldQGIAF1iWWfg8OSGQRRadx3fezzAoIQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADarFI/IT6fznvbPfru56AdVytd7qD7jH0eGVhEk+uVfoOpHdWhyULBERpSk1eOe4yhWZosLQ2niWLvcb/FQvuonmpSoQ69z1d95EfOxdMH5miiG72adBw1WJMnQBOTJ50Q3byOKb4d8Z/71YDie9W6Cz9yWFaC4ZYmhXjMlTm3EUIFmim2cpxfBCifAs5dTnVqaB510B17IGB/LAI1j+IOiTMuOZIBpcSnG796Vwep2z1K2V7pcl7yd1Ip34Zbkw5NrSRdmZy4JfCTXCmgZA4xmmZoknSnHYpbjI/LnU4nXfvt4Uom04dKpqBpYvPRvUSQpghpKKVGo2lTkH9gnVI+dFW3NpjNow6aDCb2aLx1wk+0lEgFPPyMlVi8dp5x1UmhRoONRp2clxy1lOK2fXneVerm1zz3LU2Sseu0R6mQ+i1NNxqFO/6Ea3EfRtMMTTK8Q0nTO2LLVPlIFTzV9nDFnPz7maY1TVboNf/PW/FxHZOOqCEJj/uQl5R4czBbk474J1hu3m+pnOSnqVF+xkXREd2X7e1JR604DzT0xXn5B/FjOXEvTROXX0iZaE066a4TGxiLJuf85v/oCv/7scLZU2yt4RLl3BaraprscSF4xBCD1KHJPi8kt/Z4iY/eyhNN9tWBdDajCa0JWQLat76tUqkmO3uTQsUvdHxyXvVkhGTcLU1Ug4WPmiar9JMNQ2lWb0JEm/CRbNImldZwrYp/ShlNk6raxt6LaaRDkyXlkMRqK65Cgr58osnLzk65WSySQpOPSRc/i6etSSVV1pqUp+dtfpAoSZome+Kmx97SpFCi5dtNmGKKJn+rmqzyQTnPhfif3NIAmhBfaYfeVWjoNkOeaFLpoUmDdyS5nO9RE5/iWMnl9GiS+lwTYgvFM9S3iOE0UZN9dV54pOuksy/mgUCHJg6lVraR5HVsr6VJoJsmHZNO0CO+/0ttTbTLnQ5Nek46TzVR1/pE/wxM08SWyaiNxMtnW9hy8PGBcjTDb+1laKOliXb0iSYdLayqyb6YdArquDtVQVIdmnS0sEuftbBtTWq0LgTTngA0MVMTElI8jprDF3wuEJOqkn5oxeaCS3j0QFUf1MHUjj7RhA9sKRFXA/EqDdYOA0kxh2ViiYc7PukcJoLJDk16BuK2Jvu02ngopJKHn65jMazbm6oJqQfLiuf2MZg+HJaVqr+1vOZsLa+RHZ9C2/OOW0SaMPWQliba0aea8NjcXF6zXXuUZE59yFduF7cjHAwEbsMdmrTPSzaTSqBzea2lCbmOcTFDwZgrdruD0ZwkmkCzc14ATQA0AdBk5r7swRht7+cJJV2ZVagIviB3uNLWxK/E7xIuBH7QjbYm8SS/uK3iKwL6aVISKwCrAe3GktPpvPffO4EVuA/bTNMkIxa+c1Tb2+WgwEqEJ6OJqCZhGsY3qiUI0/vJTDoCZ2v/DpAcE0aqdwsLTaBJ8/HrdZqu+8mhXQ3EO58FYif993yT8X+my6cLGG5ZNQk135pg92nLa57Vz07+L9Zk/J9pkUUPdo+XMeSSTjr9Tm6iJmsR9UTe9eJpFuNuLU1MnHRIdmNtPa+qgrJiMU1MP/ny8e5BVHUlv762gbICTboi2tjsaXHd2yorJ+8hATTpKUtHWblCWYEm/Wxpl5XIBcoKWtj+3crRzVa7rGBtZcYDcd+ysl281MqK9wgR6JECNPmC+bOjG96tRK7OUFI0fv72gxya/Pc/TST5wswXL0RJWUNJ4Xz31dxPcmjy8kUTWb40C2RjHSVFxfbb3NcvkHR6l5Q1L0oKIR/mfvgHgbgvWklZn+WS8vabudcEmjyXk2e8pCz+OPenDZroaFNmuqT8MvftGwJNUFL6Z+G5ud8JNBmgpERESZmx5dmOLAxNUFJ0ZGFogpKiIwtDE5QUHVkYmgxWUs5ESYnOQEn5PAtDE5QUHVkYmqCk6MjC0GSkkjI/pZY8zcLQZOiScqWVlJnIwtBk1JJyUZy6kmL7IgtDE5QUHVlYBk0k2DI9Qkk5mrqS0iULy6CJTHthhy8pu1MjSpcsDE2MKSl5xvIn0xGQu2VhTDoGlZQTLsrB6bRmYbSwRjG/y6eeS8uvzdq+75aFoYlxbF8xtrWWtfYn8WvXLAxNjOSMpx7v2RRmYWhiKNm1KGNX21OXhaGJ0aHnkrHIkUW7cVuvLAxNDOf0wLLhuGcWhibGZ2PLhuPeWVgGTaZh3WQawnGfLCyDJtZfhe0RjovWmnn6ZGFoMs5wvG6lAtkvC2PSGVuLkj1i7MI62Zhn4e9tMmsytb/a4HiLbR1b5cm+65eFoclYO5QLxo6s0aDwLPwHgSYTijzrjN1YIfE8k4WhyZgpRphX/iWU57IwNBk3G3kWPbFAFv6LQJNJ8v6Asd2stbMwNBk/2V3GDmRuUJ7PwtDEDE6iLC/xmzSez8LQxBROvSxSlPXJ/fF8FoYm5rB8w9i6nA2KniwMTUxiQdale11ZGJqYhli6l3CfrK4sDE3MY9sr4dL92x/0ZGFoYiJi6f5KrtfBdWZhaGJqg7Im29K9ziwMTcxlY0uqpXu9WRiamIxUS/c8C7+TaKQSHsW937yeziixVGFmNSHZS2mW7vVnYVNGatO1ercXeKlebygNfy4Wn11NJFq615+FTRkpd4qbG7tWr6d8/CJemmVNFk7zUizd8yz8q0TtwZJrhV/ag1o1CewTf+a6ecTpdIZnThNt6f5y0g3KiwGysBmahOkrUUHczd7E5aJ7zSMOKpg9TYi6637Cv0F9kCxsuiah8qf6iscx29WEcxyd8NL9QFnY9EmnFFf7WEl+g9wEEUv3a5Nbuh8sC5vewiaFJg/K4sxrQuavJrh0z7Pwjy8k02RT+agGYvshb0cCD/5c5pZAE23pfkJ7CwbMwuaMVMLjEstrPjshi46M4kndQxPB2RaLTuRtgX8NmIUnP1KzrAl5f8HYrvkNysBZGJpMOBlfTuJtge/mvnpDoImVKEZY3uS9BYNnYWgycUxfun8zeBaGJpMPPCYv3Q+ThaGJDA3KrplL98NkYWgiBSfmLd0PlYVl0GQ6f6jWYGx7WWRN3iwsgybT+SP6BmxQxNK9GZ7wLPwdgSbWFYU3KOMPPENmYUw6Unky7k33w2ZhtLASeXLJIuN9hWfoLAxNZPLkikXGmneGzsLQRCayNyw6xj33w2dhaCIV8wcsOrYXeF58PXQWhiaSeXLBtsa1U2mELAxNJGPZy/Lj8WSULAxNZOM992Qcr++8+XaELAxNpIs77/PMa/xGpdGyMDSRj+0tdmH4UiPPwm8JNJkmTrfYgcGejJiFoYmMbETZTVamLAxNpOQswq6M9OSnEbMwNJGT4whbN+6NGSNnYWgiKSeMXRrlyehZGJrISpGxXeOy8CI0mVLWGDsy5IFej56FoYm8HBmznc2ILAxN5MWY7WyGZGFoIrMnlwZ4YkgWhiZSe7I+8rZHnoV/JtBkuhl5O5tBWRiaSO7JaNvZjMrC0ERyxHa24T15PffNWwJNZoBRtrMZloWhiSU8GW47m3FZGJrIH3eG3s5mXBaGJhZAbGcbwpPfjcvC0MQKDLWdzcgsLIMmeKv5swyxnc32p4FZWAZN8IMrnkdsZxts+4mhWRiaWITjyGDbT/4xNAtj0rEKxYFeBjQ4C0MTy7DLIvpf3jE4C2PSsQzZG/3vQjc6C0MT6zDv1ftuQJ6FfyHTpgkmHZ1sb7H1yWRhGTTB8pruuKNvd6zxWRiaWIojPW3sGLIwNLEUCzfPv1rMs/BvNmgy0yx72UHW/CwMTSzGafSZ1dixZGFoYjVO+q/GjicLQxPLsdtvE/WYsjA0sRzZA5ZfNjkLQxMLtrF5drPQMwt/INAECDYiPX5WwdiyMDSxIkXGjk3NwtDEiixcsui2mVnYnJFKeBT3fvP6fSrmyuSgyWht7AXzzpuYhU0ZqU3X6t1e4KV6fcldfeUP1aHJaOXk/+ydiVcaSRfFG2yEblYXcCQKbjEqJBL3LRk1rjERzTpxNImOYzJZZs7M9/+f83U1qAg09FJVvd175nBohKJI/+Z2VfV79V4uNsTGspwLczlT8SnlR+TP1OdfEilcdCjouKGCJMu5MI8zlZJHlcdgRj34+Hnr3eRZEphY1YO6Sl5M58I8zlQ2Mq88DsXVg+lY8J/H6Y4qQOFwOIuwJHPXnVNp8SWvuTB/TBKKkzzMV/7SESFCkKMpkZjHEqe5MPeLTne38jATSdW4CTAxp6WB2+EJ47kw9yHsbiJw6yaVL8dFx/TwZKBycyfAei7MZ0Ic+65OiIO7yhUoPfVk5t0ZhrA0Vk+6pN/4zIX5nKmxhEyW17qDyvP5eCyBmQ61WfEjLnNh+88UMLGgU+lNlMdcGJi4exR7T3rBYy4MTNytfWk2xGEuDEzcrdCs9C+HuTAwcbleSNLPFQGYQC2V/J/0XxKYQK21+lMjkg2YQDdS5sL/Sl0lYAK1EJkL9yxSKvbmcExGOqvCaTeogDoX/lUaeOkDTD6IVeG8G1TlvnD0jb7dcYCJTwcmg5X7wo+qt3Zw0YEatdYnjlfmwhPqrR0MYaEmw9ei2F9dpH85QKUULTDx4PB1U8ydXB88kBZ7gAnUqBWxcHlzcBOgBEygWr0X78SYPJekQ2AC1emyUBf8+knaiQIT6I5OcvWVC9QAJWAC1WihKBbrlw/WpdkQMIFqJjnjYt9a/YuhWda3drC85i4diIWrxldfSPeWvIwJFuuN6akolpu8HN2RToEJVNVRQVxt9nr0UJKOcdGBVF0MinMa6Ra/sQ1QwhDWPVrrE99qxb72LNZvjQM38adq7vc10U3uOcYmfp8K397vazI86WIZoARM3ELJQe39viY6ZhmgBExcotXmU+EanTIMUAIm7lBZbD4VrhHLACWbMckOVwUQWuqyIB603XlgX1oMeRMTuIkubeT01LMvzbap3gVMPK2Tvsa7ws0mO8+Z3doBJs7XWn+rBZNaTj5JnzyJCZbX9FGypuud0aV7jHLPsVjvdA33i30net+8Ls2WgIkfKSkaoCQaYpR7DkycT4mRDT0Z5Z4DE0droSjmDG37Gn3DJEAJmDhZnW/F3IWxjzxiEqAETBxOyZXRD02wCFACJg6mZFwcvDT8qZ4BBgFKwMSxSpqihE3uOTBxLCWbYsHU3sAscs+BiYMpOTL3UQa558DEmQqYp4QEKNHOPQcmzqRkTiyUTX+afu45MHEoJWLZwuf3aeeeAxMnUnIgWiumFKIdoARMHEjJimi15Bbt3HNg4jwplDy12ER0h26AEjBxnFatUyIIh3SLYwATB1KySqEZurnnwMRhekqHEsq558DEcZRQqstGNUAJmDhK7xVKKBWMLdEsjgFMHEbJAa2ywlGaxTGAiYNUFjV3QzIjisUxmJ+psUQsvn1z9COSASaalBSoUkIz95z1mXos3z/fSo9Uj3rze8BES0cF2oXs96kFKLE+U/EpQQjkzyoHyb2/g8BEQ8sKJZSrCpe6aN3aYXymUvKo8njNRkdGACZalAxe19uiqOfSvUM3YJKNzCuPQ3HyPDCf//0Wk1Q4HM4Ck2tdsqCEXnEMjpiEEzO3xiJ0RIiASUVXCiUs0u1pBShxvOh8jciyHInIvXCTBkpy4ls2mzJQKo7BcQi7cK4o032ewtikThfMKBEo5Z4znxDHvqsT4uBu5RhD2EZt5MTiAqO2oy+kgSXnYyKMJWSyvNYdBCZalPSJRXZbFNLJPcdivd06YUqJGqB0DEw8QEk/2+1OaQQoARN7pX9jNdNXHRq558DE45QIVIpjABM7ZWj7PdOikHsOTOykpMiDErU4xiEwcTMlG1y+yXLuOTCxTZ1Gt98zL8u3doCJbZQY337PvKzmngMTGym54vZtVnPPgYlNlJjcWM2sLOaeAxNblORMidXcc2BiCyVmt98zr0NLxTGAiQ2ytLGaWa1bubUDTHxCCck93wcmLqLE0vZ75mUl9xyY2ECJaAclJEBpApi4hZIDyxurmZWF3HNgwpmSFdsosZJ7Dkz4aoXGxmpmZT73HJVDuWrVTkosFMdAHWKOSq5Q2ljNrEwHKAETfroq2kyJ+eIYuOjws5KCmCvb3QuTuecYwvKykn5R3By2vRsmA5SACRd1KqMS+62EyFzuOTDhoUtnWAlRaNbMrR1gwsdK+spO6Y2pACVg4icrIYrumMg9ByasreRAsZIjJ/XITO45MGFvJXPDzuqTidxzYOIvKyEyURwDmDDUMrGSBef1y3juOTBhZyVzTrQSolKX0QAlYMLMSvqcaSVEx0YDlIAJGy0QK1l2bPdODQYoARMmOiJW4uD7mUYDlIAJIyvpX3Z0F/elxRAwsd1KDpwdGhEtGcs9Bya0Nex8KyF6bujWDjDxn5WodhL9ZCT3HJjQtZJNxUouXdFVQ7nnwISmyoqVrLglYHNdmi0BE1hJGxkpjgFM/GklRAZyz4EJTSu5clWXDRTHACZUFCjnxMJK0mW9fqQ7QAmY0NCaYiXFK/f1e0JvgBIwoWDe791oJUQ9em/tABPrVjKuWMmFO/uuN/ccmFgdlRArWU26tPd6c8+BiX+thEhn7jkw8a+VqNJXHAOYWLWSDXeTri/3HJhYsJJBt1sJmabpKo4BTMzqxANWQqSrOAYwMWklT4mVBDwwn9eVew5MzFnJW1F8uyF4QnqKYwATk1Yy+DQgeESHUtsAJWBi0kpOBM9goiP3nPmZGkvE4tuVp1/20unubbdj4jErIWqfe876TD2W759vpUfU55/Hvj4JprPuxmSjYiXeUtsAJdZnKj6l/P+XP7s5Tqa/uxmTwGrBa1ZCVGpXHIPxmUrJo8pjMHP7fbHR6l/C4XA28ipUFazEVrUrjsEYk2xkXnkcit+8sJWoJul3RIieSVXBSuzVhLTjIEzO0l+FWjdxEyYbRVEcPxG8qaXWdsL3ovM6/c/dL3fPRSdJrOR9QPCqTluGT3Mdwr5Oz7t13eSCWMma4F0po5MlGyfEse/qhDi4q1Ai/zEyMhJ2ISbESnIethKinVZxbByW12SyvNYdFISEOmrtcB8mnrcSouet9u3DYn17K1nxvpUoina1yBUFJu105QcrIfpVWiwBEwtWUg74gBKhNKudtANM2lrJ5rDgD+1LXVFgYtZKBL+oZ0Az7gSYtLCSfh9ZCdG65oo9MNGSs4olcdHSPa0Ve2CioUu/WQnRhNaKPTBpbiUHTi1LwFLRQ60Ve2ACK6mR1oo9MIGV1EhrxR6YNGjZgXXXuF12NFbsgQmspFYaK/bApM5KHFwsiYc0VuyByR0rcXaxJB5qvmIPTOqtpNPXlGis2AOTGy24o8IJazVdsQcm13JJhRPmetlsxR6YVDQMK7lWsxV7YAIrqVOzFXtgQkYl7qpwwlqfGlfsgQmspF5NVuyByTCspF6NK/a+x8R1xZI46EVDkWKfY+LCYkkc1Lhi729Mym6tcMJYD+pX7P2MybBLiyUxVzQ0ULdDuX8xCcBKtLUuvQEmRGpZAliJhupX7H2KiQcqnLDVxN2dp23GxKbdktxeLIm96lbsbcbElr3XYCU6dHfF3oeYwEr0THaOpTdRH190vFEsiQMnj6I+HsJ6pViSn5YuuH+5h4olARN2VuKhYknAhKGVeHUvcWACKwEm3L4cVuJmTEY6q+JhJSc43S7F5INYFcuvSS7PwUqASWtGjuZyIqwEF532jOTmlmElGMK2ZKRvbhlL88CkuTqPNquMwEeAiQYj5c1BwsgBGAEm7Ri5BCPABIwAE2uMrFyBEWDSXAvvxwsKI/1gBJhoaRiMABO9jFyAEY9iYnkVFoz4AROr93ROCCPFVYSRAJOWA1dRXNkQAm2cpFMUO4WQJLWL39fxFn2f0mhI7Yfx71X+/FOS/iQfvm5BeelPqvfBGrpAXrjtr8svOlr/8MDEU5hY/XJgAkyAiX8wGUvE4tvV539MxyZngAkwadBj+f75VnpEfT4vvz7flc+BCTCpV3xKEAL5M/X554/khS1gAkzqlJJHlcdgRj1IPFQeOiaBCTCpUzYyrzwOxdUD+QcZq7yrAhQOh7ORbNiaRj58GNH5rlfPnr1q8z4db9H3KY2GtHrb5nuVP/9U/iMfvm6BvDQSpqiGLpAXbvubjfxlDyYdEchN6rXnokPcpNeymzRR1jWNuqirjN3k7hA2Q30Iy+v2A5trs99/f82EOPZdnRAHd9UJ8ZMOuhNiYOINTISxhEyW17qD6vKaTHl5DZh4BJN61d7MTXWkGAyHXNOo738/BEEQBEGQm9QquoBGo1/20unubdo9FYQfkQztRv+aysvTtH+/8HA6lp9asN7mL5l8ZPTmYFKevs+RkpbRBTQa/Tz29UkwnaXbqCD05vcylH9+Kv5xvveXr5Rb/Rb71juTH7Le6Mzu6A0mvbGh8zF5hh8mLaMLaDRKlEx/p9xocu/vYIbyz/+SSDH4R53qVh6G9qi0e4PJ0OT16eKj1tEFNBolCsdGKTfakRFoYHKn0Y+ft95NniUpt/otvS30Tp/RxWRP4VC4n+aGifZtY1qNEm0lFqg2GpjP/04Fkzs9nY79v107Zm0QCMM4ftFBEXsG8Uro0mKnBiRUSLZsgXQXsgkNXW4Izfffaq+Ti0ufCin/3wd4eD1evfN4o+uri8Wppsmy9GC0bRLark13/6pNeue1lSa2NX/QJnb4kjSP4tTV6dM/2/i222SOTadzV3GlPs2GVzTNKmmlZRnWfql9/rencI5dSNtk7k1nerpActrs3FZd6e48uC/PS2mlR7vQfE1GqS/fbXLJC2mbzH2EnZ4uUIR22Udd14k21BjNpjMKfXDrfXvqxamxu1Tt5v33oYn3aeMrc4zCD/F+1h/iyekCRagNc3mxuFJVm4xCt3e57QtxahFvcrsWDJytwkJGJip/rtfsnNdrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIBb9AXY8wRJOvLYxgAAAABJRU5ErkJggg=="> </div> <dl class="method"> <dt id="matplotlib.collections.EventCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.EventCollection.remove_callback" title="matplotlib.collections.EventCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EventCollection.remove_callback" title="matplotlib.collections.EventCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.add_positions">
<code>add_positions(self, position)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.add_positions"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>add one or more events at the specified positions</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EventCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.append_positions">
<code>append_positions(self, position)</code> </dt> <dd>
<p>add one or more events at the specified positions</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EventCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.draw">
<code>draw(self, renderer)</code> </dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.extend_positions">
<code>extend_positions(self, position)</code> </dt> <dd>
<p>add one or more events at the specified positions</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EventCollection.get_cursor_data" title="matplotlib.collections.EventCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_color">
<code>get_color(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.get_color"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>get the color of the lines used to mark each event</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_colors">
<code>get_colors(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EventCollection.set_contains" title="matplotlib.collections.EventCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.EventCollection.format_cursor_data" title="matplotlib.collections.EventCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EventCollection.format_cursor_data" title="matplotlib.collections.EventCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.get_linestyle" title="matplotlib.collections.EventCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.get_edgecolor" title="matplotlib.collections.EventCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.get_edgecolor" title="matplotlib.collections.EventCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.get_facecolor" title="matplotlib.collections.EventCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.get_facecolor" title="matplotlib.collections.EventCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_linelength">
<code>get_linelength(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.get_linelength"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>get the length of the lines used to mark each event</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_lineoffset">
<code>get_lineoffset(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.get_lineoffset"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>get the offset of the lines used to mark each event</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.get_linestyle" title="matplotlib.collections.EventCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_linewidth">
<code>get_linewidth(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.get_linewidth"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the width of the lines used to mark each event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_linewidths">
<code>get_linewidths(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.get_linewidths"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.get_linewidth" title="matplotlib.collections.EventCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.get_linestyle" title="matplotlib.collections.EventCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.get_linewidth" title="matplotlib.collections.EventCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_orientation">
<code>get_orientation(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.get_orientation"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>get the orientation of the event line, may be: [ 'horizontal' | 'vertical' ]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_paths">
<code>get_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.EventCollection.set_picker" title="matplotlib.collections.EventCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.EventCollection.pick" title="matplotlib.collections.EventCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_positions">
<code>get_positions(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.get_positions"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>return an array containing the floating-point values of the positions</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_segments">
<code>get_segments(self)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>segments : list</code> </dt> <dd>
<p class="first last">List of segments in the LineCollection. Each list item contains an array of vertices.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.EventCollection.set_snap" title="matplotlib.collections.EventCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.is_horizontal">
<code>is_horizontal(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.is_horizontal"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>True if the eventcollection is horizontal, False if vertical</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.EventCollection.set_transform" title="matplotlib.collections.EventCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EventCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EventCollection.add_callback" title="matplotlib.collections.EventCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.EventCollection.remove_callback" title="matplotlib.collections.EventCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.EventCollection.pickable" title="matplotlib.collections.EventCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.EventCollection.pick" title="matplotlib.collections.EventCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.EventCollection.add_callback" title="matplotlib.collections.EventCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_antialiased" title="matplotlib.collections.EventCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_antialiased" title="matplotlib.collections.EventCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set the color(s) of the LineCollection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or list of colors</code> </dt> <dd>
<p class="first last">Matplotlib color argument (all patches have same color), or a sequence or rgba tuples; if it is a sequence the patches will cycle through the sequence.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.EventCollection.contains" title="matplotlib.collections.EventCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_linestyle" title="matplotlib.collections.EventCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_edgecolor" title="matplotlib.collections.EventCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_edgecolor" title="matplotlib.collections.EventCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_facecolor" title="matplotlib.collections.EventCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_facecolor" title="matplotlib.collections.EventCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_linelength">
<code>set_linelength(self, linelength)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.set_linelength"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>set the length of the lines used to mark each event</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_lineoffset">
<code>set_lineoffset(self, lineoffset)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.set_lineoffset"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>set the offset of the lines used to mark each event</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_linestyle" title="matplotlib.collections.EventCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_linewidth" title="matplotlib.collections.EventCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_linestyle" title="matplotlib.collections.EventCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.EventCollection.set_linewidth" title="matplotlib.collections.EventCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_orientation">
<code>set_orientation(self, orientation=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.set_orientation"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>set the orientation of the event line [ 'horizontal' | 'vertical' | None ] defaults to 'horizontal' if not specified or None</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_paths">
<code>set_paths(self, segments)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_positions">
<code>set_positions(self, positions)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.set_positions"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>set the positions of the events to the specified value</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_segments">
<code>set_segments(self, segments)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_verts">
<code>set_verts(self, segments)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EventCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EventCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.switch_orientation">
<code>switch_orientation(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#EventCollection.switch_orientation"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>switch the orientation of the event line, either from vertical to horizontal or vice versus</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.EventCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.EventCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.LineCollection">
<code>class matplotlib.collections.LineCollection(segments, linewidths=None, colors=None, antialiaseds=None, linestyles='solid', offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5, zorder=2, facecolors='none', **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#LineCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><code>matplotlib.collections.Collection</code></a></p> <p>All parameters must be sequences or scalars; if scalars, they will be converted to sequences. The property of the ith line segment is:</p> <pre data-language="python">prop[i % len(props)]
</pre> <p>i.e., the properties cycle if the <code>len</code> of props is less than the number of segments.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>segments</strong></dt> <dd>
<p class="first">A sequence of (<em>line0</em>, <em>line1</em>, <em>line2</em>), where:</p> <pre data-language="python">linen = (x0, y0), (x1, y1), ... (xm, ym)
</pre> <p class="last">or the equivalent numpy array with two columns. Each line can be a different length.</p> </dd> <dt>
<code>colors : sequence, optional</code> </dt> <dd>
<p class="first last">A sequence of RGBA tuples (e.g., arbitrary color strings, etc, not allowed).</p> </dd> <dt>
<code>antialiaseds : sequence, optional</code> </dt> <dd>
<p class="first last">A sequence of ones or zeros.</p> </dd> <dt>
<code>linestyles : string, tuple, optional</code> </dt> <dd>
<p class="first">Either one of [ 'solid' | 'dashed' | 'dashdot' | 'dotted' ], or a dash tuple. The dash tuple is:</p> <pre data-language="python">(offset, onoffseq)
</pre> <p class="last">where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> </dd> <dt>
<code>norm : Normalize, optional</code> </dt> <dd>
<p class="first last"><a class="reference internal" href="_as_gen/matplotlib.colors.normalize#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> instance.</p> </dd> <dt>
<code>cmap : string or Colormap, optional</code> </dt> <dd>
<p class="first last">Colormap name or <a class="reference internal" href="_as_gen/matplotlib.colors.colormap#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a> instance.</p> </dd> <dt>
<code>pickradius : float, optional</code> </dt> <dd>
<p class="first last">The tolerance in points for mouse clicks picking a line. Default is 5 pt.</p> </dd> <dt>
<code>zorder : int, optional</code> </dt> <dd>
<p class="first last">zorder of the LineCollection. Default is 2.</p> </dd> <dt>
<code>facecolors : optional</code> </dt> <dd>
<p class="first last">The facecolors of the LineCollection. Default is 'none'. Setting to a value other than 'none' will lead to a filled polygon being drawn between points on each line.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If <em>linewidths</em>, <em>colors</em>, or <em>antialiaseds</em> is None, they default to their rcParams setting, in sequence form.</p> <p>If <em>offsets</em> and <em>transOffset</em> are not None, then <em>offsets</em> are transformed by <em>transOffset</em> and applied after the segments have been transformed to display coordinates.</p> <p>If <em>offsets</em> is not None but <em>transOffset</em> is None, then the <em>offsets</em> are added to the segments before any transformation. In this case, a single offset can be specified as:</p> <pre data-language="python">offsets=(xo,yo)
</pre> <p>and this value will be added cumulatively to each successive segment, so as to produce a set of successively offset curves.</p> <p>The use of <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>ScalarMappable</code></a> is optional. If the <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>ScalarMappable</code></a> array <code>_A</code> is not None (i.e., a call to <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable.set_array" title="matplotlib.cm.ScalarMappable.set_array"><code>set_array()</code></a> has been made), at draw time a call to scalar mappable will be made to set the colors.</p> <dl class="method"> <dt id="matplotlib.collections.LineCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.LineCollection.remove_callback" title="matplotlib.collections.LineCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.LineCollection.remove_callback" title="matplotlib.collections.LineCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.LineCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.LineCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.draw">
<code>draw(self, renderer)</code> </dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.LineCollection.get_cursor_data" title="matplotlib.collections.LineCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_color">
<code>get_color(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#LineCollection.get_color"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_colors">
<code>get_colors(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.LineCollection.set_contains" title="matplotlib.collections.LineCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.LineCollection.format_cursor_data" title="matplotlib.collections.LineCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.LineCollection.format_cursor_data" title="matplotlib.collections.LineCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.get_linestyle" title="matplotlib.collections.LineCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.get_edgecolor" title="matplotlib.collections.LineCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.get_edgecolor" title="matplotlib.collections.LineCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.get_facecolor" title="matplotlib.collections.LineCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.get_facecolor" title="matplotlib.collections.LineCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.get_linestyle" title="matplotlib.collections.LineCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.get_linewidth" title="matplotlib.collections.LineCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.get_linestyle" title="matplotlib.collections.LineCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.get_linewidth" title="matplotlib.collections.LineCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_paths">
<code>get_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.LineCollection.set_picker" title="matplotlib.collections.LineCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.LineCollection.pick" title="matplotlib.collections.LineCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_segments">
<code>get_segments(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#LineCollection.get_segments"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>segments : list</code> </dt> <dd>
<p class="first last">List of segments in the LineCollection. Each list item contains an array of vertices.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.LineCollection.set_snap" title="matplotlib.collections.LineCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.LineCollection.set_transform" title="matplotlib.collections.LineCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.LineCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.LineCollection.add_callback" title="matplotlib.collections.LineCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.LineCollection.remove_callback" title="matplotlib.collections.LineCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.LineCollection.pickable" title="matplotlib.collections.LineCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.LineCollection.pick" title="matplotlib.collections.LineCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.LineCollection.add_callback" title="matplotlib.collections.LineCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_antialiased" title="matplotlib.collections.LineCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_antialiased" title="matplotlib.collections.LineCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_color">
<code>set_color(self, c)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#LineCollection.set_color"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the color(s) of the LineCollection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or list of colors</code> </dt> <dd>
<p class="first last">Matplotlib color argument (all patches have same color), or a sequence or rgba tuples; if it is a sequence the patches will cycle through the sequence.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.LineCollection.contains" title="matplotlib.collections.LineCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_linestyle" title="matplotlib.collections.LineCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_edgecolor" title="matplotlib.collections.LineCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_edgecolor" title="matplotlib.collections.LineCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_facecolor" title="matplotlib.collections.LineCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_facecolor" title="matplotlib.collections.LineCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_linestyle" title="matplotlib.collections.LineCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_linewidth" title="matplotlib.collections.LineCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_linestyle" title="matplotlib.collections.LineCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.LineCollection.set_linewidth" title="matplotlib.collections.LineCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_paths">
<code>set_paths(self, segments)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_segments">
<code>set_segments(self, segments)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#LineCollection.set_segments"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_verts">
<code>set_verts(self, segments)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.LineCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.LineCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.LineCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.LineCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.PatchCollection">
<code>class matplotlib.collections.PatchCollection(patches, match_original=False, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#PatchCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><code>matplotlib.collections.Collection</code></a></p> <p>A generic collection of patches.</p> <p>This makes it easier to assign a color map to a heterogeneous collection of patches.</p> <p>This also may improve plotting speed, since PatchCollection will draw faster than a large number of patches.</p> <dl class="docutils"> <dt><em>patches</em></dt> <dd>a sequence of Patch objects. This list may include a heterogeneous assortment of different patch types.</dd> <dt><em>match_original</em></dt> <dd>If True, use the colors and linewidths of the original patches. If False, new colors may be assigned by providing the standard collection arguments, facecolor, edgecolor, linewidths, norm or cmap.</dd> </dl> <p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em> are None, they default to their <a class="reference internal" href="matplotlib_configuration_api#matplotlib.rcParams" title="matplotlib.rcParams"><code>matplotlib.rcParams</code></a> patch setting, in sequence form.</p> <p>The use of <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>ScalarMappable</code></a> is optional. If the <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>ScalarMappable</code></a> matrix _A is not None (i.e., a call to set_array has been made), at draw time a call to scalar mappable will be made to set the face colors.</p> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.PatchCollection.remove_callback" title="matplotlib.collections.PatchCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PatchCollection.remove_callback" title="matplotlib.collections.PatchCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PatchCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PatchCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.draw">
<code>draw(self, renderer)</code> </dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PatchCollection.get_cursor_data" title="matplotlib.collections.PatchCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_contains" title="matplotlib.collections.PatchCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.PatchCollection.format_cursor_data" title="matplotlib.collections.PatchCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PatchCollection.format_cursor_data" title="matplotlib.collections.PatchCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.get_linestyle" title="matplotlib.collections.PatchCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.get_edgecolor" title="matplotlib.collections.PatchCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.get_edgecolor" title="matplotlib.collections.PatchCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.get_facecolor" title="matplotlib.collections.PatchCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.get_facecolor" title="matplotlib.collections.PatchCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.get_linestyle" title="matplotlib.collections.PatchCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.get_linewidth" title="matplotlib.collections.PatchCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.get_linestyle" title="matplotlib.collections.PatchCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.get_linewidth" title="matplotlib.collections.PatchCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_paths">
<code>get_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_picker" title="matplotlib.collections.PatchCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.PatchCollection.pick" title="matplotlib.collections.PatchCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_snap" title="matplotlib.collections.PatchCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_transform" title="matplotlib.collections.PatchCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PatchCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PatchCollection.add_callback" title="matplotlib.collections.PatchCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.PatchCollection.remove_callback" title="matplotlib.collections.PatchCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.PatchCollection.pickable" title="matplotlib.collections.PatchCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.PatchCollection.pick" title="matplotlib.collections.PatchCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PatchCollection.add_callback" title="matplotlib.collections.PatchCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_antialiased" title="matplotlib.collections.PatchCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_antialiased" title="matplotlib.collections.PatchCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.PatchCollection.contains" title="matplotlib.collections.PatchCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_linestyle" title="matplotlib.collections.PatchCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_edgecolor" title="matplotlib.collections.PatchCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_edgecolor" title="matplotlib.collections.PatchCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_facecolor" title="matplotlib.collections.PatchCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_facecolor" title="matplotlib.collections.PatchCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_linestyle" title="matplotlib.collections.PatchCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_linewidth" title="matplotlib.collections.PatchCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_linestyle" title="matplotlib.collections.PatchCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PatchCollection.set_linewidth" title="matplotlib.collections.PatchCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_paths">
<code>set_paths(self, patches)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#PatchCollection.set_paths"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PatchCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PatchCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PatchCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PatchCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.PathCollection">
<code>class matplotlib.collections.PathCollection(paths, sizes=None, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#PathCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.collections._CollectionWithSizes</code></p> <p>This is the most basic <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><code>Collection</code></a> subclass. A <a class="reference internal" href="#matplotlib.collections.PathCollection" title="matplotlib.collections.PathCollection"><code>PathCollection</code></a> is e.g. created by a <a class="reference internal" href="_as_gen/matplotlib.axes.axes.scatter#matplotlib.axes.Axes.scatter" title="matplotlib.axes.Axes.scatter"><code>scatter()</code></a> plot.</p> <p><em>paths</em> is a sequence of <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>matplotlib.path.Path</code></a> instances.</p>  <p>Valid Collection keyword arguments:</p>  <ul class="simple"> <li>
<em>edgecolors</em>: None</li> <li>
<em>facecolors</em>: None</li> <li>
<em>linewidths</em>: None</li> <li>
<em>antialiaseds</em>: None</li> <li>
<em>offsets</em>: None</li> <li>
<em>transOffset</em>: transforms.IdentityTransform()</li> <li>
<em>norm</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> <li>
<em>cmap</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> </ul>  <p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after rendering (default no offsets)</p> <p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em> are None, they default to their <a class="reference internal" href="matplotlib_configuration_api#matplotlib.rcParams" title="matplotlib.rcParams"><code>matplotlib.rcParams</code></a> patch setting, in sequence form.</p>  <dl class="method"> <dt id="matplotlib.collections.PathCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.PathCollection.remove_callback" title="matplotlib.collections.PathCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PathCollection.remove_callback" title="matplotlib.collections.PathCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PathCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PathCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.draw">
<code>draw(self, renderer)</code> </dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PathCollection.get_cursor_data" title="matplotlib.collections.PathCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PathCollection.set_contains" title="matplotlib.collections.PathCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.PathCollection.format_cursor_data" title="matplotlib.collections.PathCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PathCollection.format_cursor_data" title="matplotlib.collections.PathCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.get_linestyle" title="matplotlib.collections.PathCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.get_edgecolor" title="matplotlib.collections.PathCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.get_edgecolor" title="matplotlib.collections.PathCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.get_facecolor" title="matplotlib.collections.PathCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.get_facecolor" title="matplotlib.collections.PathCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.get_linestyle" title="matplotlib.collections.PathCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.get_linewidth" title="matplotlib.collections.PathCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.get_linestyle" title="matplotlib.collections.PathCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.get_linewidth" title="matplotlib.collections.PathCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_paths">
<code>get_paths(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#PathCollection.get_paths"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.PathCollection.set_picker" title="matplotlib.collections.PathCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.PathCollection.pick" title="matplotlib.collections.PathCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_sizes">
<code>get_sizes(self)</code> </dt> <dd>
<p>Returns the sizes of the elements in the collection. The value represents the 'area' of the element.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : array</code> </dt> <dd>
<p class="first last">The 'area' of each element.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.PathCollection.set_snap" title="matplotlib.collections.PathCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.PathCollection.set_transform" title="matplotlib.collections.PathCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.legend_elements">
<code>legend_elements(self, prop='colors', num='auto', fmt=None, func=&lt;function PathCollection.&lt;lambda&gt; at 0x7f8092b730d0&gt;, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#PathCollection.legend_elements"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Creates legend handles and labels for a PathCollection. This is useful for obtaining a legend for a <a class="reference internal" href="_as_gen/matplotlib.axes.axes.scatter#matplotlib.axes.Axes.scatter" title="matplotlib.axes.Axes.scatter"><code>scatter()</code></a> plot. E.g.:</p> <pre data-language="python">scatter = plt.scatter([1,2,3], [4,5,6], c=[7,2,3])
plt.legend(*scatter.legend_elements())
</pre> <p>Also see the <a class="reference internal" href="https://matplotlib.org/3.1.1/gallery/lines_bars_and_markers/scatter_with_legend.html#automatedlegendcreation"><span class="std std-ref">Automated legend creation</span></a> example.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>prop : string, optional, default "colors"</code> </dt> <dd>
<p class="first last">Can be <em>"colors"</em> or <em>"sizes"</em>. In case of <em>"colors"</em>, the legend handles will show the different colors of the collection. In case of "sizes", the legend will show the different sizes.</p> </dd> <dt>
<code>num : int, None, "auto" (default), array-like, or Locator,</code> </dt> <dd>
<p class="first last">optional Target number of elements to create. If None, use all unique elements of the mappable array. If an integer, target to use <em>num</em> elements in the normed range. If <em>"auto"</em>, try to determine which option better suits the nature of the data. The number of created elements may slightly deviate from <em>num</em> due to a <a class="reference internal" href="ticker_api#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>Locator</code></a> being used to find useful locations. If a list or array, use exactly those elements for the legend. Finally, a <a class="reference internal" href="ticker_api#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>Locator</code></a> can be provided.</p> </dd> <dt>
<code>fmt : string, Formatter, or None (default)</code> </dt> <dd>
<p class="first last">The format or formatter to use for the labels. If a string must be a valid input for a <a class="reference internal" href="ticker_api#matplotlib.ticker.StrMethodFormatter" title="matplotlib.ticker.StrMethodFormatter"><code>StrMethodFormatter</code></a>. If None (the default), use a <a class="reference internal" href="ticker_api#matplotlib.ticker.ScalarFormatter" title="matplotlib.ticker.ScalarFormatter"><code>ScalarFormatter</code></a>.</p> </dd> <dt>
<code>func : function, default lambda x: x</code> </dt> <dd>
<p class="first last">Function to calculate the labels. Often the size (or color) argument to <a class="reference internal" href="_as_gen/matplotlib.axes.axes.scatter#matplotlib.axes.Axes.scatter" title="matplotlib.axes.Axes.scatter"><code>scatter()</code></a> will have been pre-processed by the user using a function <em>s = f(x)</em> to make the markers visible; e.g. <em>size = np.log10(x)</em>. Providing the inverse of this function here allows that pre-processing to be inverted, so that the legend labels have the correct values; e.g. <em>func = np.exp(x, 10)</em>.</p> </dd> <dt>
<code>kwargs : further parameters</code> </dt> <dd>
<p class="first last">Allowed kwargs are <em>color</em> and <em>size</em>. E.g. it may be useful to set the color of the markers if <em>prop="sizes"</em> is used; similarly to set the size of the markers if <em>prop="colors"</em> is used. Any further parameters are passed onto the <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a> instance. This may be useful to e.g. specify a different <em>markeredgecolor</em> or <em>alpha</em> for the legend handles.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>tuple (handles, labels)</dt> <dd>
<p class="first last">with <em>handles</em> being a list of <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a> objects and <em>labels</em> a matching list of strings.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PathCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PathCollection.add_callback" title="matplotlib.collections.PathCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.PathCollection.remove_callback" title="matplotlib.collections.PathCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.PathCollection.pickable" title="matplotlib.collections.PathCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.PathCollection.pick" title="matplotlib.collections.PathCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PathCollection.add_callback" title="matplotlib.collections.PathCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_antialiased" title="matplotlib.collections.PathCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_antialiased" title="matplotlib.collections.PathCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.PathCollection.contains" title="matplotlib.collections.PathCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_linestyle" title="matplotlib.collections.PathCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_edgecolor" title="matplotlib.collections.PathCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_edgecolor" title="matplotlib.collections.PathCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_facecolor" title="matplotlib.collections.PathCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_facecolor" title="matplotlib.collections.PathCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_linestyle" title="matplotlib.collections.PathCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_linewidth" title="matplotlib.collections.PathCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_linestyle" title="matplotlib.collections.PathCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PathCollection.set_linewidth" title="matplotlib.collections.PathCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_paths">
<code>set_paths(self, paths)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#PathCollection.set_paths"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_sizes">
<code>set_sizes(self, sizes, dpi=72.0)</code> </dt> <dd>
<p>Set the sizes of each member of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : ndarray or None</code> </dt> <dd>
<p class="first last">The size to set for each element of the collection. The value is the 'area' of the element.</p> </dd> <dt>
<code>dpi : float</code> </dt> <dd>
<p class="first last">The dpi of the canvas. Defaults to 72.0.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PathCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PathCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PathCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PathCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.PolyCollection">
<code>class matplotlib.collections.PolyCollection(verts, sizes=None, closed=True, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#PolyCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.collections._CollectionWithSizes</code></p> <p><em>verts</em> is a sequence of ( <em>verts0</em>, <em>verts1</em>, ...) where <em>verts_i</em> is a sequence of <em>xy</em> tuples of vertices, or an equivalent <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.16)"><code>numpy</code></a> array of shape (<em>nv</em>, 2).</p> <p><em>sizes</em> is <em>None</em> (default) or a sequence of floats that scale the corresponding <em>verts_i</em>. The scaling is applied before the Artist master transform; if the latter is an identity transform, then the overall scaling is such that if <em>verts_i</em> specify a unit square, then <em>sizes_i</em> is the area of that square in points^2. If len(<em>sizes</em>) &lt; <em>nv</em>, the additional values will be taken cyclically from the array.</p> <p><em>closed</em>, when <em>True</em>, will explicitly close the polygon.</p>  <p>Valid Collection keyword arguments:</p>  <ul class="simple"> <li>
<em>edgecolors</em>: None</li> <li>
<em>facecolors</em>: None</li> <li>
<em>linewidths</em>: None</li> <li>
<em>antialiaseds</em>: None</li> <li>
<em>offsets</em>: None</li> <li>
<em>transOffset</em>: transforms.IdentityTransform()</li> <li>
<em>norm</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> <li>
<em>cmap</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> </ul>  <p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after rendering (default no offsets)</p> <p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em> are None, they default to their <a class="reference internal" href="matplotlib_configuration_api#matplotlib.rcParams" title="matplotlib.rcParams"><code>matplotlib.rcParams</code></a> patch setting, in sequence form.</p>  <dl class="method"> <dt id="matplotlib.collections.PolyCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.PolyCollection.remove_callback" title="matplotlib.collections.PolyCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PolyCollection.remove_callback" title="matplotlib.collections.PolyCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PolyCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PolyCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.draw">
<code>draw(self, renderer)</code> </dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PolyCollection.get_cursor_data" title="matplotlib.collections.PolyCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_contains" title="matplotlib.collections.PolyCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.PolyCollection.format_cursor_data" title="matplotlib.collections.PolyCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PolyCollection.format_cursor_data" title="matplotlib.collections.PolyCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.get_linestyle" title="matplotlib.collections.PolyCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.get_edgecolor" title="matplotlib.collections.PolyCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.get_edgecolor" title="matplotlib.collections.PolyCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.get_facecolor" title="matplotlib.collections.PolyCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.get_facecolor" title="matplotlib.collections.PolyCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.get_linestyle" title="matplotlib.collections.PolyCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.get_linewidth" title="matplotlib.collections.PolyCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.get_linestyle" title="matplotlib.collections.PolyCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.get_linewidth" title="matplotlib.collections.PolyCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_paths">
<code>get_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_picker" title="matplotlib.collections.PolyCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.PolyCollection.pick" title="matplotlib.collections.PolyCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_sizes">
<code>get_sizes(self)</code> </dt> <dd>
<p>Returns the sizes of the elements in the collection. The value represents the 'area' of the element.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : array</code> </dt> <dd>
<p class="first last">The 'area' of each element.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_snap" title="matplotlib.collections.PolyCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_transform" title="matplotlib.collections.PolyCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PolyCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PolyCollection.add_callback" title="matplotlib.collections.PolyCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.PolyCollection.remove_callback" title="matplotlib.collections.PolyCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.PolyCollection.pickable" title="matplotlib.collections.PolyCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.PolyCollection.pick" title="matplotlib.collections.PolyCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.PolyCollection.add_callback" title="matplotlib.collections.PolyCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_antialiased" title="matplotlib.collections.PolyCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_antialiased" title="matplotlib.collections.PolyCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.PolyCollection.contains" title="matplotlib.collections.PolyCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_linestyle" title="matplotlib.collections.PolyCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_edgecolor" title="matplotlib.collections.PolyCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_edgecolor" title="matplotlib.collections.PolyCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_facecolor" title="matplotlib.collections.PolyCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_facecolor" title="matplotlib.collections.PolyCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_linestyle" title="matplotlib.collections.PolyCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_linewidth" title="matplotlib.collections.PolyCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_linestyle" title="matplotlib.collections.PolyCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.PolyCollection.set_linewidth" title="matplotlib.collections.PolyCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_paths">
<code>set_paths(self, verts, closed=True)</code> </dt> <dd>
<p>This allows one to delay initialization of the vertices.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_sizes">
<code>set_sizes(self, sizes, dpi=72.0)</code> </dt> <dd>
<p>Set the sizes of each member of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : ndarray or None</code> </dt> <dd>
<p class="first last">The size to set for each element of the collection. The value is the 'area' of the element.</p> </dd> <dt>
<code>dpi : float</code> </dt> <dd>
<p class="first last">The dpi of the canvas. Defaults to 72.0.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_verts">
<code>set_verts(self, verts, closed=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#PolyCollection.set_verts"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This allows one to delay initialization of the vertices.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_verts_and_codes">
<code>set_verts_and_codes(self, verts, codes)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#PolyCollection.set_verts_and_codes"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This allows one to initialize vertices with path codes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PolyCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PolyCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.PolyCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.PolyCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.QuadMesh">
<code>class matplotlib.collections.QuadMesh(meshWidth, meshHeight, coordinates, antialiased=True, shading='flat', **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#QuadMesh"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><code>matplotlib.collections.Collection</code></a></p> <p>Class for the efficient drawing of a quadrilateral mesh.</p> <p>A quadrilateral mesh consists of a grid of vertices. The dimensions of this array are (<em>meshWidth</em> + 1, <em>meshHeight</em> + 1). Each vertex in the mesh has a different set of "mesh coordinates" representing its position in the topology of the mesh. For any values (<em>m</em>, <em>n</em>) such that 0 &lt;= <em>m</em> &lt;= <em>meshWidth</em> and 0 &lt;= <em>n</em> &lt;= <em>meshHeight</em>, the vertices at mesh coordinates (<em>m</em>, <em>n</em>), (<em>m</em>, <em>n</em> + 1), (<em>m</em> + 1, <em>n</em> + 1), and (<em>m</em> + 1, <em>n</em>) form one of the quadrilaterals in the mesh. There are thus (<em>meshWidth</em> * <em>meshHeight</em>) quadrilaterals in the mesh. The mesh need not be regular and the polygons need not be convex.</p> <p>A quadrilateral mesh is represented by a (2 x ((<em>meshWidth</em> + 1) * (<em>meshHeight</em> + 1))) numpy array <em>coordinates</em>, where each row is the <em>x</em> and <em>y</em> coordinates of one of the vertices. To define the function that maps from a data point to its corresponding color, use the <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_cmap" title="matplotlib.collections.QuadMesh.set_cmap"><code>set_cmap()</code></a> method. Each of these arrays is indexed in row-major order by the mesh coordinates of the vertex (or the mesh coordinates of the lower left vertex, in the case of the colors).</p> <p>For example, the first entry in <em>coordinates</em> is the coordinates of the vertex at mesh coordinates (0, 0), then the one at (0, 1), then at (0, 2) .. (0, meshWidth), (1, 0), (1, 1), and so on.</p> <p><em>shading</em> may be 'flat', or 'gouraud'</p> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.QuadMesh.remove_callback" title="matplotlib.collections.QuadMesh.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.QuadMesh.remove_callback" title="matplotlib.collections.QuadMesh.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.QuadMesh.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.QuadMesh.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.collections.QuadMesh.convert_mesh_to_paths">
<code>static convert_mesh_to_paths(meshWidth, meshHeight, coordinates)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#QuadMesh.convert_mesh_to_paths"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Converts a given mesh into a sequence of <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> objects.</p> <p>This function is primarily of use to implementers of backends that do not directly support quadmeshes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.convert_mesh_to_triangles">
<code>convert_mesh_to_triangles(self, meshWidth, meshHeight, coordinates)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#QuadMesh.convert_mesh_to_triangles"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Converts a given mesh into a sequence of triangles, each point with its own color. This is useful for experiments using <code>draw_gouraud_triangle</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.draw">
<code>draw(self, renderer)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#QuadMesh.draw"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.QuadMesh.get_cursor_data" title="matplotlib.collections.QuadMesh.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_contains" title="matplotlib.collections.QuadMesh.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.QuadMesh.format_cursor_data" title="matplotlib.collections.QuadMesh.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.QuadMesh.format_cursor_data" title="matplotlib.collections.QuadMesh.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.get_linestyle" title="matplotlib.collections.QuadMesh.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_datalim">
<code>get_datalim(self, transData)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#QuadMesh.get_datalim"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.get_edgecolor" title="matplotlib.collections.QuadMesh.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.get_edgecolor" title="matplotlib.collections.QuadMesh.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.get_facecolor" title="matplotlib.collections.QuadMesh.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.get_facecolor" title="matplotlib.collections.QuadMesh.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.get_linestyle" title="matplotlib.collections.QuadMesh.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.get_linewidth" title="matplotlib.collections.QuadMesh.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.get_linestyle" title="matplotlib.collections.QuadMesh.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.get_linewidth" title="matplotlib.collections.QuadMesh.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_paths">
<code>get_paths(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#QuadMesh.get_paths"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_picker" title="matplotlib.collections.QuadMesh.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.QuadMesh.pick" title="matplotlib.collections.QuadMesh.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_snap" title="matplotlib.collections.QuadMesh.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_transform" title="matplotlib.collections.QuadMesh.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.QuadMesh.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.QuadMesh.add_callback" title="matplotlib.collections.QuadMesh.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.QuadMesh.remove_callback" title="matplotlib.collections.QuadMesh.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.QuadMesh.pickable" title="matplotlib.collections.QuadMesh.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.QuadMesh.pick" title="matplotlib.collections.QuadMesh.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.QuadMesh.add_callback" title="matplotlib.collections.QuadMesh.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_antialiased" title="matplotlib.collections.QuadMesh.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_antialiased" title="matplotlib.collections.QuadMesh.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.QuadMesh.contains" title="matplotlib.collections.QuadMesh.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_linestyle" title="matplotlib.collections.QuadMesh.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_edgecolor" title="matplotlib.collections.QuadMesh.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_edgecolor" title="matplotlib.collections.QuadMesh.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_facecolor" title="matplotlib.collections.QuadMesh.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_facecolor" title="matplotlib.collections.QuadMesh.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_linestyle" title="matplotlib.collections.QuadMesh.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_linewidth" title="matplotlib.collections.QuadMesh.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_linestyle" title="matplotlib.collections.QuadMesh.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.QuadMesh.set_linewidth" title="matplotlib.collections.QuadMesh.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_paths">
<code>set_paths(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#QuadMesh.set_paths"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.QuadMesh.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.QuadMesh.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.QuadMesh.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.QuadMesh.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.RegularPolyCollection">
<code>class matplotlib.collections.RegularPolyCollection(numsides, rotation=0, sizes=(1, ), **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#RegularPolyCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.collections._CollectionWithSizes</code></p> <p>Draw a collection of regular polygons with <em>numsides</em>.</p> <dl class="docutils"> <dt><em>numsides</em></dt> <dd>the number of sides of the polygon</dd> <dt><em>rotation</em></dt> <dd>the rotation of the polygon in radians</dd> <dt><em>sizes</em></dt> <dd>
<p class="first">gives the area of the circle circumscribing the regular polygon in points^2</p> <p>Valid Collection keyword arguments:</p>  <ul class="simple"> <li>
<em>edgecolors</em>: None</li> <li>
<em>facecolors</em>: None</li> <li>
<em>linewidths</em>: None</li> <li>
<em>antialiaseds</em>: None</li> <li>
<em>offsets</em>: None</li> <li>
<em>transOffset</em>: transforms.IdentityTransform()</li> <li>
<em>norm</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> <li>
<em>cmap</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> </ul>  <p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after rendering (default no offsets)</p> <p class="last">If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em> are None, they default to their <a class="reference internal" href="matplotlib_configuration_api#matplotlib.rcParams" title="matplotlib.rcParams"><code>matplotlib.rcParams</code></a> patch setting, in sequence form.</p> </dd> </dl> <p>Example: see <a class="reference internal" href="https://matplotlib.org/3.1.1/gallery/event_handling/lasso_demo.html"><span class="doc">Lasso Demo</span></a> for a complete example:</p> <pre data-language="python">offsets = np.random.rand(20,2)
facecolors = [cm.jet(x) for x in np.random.rand(20)]
black = (0,0,0,1)

collection = RegularPolyCollection(
    numsides=5, # a pentagon
    rotation=0, sizes=(50,),
    facecolors=facecolors,
    edgecolors=(black,),
    linewidths=(1,),
    offsets=offsets,
    transOffset=ax.transData,
    )
</pre> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.remove_callback" title="matplotlib.collections.RegularPolyCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.remove_callback" title="matplotlib.collections.RegularPolyCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.RegularPolyCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.RegularPolyCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.draw">
<code>draw(self, renderer)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#RegularPolyCollection.draw"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.get_cursor_data" title="matplotlib.collections.RegularPolyCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_contains" title="matplotlib.collections.RegularPolyCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.format_cursor_data" title="matplotlib.collections.RegularPolyCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.format_cursor_data" title="matplotlib.collections.RegularPolyCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.get_linestyle" title="matplotlib.collections.RegularPolyCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.get_edgecolor" title="matplotlib.collections.RegularPolyCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.get_edgecolor" title="matplotlib.collections.RegularPolyCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.get_facecolor" title="matplotlib.collections.RegularPolyCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.get_facecolor" title="matplotlib.collections.RegularPolyCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.get_linestyle" title="matplotlib.collections.RegularPolyCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.get_linewidth" title="matplotlib.collections.RegularPolyCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.get_linestyle" title="matplotlib.collections.RegularPolyCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.get_linewidth" title="matplotlib.collections.RegularPolyCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_numsides">
<code>get_numsides(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#RegularPolyCollection.get_numsides"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_paths">
<code>get_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_picker" title="matplotlib.collections.RegularPolyCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.pick" title="matplotlib.collections.RegularPolyCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_rotation">
<code>get_rotation(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#RegularPolyCollection.get_rotation"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_sizes">
<code>get_sizes(self)</code> </dt> <dd>
<p>Returns the sizes of the elements in the collection. The value represents the 'area' of the element.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : array</code> </dt> <dd>
<p class="first last">The 'area' of each element.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_snap" title="matplotlib.collections.RegularPolyCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_transform" title="matplotlib.collections.RegularPolyCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.RegularPolyCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.add_callback" title="matplotlib.collections.RegularPolyCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.remove_callback" title="matplotlib.collections.RegularPolyCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.pickable" title="matplotlib.collections.RegularPolyCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.pick" title="matplotlib.collections.RegularPolyCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.add_callback" title="matplotlib.collections.RegularPolyCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_antialiased" title="matplotlib.collections.RegularPolyCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_antialiased" title="matplotlib.collections.RegularPolyCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.contains" title="matplotlib.collections.RegularPolyCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_linestyle" title="matplotlib.collections.RegularPolyCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_edgecolor" title="matplotlib.collections.RegularPolyCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_edgecolor" title="matplotlib.collections.RegularPolyCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_facecolor" title="matplotlib.collections.RegularPolyCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_facecolor" title="matplotlib.collections.RegularPolyCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_linestyle" title="matplotlib.collections.RegularPolyCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_linewidth" title="matplotlib.collections.RegularPolyCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_linestyle" title="matplotlib.collections.RegularPolyCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection.set_linewidth" title="matplotlib.collections.RegularPolyCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_paths">
<code>set_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_sizes">
<code>set_sizes(self, sizes, dpi=72.0)</code> </dt> <dd>
<p>Set the sizes of each member of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : ndarray or None</code> </dt> <dd>
<p class="first last">The size to set for each element of the collection. The value is the 'area' of the element.</p> </dd> <dt>
<code>dpi : float</code> </dt> <dd>
<p class="first last">The dpi of the canvas. Defaults to 72.0.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.RegularPolyCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.RegularPolyCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.RegularPolyCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.RegularPolyCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.StarPolygonCollection">
<code>class matplotlib.collections.StarPolygonCollection(numsides, rotation=0, sizes=(1, ), **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#StarPolygonCollection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection" title="matplotlib.collections.RegularPolyCollection"><code>matplotlib.collections.RegularPolyCollection</code></a></p> <p>Draw a collection of regular stars with <em>numsides</em> points.</p> <dl class="docutils"> <dt><em>numsides</em></dt> <dd>the number of sides of the polygon</dd> <dt><em>rotation</em></dt> <dd>the rotation of the polygon in radians</dd> <dt><em>sizes</em></dt> <dd>
<p class="first">gives the area of the circle circumscribing the regular polygon in points^2</p> <p>Valid Collection keyword arguments:</p>  <ul class="simple"> <li>
<em>edgecolors</em>: None</li> <li>
<em>facecolors</em>: None</li> <li>
<em>linewidths</em>: None</li> <li>
<em>antialiaseds</em>: None</li> <li>
<em>offsets</em>: None</li> <li>
<em>transOffset</em>: transforms.IdentityTransform()</li> <li>
<em>norm</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> <li>
<em>cmap</em>: None (optional for <a class="reference internal" href="cm_api#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>)</li> </ul>  <p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after rendering (default no offsets)</p> <p class="last">If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em> are None, they default to their <a class="reference internal" href="matplotlib_configuration_api#matplotlib.rcParams" title="matplotlib.rcParams"><code>matplotlib.rcParams</code></a> patch setting, in sequence form.</p> </dd> </dl> <p>Example: see <a class="reference internal" href="https://matplotlib.org/3.1.1/gallery/event_handling/lasso_demo.html"><span class="doc">Lasso Demo</span></a> for a complete example:</p> <pre data-language="python">offsets = np.random.rand(20,2)
facecolors = [cm.jet(x) for x in np.random.rand(20)]
black = (0,0,0,1)

collection = RegularPolyCollection(
    numsides=5, # a pentagon
    rotation=0, sizes=(50,),
    facecolors=facecolors,
    edgecolors=(black,),
    linewidths=(1,),
    offsets=offsets,
    transOffset=ax.transData,
    )
</pre> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.remove_callback" title="matplotlib.collections.StarPolygonCollection.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.remove_callback" title="matplotlib.collections.StarPolygonCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.StarPolygonCollection.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.StarPolygonCollection.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.draw">
<code>draw(self, renderer)</code> </dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.get_cursor_data" title="matplotlib.collections.StarPolygonCollection.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_contains" title="matplotlib.collections.StarPolygonCollection.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.format_cursor_data" title="matplotlib.collections.StarPolygonCollection.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.format_cursor_data" title="matplotlib.collections.StarPolygonCollection.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.get_linestyle" title="matplotlib.collections.StarPolygonCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.get_edgecolor" title="matplotlib.collections.StarPolygonCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.get_edgecolor" title="matplotlib.collections.StarPolygonCollection.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.get_facecolor" title="matplotlib.collections.StarPolygonCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.get_facecolor" title="matplotlib.collections.StarPolygonCollection.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.get_linestyle" title="matplotlib.collections.StarPolygonCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.get_linewidth" title="matplotlib.collections.StarPolygonCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.get_linestyle" title="matplotlib.collections.StarPolygonCollection.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.get_linewidth" title="matplotlib.collections.StarPolygonCollection.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_numsides">
<code>get_numsides(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_paths">
<code>get_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_picker" title="matplotlib.collections.StarPolygonCollection.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.pick" title="matplotlib.collections.StarPolygonCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_rotation">
<code>get_rotation(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_sizes">
<code>get_sizes(self)</code> </dt> <dd>
<p>Returns the sizes of the elements in the collection. The value represents the 'area' of the element.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : array</code> </dt> <dd>
<p class="first last">The 'area' of each element.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_snap" title="matplotlib.collections.StarPolygonCollection.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_transform" title="matplotlib.collections.StarPolygonCollection.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.StarPolygonCollection.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.add_callback" title="matplotlib.collections.StarPolygonCollection.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.remove_callback" title="matplotlib.collections.StarPolygonCollection.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.pickable" title="matplotlib.collections.StarPolygonCollection.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.pick" title="matplotlib.collections.StarPolygonCollection.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.add_callback" title="matplotlib.collections.StarPolygonCollection.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_antialiased" title="matplotlib.collections.StarPolygonCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_antialiased" title="matplotlib.collections.StarPolygonCollection.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.contains" title="matplotlib.collections.StarPolygonCollection.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_linestyle" title="matplotlib.collections.StarPolygonCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_edgecolor" title="matplotlib.collections.StarPolygonCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_edgecolor" title="matplotlib.collections.StarPolygonCollection.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_facecolor" title="matplotlib.collections.StarPolygonCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_facecolor" title="matplotlib.collections.StarPolygonCollection.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_linestyle" title="matplotlib.collections.StarPolygonCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_linewidth" title="matplotlib.collections.StarPolygonCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_linestyle" title="matplotlib.collections.StarPolygonCollection.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.StarPolygonCollection.set_linewidth" title="matplotlib.collections.StarPolygonCollection.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_paths">
<code>set_paths(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_sizes">
<code>set_sizes(self, sizes, dpi=72.0)</code> </dt> <dd>
<p>Set the sizes of each member of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sizes : ndarray or None</code> </dt> <dd>
<p class="first last">The size to set for each element of the collection. The value is the 'area' of the element.</p> </dd> <dt>
<code>dpi : float</code> </dt> <dd>
<p class="first last">The dpi of the canvas. Defaults to 72.0.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.StarPolygonCollection.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.StarPolygonCollection.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.StarPolygonCollection.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.StarPolygonCollection.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.collections.TriMesh">
<code>class matplotlib.collections.TriMesh(triangulation, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#TriMesh"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><code>matplotlib.collections.Collection</code></a></p> <p>Class for the efficient drawing of a triangular mesh using Gouraud shading.</p> <p>A triangular mesh is a <a class="reference internal" href="tri_api#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a> object.</p> <dl class="method"> <dt id="matplotlib.collections.TriMesh.add_callback">
<code>add_callback(self, func)</code> </dt> <dd>
<p>Add a callback function that will be called whenever one of the <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>'s properties changes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>func : callable</code> </dt> <dd>
<p class="first">The callback function. It must have the signature:</p> <pre data-language="python">def func(artist: Artist) -&gt; Any
</pre> <p class="last">where <em>artist</em> is the calling <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>. Return values may exist but are ignored.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>oid : int</code> </dt> <dd>
<p class="first last">The observer id associated with the callback. This id can be used for removing the callback with <a class="reference internal" href="#matplotlib.collections.TriMesh.remove_callback" title="matplotlib.collections.TriMesh.remove_callback"><code>remove_callback</code></a> later.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.TriMesh.remove_callback" title="matplotlib.collections.TriMesh.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.add_checker">
<code>add_checker(self, checker)</code> </dt> <dd>
<p>Add an entry to a dictionary of boolean flags that are set to True when the mappable is changed.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.TriMesh.aname">
<code>aname</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.autoscale">
<code>autoscale(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.autoscale_None">
<code>autoscale_None(self)</code> </dt> <dd>
<p>Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.TriMesh.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.changed">
<code>changed(self)</code> </dt> <dd>
<p>Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.check_update">
<code>check_update(self, checker)</code> </dt> <dd>
<p>If mappable has changed since the last check, return True; else return False</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.contains">
<code>contains(self, mouseevent)</code> </dt> <dd>
<p>Test whether the mouse event occurred in the collection.</p> <p>Returns <code>bool, dict(ind=itemlist)</code>, where every item in itemlist contains the event.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.collections.TriMesh.convert_mesh_to_paths">
<code>static convert_mesh_to_paths(tri)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#TriMesh.convert_mesh_to_paths"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Converts a given mesh into a sequence of <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> objects.</p> <p>This function is primarily of use to implementers of backends that do not directly support meshes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.convert_xunits">
<code>convert_xunits(self, x)</code> </dt> <dd>
<p>Convert <em>x</em> using the unit type of the xaxis.</p> <p>If the artist is not in contained in an Axes or if the xaxis does not have units, <em>x</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.convert_yunits">
<code>convert_yunits(self, y)</code> </dt> <dd>
<p>Convert <em>y</em> using the unit type of the yaxis.</p> <p>If the artist is not in contained in an Axes or if the yaxis does not have units, <em>y</em> itself is returned.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.draw">
<code>draw(self, renderer)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#TriMesh.draw"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw the Artist using the given renderer.</p> <p>This method will be overridden in the Artist subclasses. Typically, it is implemented to not have any effect if the Artist is not visible (<a class="reference internal" href="_as_gen/matplotlib.artist.artist.get_visible#matplotlib.artist.Artist.get_visible" title="matplotlib.artist.Artist.get_visible"><code>Artist.get_visible</code></a> is <em>False</em>).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase subclass.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.findobj">
<code>findobj(self, match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>match</strong></dt> <dd>
<p class="first">A filter criterion for the matches. This can be</p> <ul class="last simple"> <li>
<em>None</em>: Return all objects contained in artist.</li> <li>A function with signature <code>def match(artist: Artist) -&gt; bool</code>. The result will only contain artists for which the function returns <em>True</em>.</li> <li>A class instance: e.g., <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>. The result will only contain artists of this class or its subclasses (<code>isinstance</code> check).</li> </ul> </dd> <dt>
<code>include_self : bool</code> </dt> <dd>
<p class="first last">Include <em>self</em> in the list to be checked for a match.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>artists : list of Artist</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.format_cursor_data">
<code>format_cursor_data(self, data)</code> </dt> <dd>
<p>Return a string representation of <em>data</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.TriMesh.get_cursor_data" title="matplotlib.collections.TriMesh.get_cursor_data"><code>get_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_agg_filter">
<code>get_agg_filter(self)</code> </dt> <dd>
<p>Return filter function to be used for agg filter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_alpha">
<code>get_alpha(self)</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_animated">
<code>get_animated(self)</code> </dt> <dd>
<p>Return the animated state.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_array">
<code>get_array(self)</code> </dt> <dd>
<p>Return the array</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_capstyle">
<code>get_capstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_children">
<code>get_children(self)</code> </dt> <dd>
<p>Return a list of the child <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s of this <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_clim">
<code>get_clim(self)</code> </dt> <dd>
<p>return the min, max of the color limits for image scaling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_clip_box">
<code>get_clip_box(self)</code> </dt> <dd>
<p>Return the clipbox.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_clip_on">
<code>get_clip_on(self)</code> </dt> <dd>
<p>Return whether the artist uses clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_clip_path">
<code>get_clip_path(self)</code> </dt> <dd>
<p>Return the clip path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_cmap">
<code>get_cmap(self)</code> </dt> <dd>
<p>return the colormap</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_contains">
<code>get_contains(self)</code> </dt> <dd>
<p>Return the custom contains function of the artist if set, or <em>None</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.TriMesh.set_contains" title="matplotlib.collections.TriMesh.set_contains"><code>set_contains</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_cursor_data">
<code>get_cursor_data(self, event)</code> </dt> <dd>
<p>Return the cursor data for a given event.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself.</p> </div> <p>Cursor data can be used by Artists to provide additional context information for a given event. The default implementation just returns <em>None</em>.</p> <p>Subclasses can override the method and return arbitrary data. However, when doing so, they must ensure that <a class="reference internal" href="#matplotlib.collections.TriMesh.format_cursor_data" title="matplotlib.collections.TriMesh.format_cursor_data"><code>format_cursor_data</code></a> can convert the data to a string representation.</p> <p>The only current use case is displaying the z-value of an <a class="reference internal" href="image_api#matplotlib.image.AxesImage" title="matplotlib.image.AxesImage"><code>AxesImage</code></a> in the status bar of a plot window, while moving the mouse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : matplotlib.backend_bases.MouseEvent</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.TriMesh.format_cursor_data" title="matplotlib.collections.TriMesh.format_cursor_data"><code>format_cursor_data</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_dashes">
<code>get_dashes(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.get_linestyle" title="matplotlib.collections.TriMesh.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_datalim">
<code>get_datalim(self, transData)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_ec">
<code>get_ec(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.get_edgecolor" title="matplotlib.collections.TriMesh.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_edgecolor">
<code>get_edgecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_edgecolors">
<code>get_edgecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.get_edgecolor" title="matplotlib.collections.TriMesh.get_edgecolor"><code>get_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_facecolor">
<code>get_facecolor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_facecolors">
<code>get_facecolors(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.get_facecolor" title="matplotlib.collections.TriMesh.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_fc">
<code>get_fc(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.get_facecolor" title="matplotlib.collections.TriMesh.get_facecolor"><code>get_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_figure">
<code>get_figure(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_fill">
<code>get_fill(self)</code> </dt> <dd>
<p>return whether fill is set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_gid">
<code>get_gid(self)</code> </dt> <dd>
<p>Return the group id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_hatch">
<code>get_hatch(self)</code> </dt> <dd>
<p>Return the current hatching pattern.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_in_layout">
<code>get_in_layout(self)</code> </dt> <dd>
<p>Return boolean flag, <code>True</code> if artist is included in layout calculations.</p> <p>E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_joinstyle">
<code>get_joinstyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_label">
<code>get_label(self)</code> </dt> <dd>
<p>Return the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_linestyle">
<code>get_linestyle(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_linestyles">
<code>get_linestyles(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.get_linestyle" title="matplotlib.collections.TriMesh.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_linewidth">
<code>get_linewidth(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_linewidths">
<code>get_linewidths(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.get_linewidth" title="matplotlib.collections.TriMesh.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_ls">
<code>get_ls(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.get_linestyle" title="matplotlib.collections.TriMesh.get_linestyle"><code>get_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_lw">
<code>get_lw(self)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.get_linewidth" title="matplotlib.collections.TriMesh.get_linewidth"><code>get_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_offset_position">
<code>get_offset_position(self)</code> </dt> <dd>
<p>Returns how offsets are applied for the collection. If <em>offset_position</em> is 'screen', the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_offset_transform">
<code>get_offset_transform(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_offsets">
<code>get_offsets(self)</code> </dt> <dd>
<p>Return the offsets for the collection.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_path_effects">
<code>get_path_effects(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_paths">
<code>get_paths(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#TriMesh.get_paths"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_picker">
<code>get_picker(self)</code> </dt> <dd>
<p>Return the picking behavior of the artist.</p> <p>The possible values are described in <a class="reference internal" href="#matplotlib.collections.TriMesh.set_picker" title="matplotlib.collections.TriMesh.set_picker"><code>set_picker</code></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, pickable,</code> <a class="reference internal" href="#matplotlib.collections.TriMesh.pick" title="matplotlib.collections.TriMesh.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_pickradius">
<code>get_pickradius(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_rasterized">
<code>get_rasterized(self)</code> </dt> <dd>
<p>Return whether the artist is to be rasterized.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_sketch_params">
<code>get_sketch_params(self)</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<em>scale</em>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<em>length</em>: The length of the wiggle along the line.</li> <li>
<em>randomness</em>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">Returns <em>None</em> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_snap">
<code>get_snap(self)</code> </dt> <dd>
<p>Returns the snap setting.</p> <p>See <a class="reference internal" href="#matplotlib.collections.TriMesh.set_snap" title="matplotlib.collections.TriMesh.set_snap"><code>set_snap</code></a> for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_tightbbox">
<code>get_tightbbox(self, renderer)</code> </dt> <dd>
<p>Like <code>Artist.get_window_extent</code>, but includes any clipping.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>renderer : RendererBase instance</code> </dt> <dd>
<p class="first last">renderer that will be used to draw the figures (i.e. <code>fig.canvas.get_renderer()</code>)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : BBox</code> </dt> <dd>
<p class="first last">The enclosing bounding box (in figure pixel co-ordinates).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_transform">
<code>get_transform(self)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine(self)</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_transforms">
<code>get_transforms(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_url">
<code>get_url(self)</code> </dt> <dd>
<p>Return the url.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_urls">
<code>get_urls(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_visible">
<code>get_visible(self)</code> </dt> <dd>
<p>Return the visibility.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_window_extent">
<code>get_window_extent(self, renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space.</p> <p>The bounding box' width and height are nonnegative.</p> <p>Subclasses should override for inclusion in the bounding box "tight" calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.get_zorder">
<code>get_zorder(self)</code> </dt> <dd>
<p>Return the artist's zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.have_units">
<code>have_units(self)</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.is_transform_set">
<code>is_transform_set(self)</code> </dt> <dd>
<p>Return whether the Artist has an explicitly set transform.</p> <p>This is <em>True</em> after <a class="reference internal" href="#matplotlib.collections.TriMesh.set_transform" title="matplotlib.collections.TriMesh.set_transform"><code>set_transform</code></a> has been called.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.TriMesh.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.pchanged">
<code>pchanged(self)</code> </dt> <dd>
<p>Call all of the registered callbacks.</p> <p>This function is triggered internally when a property is changed.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.TriMesh.add_callback" title="matplotlib.collections.TriMesh.add_callback"><code>add_callback</code></a>
</dt>  <dt>
 <a class="reference internal" href="#matplotlib.collections.TriMesh.remove_callback" title="matplotlib.collections.TriMesh.remove_callback"><code>remove_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.pick">
<code>pick(self, mouseevent)</code> </dt> <dd>
<p>Process a pick event.</p> <p>Each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.TriMesh.pickable" title="matplotlib.collections.TriMesh.pickable"><code>pickable</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.pickable">
<code>pickable(self)</code> </dt> <dd>
<p>Return whether the artist is pickable.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>set_picker, get_picker,</code> <a class="reference internal" href="#matplotlib.collections.TriMesh.pick" title="matplotlib.collections.TriMesh.pick"><code>pick</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.properties">
<code>properties(self)</code> </dt> <dd>
<p>Return a dictionary of all the properties of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.remove">
<code>remove(self)</code> </dt> <dd>
<p>Remove the artist from the figure if possible.</p> <p>The effect will not be visible until the figure is redrawn, e.g., with <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>FigureCanvasBase.draw_idle</code></a>. Call <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="_as_gen/matplotlib.axes.axes.relim#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim</code></a> will not see collections even if the collection was added to the axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist's legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.remove_callback">
<code>remove_callback(self, oid)</code> </dt> <dd>
<p>Remove a callback based on its observer id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.collections.TriMesh.add_callback" title="matplotlib.collections.TriMesh.add_callback"><code>add_callback</code></a>
</dt>  </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set">
<code>set(self, **kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_aa">
<code>set_aa(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_antialiased" title="matplotlib.collections.TriMesh.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_agg_filter">
<code>set_agg_filter(self, filter_func)</code> </dt> <dd>
<p>Set the agg filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filter_func : callable</code> </dt> <dd>
<p class="first last">A filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_alpha">
<code>set_alpha(self, alpha)</code> </dt> <dd>
<p>Set the alpha transparencies of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>alpha : float or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_animated">
<code>set_animated(self, b)</code> </dt> <dd>
<p>Set the artist's animation state.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_antialiased">
<code>set_antialiased(self, aa)</code> </dt> <dd>
<p>Set the antialiasing state for rendering.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>aa : bool or sequence of bools</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_antialiaseds">
<code>set_antialiaseds(self, aa)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_antialiased" title="matplotlib.collections.TriMesh.set_antialiased"><code>set_antialiased</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_array">
<code>set_array(self, A)</code> </dt> <dd>
<p>Set the image array from numpy array <em>A</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>A : ndarray</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_capstyle">
<code>set_capstyle(self, cs)</code> </dt> <dd>
<p>Set the capstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cs : {'butt', 'round', 'projecting'}</code> </dt> <dd>
<p class="first last">The capstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_clim">
<code>set_clim(self, vmin=None, vmax=None)</code> </dt> <dd>
<p>set the norm limits for image scaling; if <em>vmin</em> is a length2 sequence, interpret it as <code>(vmin, vmax)</code> which is used to support setp</p> <p>ACCEPTS: a length 2 sequence of floats; may be overridden in methods that have <code>vmin</code> and <code>vmax</code> kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_clip_box">
<code>set_clip_box(self, clipbox)</code> </dt> <dd>
<p>Set the artist's clip <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>clipbox : Bbox</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_clip_on">
<code>set_clip_on(self, b)</code> </dt> <dd>
<p>Set whether the artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_clip_path">
<code>set_clip_path(self, path, transform=None)</code> </dt> <dd>
<p>Set the artist's clip path, which may be:</p> <ul class="simple"> <li>a <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance; or</li> <li>a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, in which case a <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance, which will be applied to the path before using it for clipping, must be provided; or</li> <li>
<code>None</code>, to remove a previously set clipping path.</li> </ul> <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <code>None</code>.</p> <p>ACCEPTS: [(<a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_cmap">
<code>set_cmap(self, cmap)</code> </dt> <dd>
<p>set the colormap for luminance data</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cmap : colormap or registered colormap name</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_color">
<code>set_color(self, c)</code> </dt> <dd>
<p>Set both the edgecolor and the facecolor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of rgba tuples</code> </dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Collection.set_facecolor,</code> <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>Collection.set_edgecolor</code></a>
</dt> <dd>For setting the edge or face color individually.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_contains">
<code>set_contains(self, picker)</code> </dt> <dd>
<p>Define a custom contains test for the artist.</p> <p>The provided callable replaces the default <a class="reference internal" href="#matplotlib.collections.TriMesh.contains" title="matplotlib.collections.TriMesh.contains"><code>contains</code></a> method of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : callable</code> </dt> <dd>
<p class="first">A custom picker function to evaluate if an event is within the artist. The function must have the signature:</p> <pre data-language="python">def contains(artist: Artist, event: MouseEvent) -&gt; bool, dict
</pre> <p>that returns:</p> <ul class="last simple"> <li>a bool indicating if the event is within the artist</li> <li>a dict of additional information. The dict should at least return the same information as the default <code>contains()</code> implementation of the respective artist, but may provide additional information.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_dashes">
<code>set_dashes(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_linestyle" title="matplotlib.collections.TriMesh.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_ec">
<code>set_ec(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_edgecolor" title="matplotlib.collections.TriMesh.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_edgecolor">
<code>set_edgecolor(self, c)</code> </dt> <dd>
<p>Set the edgecolor(s) of the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors or 'face'</code> </dt> <dd>
<p class="first last">The collection edgecolor(s). If a sequence, the patches cycle through it. If 'face', match the facecolor.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_edgecolors">
<code>set_edgecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_edgecolor" title="matplotlib.collections.TriMesh.set_edgecolor"><code>set_edgecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_facecolor">
<code>set_facecolor(self, c)</code> </dt> <dd>
<p>Set the facecolor(s) of the collection. <em>c</em> can be a matplotlib color spec (all patches have same color), or a sequence of specs; if it is a sequence the patches will cycle through the sequence.</p> <p>If <em>c</em> is 'none', the patch will not be filled.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : color or sequence of colors</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_facecolors">
<code>set_facecolors(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_facecolor" title="matplotlib.collections.TriMesh.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_fc">
<code>set_fc(self, c)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_facecolor" title="matplotlib.collections.TriMesh.set_facecolor"><code>set_facecolor</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_figure">
<code>set_figure(self, fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig : Figure</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_gid">
<code>set_gid(self, gid)</code> </dt> <dd>
<p>Set the (group) id for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gid : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_hatch">
<code>set_hatch(self, hatch)</code> </dt> <dd>
<p>Set the hatching pattern</p> <p><em>hatch</em> can be one of:</p> <pre data-language="python">/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars
</pre> <p>Letters can be combined, in which case all the specified hatchings are done. If same letter repeats, it increases the density of hatching of that pattern.</p> <p>Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</p> <p>Unlike other properties such as linewidth and colors, hatching can only be specified for the collection as a whole, not separately for each member.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_in_layout">
<code>set_in_layout(self, in_layout)</code> </dt> <dd>
<p>Set if artist is to be included in layout calculations, E.g. <a class="reference internal" href="https://matplotlib.org/3.1.1/tutorials/intermediate/constrainedlayout_guide.html"><span class="doc">Constrained Layout Guide</span></a>, <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.tight_layout" title="matplotlib.figure.Figure.tight_layout"><code>Figure.tight_layout()</code></a>, and <code>fig.savefig(fname, bbox_inches='tight')</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>in_layout : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_joinstyle">
<code>set_joinstyle(self, js)</code> </dt> <dd>
<p>Set the joinstyle for the collection (for all its elements).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>js : {'miter', 'round', 'bevel'}</code> </dt> <dd>
<p class="first last">The joinstyle</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_label">
<code>set_label(self, s)</code> </dt> <dd>
<p>Set a label that will be displayed in the legend.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : object</code> </dt> <dd>
<p class="first last"><em>s</em> will be converted to a string by calling <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><code>str</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_linestyle">
<code>set_linestyle(self, ls)</code> </dt> <dd>
<p>Set the linestyle(s) for the collection.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">linestyle</th> <th class="head">description</th> </tr> </thead>  <tr>
<td>
<code>'-'</code> or <code>'solid'</code>
</td> <td>solid line</td> </tr> <tr>
<td>
<code>'--'</code> or <code>'dashed'</code>
</td> <td>dashed line</td> </tr> <tr>
<td>
<code>'-.'</code> or <code>'dashdot'</code>
</td> <td>dash-dotted line</td> </tr> <tr>
<td>
<code>':'</code> or <code>'dotted'</code>
</td> <td>dotted line</td> </tr>  </table> <p>Alternatively a dash tuple of the following form can be provided:</p> <pre data-language="python">(offset, onoffseq),
</pre> <p>where <code>onoffseq</code> is an even length tuple of on and off ink in points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}</code> </dt> <dd>
<p class="first last">The line style.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_linestyles">
<code>set_linestyles(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_linestyle" title="matplotlib.collections.TriMesh.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_linewidth">
<code>set_linewidth(self, lw)</code> </dt> <dd>
<p>Set the linewidth(s) for the collection. <em>lw</em> can be a scalar or a sequence; if it is a sequence the patches will cycle through the sequence</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>lw : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_linewidths">
<code>set_linewidths(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_linewidth" title="matplotlib.collections.TriMesh.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_ls">
<code>set_ls(self, ls)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_linestyle" title="matplotlib.collections.TriMesh.set_linestyle"><code>set_linestyle</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_lw">
<code>set_lw(self, lw)</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#matplotlib.collections.TriMesh.set_linewidth" title="matplotlib.collections.TriMesh.set_linewidth"><code>set_linewidth</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_norm">
<code>set_norm(self, norm)</code> </dt> <dd>
<p>Set the normalization instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>norm : Normalize</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If there are any colorbars using the mappable for this norm, setting the norm of the mappable will reset the norm, locator, and formatters on the colorbar to default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_offset_position">
<code>set_offset_position(self, offset_position)</code> </dt> <dd>
<p>Set how offsets are applied. If <em>offset_position</em> is 'screen' (default) the offset is applied after the master transform has been applied, that is, the offsets are in screen coordinates. If offset_position is 'data', the offset is applied before the master transform, i.e., the offsets are in data coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offset_position : {'screen', 'data'}</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_offsets">
<code>set_offsets(self, offsets)</code> </dt> <dd>
<p>Set the offsets for the collection.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>offsets : float or sequence of floats</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_path_effects">
<code>set_path_effects(self, path_effects)</code> </dt> <dd>
<p>Set the path effects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path_effects : AbstractPathEffect</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_paths">
<code>set_paths(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/collections.html#TriMesh.set_paths"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_picker">
<code>set_picker(self, picker)</code> </dt> <dd>
<p>Define the picking behavior of the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>picker : None or bool or float or callable</code> </dt> <dd>
<p class="first">This can be one of the following:</p> <ul class="last"> <li>
<em>None</em>: Picking is disabled for this artist (default). </li> <li>A boolean: If <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist. </li> <li>A float: If picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it's data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: If picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_pickradius">
<code>set_pickradius(self, pr)</code> </dt> <dd>
<p>Set the pick radius used for containment tests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : float</code> </dt> <dd>
<p class="first last">Pick radius, in points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_rasterized">
<code>set_rasterized(self, rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend's default behavior.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>rasterized : bool or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128.0)</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16.0)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_snap">
<code>set_snap(self, snap)</code> </dt> <dd>
<p>Set the snapping behavior.</p> <p>Snapping aligns positions with the pixel grid, which results in clearer images. For example, if a black line of 1px width was defined at a position in between two pixels, the resulting image would contain the interpolated value of that line in the pixel grid, which would be a grey value on both adjacent pixel positions. In contrast, snapping will move the line to the nearest integer pixel value, so that the resulting image will really contain a 1px wide black line.</p> <p>Snapping is currently only supported by the Agg and MacOSX backends.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>snap : bool or None</code> </dt> <dd>
<p class="first">Possible values:</p> <ul class="last simple"> <li>
<em>True</em>: Snap vertices to the nearest pixel center.</li> <li>
<em>False</em>: Do not modify vertex positions.</li> <li>
<em>None</em>: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center.</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_transform">
<code>set_transform(self, t)</code> </dt> <dd>
<p>Set the artist transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>t : Transform</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_url">
<code>set_url(self, url)</code> </dt> <dd>
<p>Set the url for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>url : str</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_urls">
<code>set_urls(self, urls)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>urls : List[str] or None</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_visible">
<code>set_visible(self, b)</code> </dt> <dd>
<p>Set the artist's visibility.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>b : bool</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.set_zorder">
<code>set_zorder(self, level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>level : float</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.TriMesh.stale">
<code>stale</code> </dt> <dd>
<p>Whether the artist is 'stale' and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.TriMesh.sticky_edges">
<code>sticky_edges</code> </dt> <dd>
<p><code>x</code> and <code>y</code> sticky edge lists for autoscaling.</p> <p>When performing autoscaling, if a data limit coincides with a value in the corresponding sticky_edges list, then no margin will be added--the view limit "sticks" to the edge. A typical use case is histograms, where one usually expects no margin on the bottom edge (0) of the histogram.</p> <p>This attribute cannot be assigned to; however, the <code>x</code> and <code>y</code> lists can be modified in place as needed.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax)
&gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.to_rgba">
<code>to_rgba(self, x, alpha=None, bytes=False, norm=True)</code> </dt> <dd>
<p>Return a normalized rgba array corresponding to <em>x</em>.</p> <p>In the normal case, <em>x</em> is a 1-D or 2-D sequence of scalars, and the corresponding ndarray of rgba values will be returned, based on the norm and colormap set for this ScalarMappable.</p> <p>There is one special case, for handling images that are already rgb or rgba, such as might have been read from an image file. If <em>x</em> is an ndarray with 3 dimensions, and the last dimension is either 3 or 4, then it will be treated as an rgb or rgba array, and no mapping will be done. The array can be uint8, or it can be floating point with values in the 0-1 range; otherwise a ValueError will be raised. If it is a masked array, the mask will be ignored. If the last dimension is 3, the <em>alpha</em> kwarg (defaulting to 1) will be used to fill in the transparency. If the last dimension is 4, the <em>alpha</em> kwarg is ignored; it does not replace the pre-existing alpha. A ValueError will be raised if the third dimension is other than 3 or 4.</p> <p>In either case, if <em>bytes</em> is <em>False</em> (default), the rgba array will be floats in the 0-1 range; if it is <em>True</em>, the returned rgba array will be uint8 in the 0 to 255 range.</p> <p>If norm is False, no normalization of the input data is performed, and it is assumed to be in the range (0-1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.update">
<code>update(self, props)</code> </dt> <dd>
<p>Update this artist's properties from the dictionary <em>props</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.update_from">
<code>update_from(self, other)</code> </dt> <dd>
<p>copy properties from other to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.collections.TriMesh.update_scalarmappable">
<code>update_scalarmappable(self)</code> </dt> <dd>
<p>Update colors from the scalar mappable array, if it is not None.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.collections.TriMesh.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2018 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.1.1/api/collections_api.html" class="_attribution-link">https://matplotlib.org/3.1.1/api/collections_api.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
