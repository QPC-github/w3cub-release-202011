
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>API - Flask 1.1 - W3cubDocs</title>
  
  <meta name="description" content="This part of the documentation covers all the interfaces of Flask. For parts where Flask depends on external libraries, we document the most &hellip;">
  <meta name="keywords" content="api, flask, flask~1.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/flask~1.1/api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c7076d7cdaddc6969cb97911f9b488459d4bebca88d6f2525f2a12432f0bec8426c751ccfbc34920dda3867e50ab24698396bc4e548e788fc826f69a158d6856.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/flask~1.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/flask~1.1/" class="_nav-link" title="" style="margin-left:0;">Flask 1.1</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="id1">API</h1> <p id="module-flask">This part of the documentation covers all the interfaces of Flask. For parts where Flask depends on external libraries, we document the most important right here and provide links to the canonical documentation.</p>  <h2 id="application-object">Application Object</h2> <dl class="class"> <dt id="flask.Flask">
<code>class flask.Flask(import_name, static_url_path=None, static_folder='static', static_host=None, host_matching=False, subdomain_matching=False, template_folder='templates', instance_path=None, instance_relative_config=False, root_path=None)</code> </dt> <dd>
<p>The flask object implements a WSGI application and acts as the central object. It is passed the name of the module or package of the application. Once it is created it will act as a central registry for the view functions, the URL rules, template configuration and much more.</p> <p>The name of the package is used to resolve resources from inside the package or the folder the module is contained in depending on if the package parameter resolves to an actual python package (a folder with an <code>__init__.py</code> file inside) or a standard module (just a <code>.py</code> file).</p> <p>For more information about resource loading, see <a class="reference internal" href="#flask.Flask.open_resource" title="flask.Flask.open_resource"><code>open_resource()</code></a>.</p> <p>Usually you create a <a class="reference internal" href="#flask.Flask" title="flask.Flask"><code>Flask</code></a> instance in your main module or in the <code>__init__.py</code> file of your package like this:</p> <pre data-language="python">from flask import Flask
app = Flask(__name__)
</pre> <div class="admonition-about-the-first-parameter admonition"> <p class="admonition-title">About the First Parameter</p> <p>The idea of the first parameter is to give Flask an idea of what belongs to your application. This name is used to find resources on the filesystem, can be used by extensions to improve debugging information and a lot more.</p> <p>So it’s important what you provide there. If you are using a single module, <code>__name__</code> is always the correct value. If you however are using a package, it’s usually recommended to hardcode the name of your package there.</p> <p>For example if your application is defined in <code>yourapplication/app.py</code> you should create it with one of the two versions below:</p> <pre data-language="python">app = Flask('yourapplication')
app = Flask(__name__.split('.')[0])
</pre> <p>Why is that? The application will work even with <code>__name__</code>, thanks to how resources are looked up. However it will make debugging more painful. Certain extensions can make assumptions based on the import name of your application. For example the Flask-SQLAlchemy extension will look for the code in your application that triggered an SQL query in debug mode. If the import name is not properly set up, that debugging information is lost. (For example it would only pick up SQL queries in <code>yourapplication.app</code> and not <code>yourapplication.views.frontend</code>)</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 1.0: </span>The <code>host_matching</code> and <code>static_host</code> parameters were added.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0: </span>The <code>subdomain_matching</code> parameter was added. Subdomain matching needs to be enabled manually now. Setting <a class="reference internal" href="../config/index#SERVER_NAME" title="SERVER_NAME"><code>SERVER_NAME</code></a> does not implicitly enable it.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.11: </span>The <code>root_path</code> parameter was added.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.8: </span>The <code>instance_path</code> and <code>instance_relative_config</code> parameters were added.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.7: </span>The <code>static_url_path</code>, <code>static_folder</code>, and <code>template_folder</code> parameters were added.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>import_name</strong> – the name of the application package</li> <li>
<strong>static_url_path</strong> – can be used to specify a different path for the static files on the web. Defaults to the name of the <code>static_folder</code> folder.</li> <li>
<strong>static_folder</strong> – The folder with static files that is served at <code>static_url_path</code>. Relative to the application <code>root_path</code> or an absolute path. Defaults to <code>'static'</code>.</li> <li>
<strong>static_host</strong> – the host to use when adding the static route. Defaults to None. Required when using <code>host_matching=True</code> with a <code>static_folder</code> configured.</li> <li>
<strong>host_matching</strong> – set <code>url_map.host_matching</code> attribute. Defaults to False.</li> <li>
<strong>subdomain_matching</strong> – consider the subdomain relative to <a class="reference internal" href="../config/index#SERVER_NAME" title="SERVER_NAME"><code>SERVER_NAME</code></a> when matching routes. Defaults to False.</li> <li>
<strong>template_folder</strong> – the folder that contains the templates that should be used by the application. Defaults to <code>'templates'</code> folder in the root path of the application.</li> <li>
<strong>instance_path</strong> – An alternative instance path for the application. By default the folder <code>'instance'</code> next to the package or module is assumed to be the instance path.</li> <li>
<strong>instance_relative_config</strong> – if set to <code>True</code> relative filenames for loading the config are assumed to be relative to the instance path instead of the application root.</li> <li>
<strong>root_path</strong> – Flask by default will automatically calculate the path to the root of the application. In certain situations this cannot be achieved (for instance if the package is a Python 3 namespace package) and needs to be manually defined.</li> </ul> </dd> </dl> <dl class="method"> <dt id="flask.Flask.add_template_filter">
<code>add_template_filter(f, name=None)</code> </dt> <dd>
<p>Register a custom template filter. Works exactly like the <a class="reference internal" href="#flask.Flask.template_filter" title="flask.Flask.template_filter"><code>template_filter()</code></a> decorator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the filter, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.add_template_global">
<code>add_template_global(f, name=None)</code> </dt> <dd>
<p>Register a custom template global function. Works exactly like the <a class="reference internal" href="#flask.Flask.template_global" title="flask.Flask.template_global"><code>template_global()</code></a> decorator.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the global function, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.add_template_test">
<code>add_template_test(f, name=None)</code> </dt> <dd>
<p>Register a custom template test. Works exactly like the <a class="reference internal" href="#flask.Flask.template_test" title="flask.Flask.template_test"><code>template_test()</code></a> decorator.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the test, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.add_url_rule">
<code>add_url_rule(rule, endpoint=None, view_func=None, provide_automatic_options=None, **options)</code> </dt> <dd>
<p>Connects a URL rule. Works exactly like the <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><code>route()</code></a> decorator. If a view_func is provided it will be registered with the endpoint.</p> <p>Basically this example:</p> <pre data-language="python">@app.route('/')
def index():
    pass
</pre> <p>Is equivalent to the following:</p> <pre data-language="python">def index():
    pass
app.add_url_rule('/', 'index', index)
</pre> <p>If the view_func is not provided you will need to connect the endpoint to a view function like so:</p> <pre data-language="python">app.view_functions['index'] = index
</pre> <p>Internally <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><code>route()</code></a> invokes <a class="reference internal" href="#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><code>add_url_rule()</code></a> so if you want to customize the behavior via subclassing you only need to change this method.</p> <p>For more information refer to <a class="reference internal" href="#url-route-registrations"><span class="std std-ref">URL Route Registrations</span></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.6: </span><code>OPTIONS</code> is added automatically as method.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.2: </span><code>view_func</code> parameter added.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>rule</strong> – the URL rule as string</li> <li>
<strong>endpoint</strong> – the endpoint for the registered URL rule. Flask itself assumes the name of the view function as endpoint</li> <li>
<strong>view_func</strong> – the function to call when serving a request to the provided endpoint</li> <li>
<strong>provide_automatic_options</strong> – controls whether the <code>OPTIONS</code> method should be added automatically. This can also be controlled by setting the <code>view_func.provide_automatic_options = False</code> before adding the rule.</li> <li>
<strong>options</strong> – the options to be forwarded to the underlying <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule" title="(in Werkzeug v1.0.x)"><code>Rule</code></a> object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to (<code>GET</code>, <code>POST</code> etc.). By default a rule just listens for <code>GET</code> (and implicitly <code>HEAD</code>). Starting with Flask 0.6, <code>OPTIONS</code> is implicitly added and handled by the standard request handling.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.after_request">
<code>after_request(f)</code> </dt> <dd>
<p>Register a function to be run after each request.</p> <p>Your function must take one parameter, an instance of <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><code>response_class</code></a> and return a new response object or the same (see <a class="reference internal" href="#flask.Flask.process_response" title="flask.Flask.process_response"><code>process_response()</code></a>).</p> <p>As of Flask 0.7 this function might not be executed at the end of the request in case an unhandled exception occurred.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.after_request_funcs">
<code>after_request_funcs = None</code> </dt> <dd>
<p>A dictionary with lists of functions that should be called after each request. The key of the dictionary is the name of the blueprint this function is active for, <code>None</code> for all requests. This can for example be used to close database connections. To register a function here, use the <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><code>after_request()</code></a> decorator.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.app_context">
<code>app_context()</code> </dt> <dd>
<p>Create an <a class="reference internal" href="#flask.ctx.AppContext" title="flask.ctx.AppContext"><code>AppContext</code></a>. Use as a <code>with</code> block to push the context, which will make <a class="reference internal" href="#flask.current_app" title="flask.current_app"><code>current_app</code></a> point at this application.</p> <p>An application context is automatically pushed by <a class="reference internal" href="#flask.ctx.RequestContext.push" title="flask.ctx.RequestContext.push"><code>RequestContext.push()</code></a> when handling a request, and when running a CLI command. Use this to manually create a context outside of these situations.</p> <pre data-language="python">with app.app_context():
    init_db()
</pre> <p>See <a class="reference internal" href="../appcontext/index"><span class="doc">The Application Context</span></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.app_ctx_globals_class">
<code>app_ctx_globals_class</code> </dt> <dd>
<p>alias of <a class="reference internal" href="#flask.ctx._AppCtxGlobals" title="flask.ctx._AppCtxGlobals"><code>flask.ctx._AppCtxGlobals</code></a></p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.auto_find_instance_path">
<code>auto_find_instance_path()</code> </dt> <dd>
<p>Tries to locate the instance path if it was not provided to the constructor of the application class. It will basically calculate the path to a folder named <code>instance</code> next to your main file or the package.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.before_first_request">
<code>before_first_request(f)</code> </dt> <dd>
<p>Registers a function to be run before the first request to this instance of the application.</p> <p>The function will be called without any arguments and its return value is ignored.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.before_first_request_funcs">
<code>before_first_request_funcs = None</code> </dt> <dd>
<p>A list of functions that will be called at the beginning of the first request to this instance. To register a function, use the <a class="reference internal" href="#flask.Flask.before_first_request" title="flask.Flask.before_first_request"><code>before_first_request()</code></a> decorator.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.before_request">
<code>before_request(f)</code> </dt> <dd>
<p>Registers a function to run before each request.</p> <p>For example, this can be used to open a database connection, or to load the logged in user from the session.</p> <p>The function will be called without any arguments. If it returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.before_request_funcs">
<code>before_request_funcs = None</code> </dt> <dd>
<p>A dictionary with lists of functions that will be called at the beginning of each request. The key of the dictionary is the name of the blueprint this function is active for, or <code>None</code> for all requests. To register a function, use the <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><code>before_request()</code></a> decorator.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.blueprints">
<code>blueprints = None</code> </dt> <dd>
<p>all the attached blueprints in a dictionary by name. Blueprints can be attached multiple times so this dictionary does not tell you how often they got attached.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.config">
<code>config = None</code> </dt> <dd>
<p>The configuration dictionary as <a class="reference internal" href="#flask.Config" title="flask.Config"><code>Config</code></a>. This behaves exactly like a regular dictionary but supports additional methods to load a config from files.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.config_class">
<code>config_class</code> </dt> <dd>
<p>alias of <code>flask.config.Config</code></p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.context_processor">
<code>context_processor(f)</code> </dt> <dd>
<p>Registers a template context processor function.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.create_global_jinja_loader">
<code>create_global_jinja_loader()</code> </dt> <dd>
<p>Creates the loader for the Jinja2 environment. Can be used to override just the loader and keeping the rest unchanged. It’s discouraged to override this function. Instead one should override the <a class="reference internal" href="#flask.Flask.jinja_loader" title="flask.Flask.jinja_loader"><code>jinja_loader()</code></a> function instead.</p> <p>The global loader dispatches between the loaders of the application and the individual blueprints.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.create_jinja_environment">
<code>create_jinja_environment()</code> </dt> <dd>
<p>Create the Jinja environment based on <a class="reference internal" href="#flask.Flask.jinja_options" title="flask.Flask.jinja_options"><code>jinja_options</code></a> and the various Jinja-related methods of the app. Changing <a class="reference internal" href="#flask.Flask.jinja_options" title="flask.Flask.jinja_options"><code>jinja_options</code></a> after this will have no effect. Also adds Flask-related globals and filters to the environment.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.11: </span><code>Environment.auto_reload</code> set in accordance with <code>TEMPLATES_AUTO_RELOAD</code> configuration option.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.create_url_adapter">
<code>create_url_adapter(request)</code> </dt> <dd>
<p>Creates a URL adapter for the given request. The URL adapter is created at a point where the request context is not yet set up so the request is passed explicitly.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span><a class="reference internal" href="../config/index#SERVER_NAME" title="SERVER_NAME"><code>SERVER_NAME</code></a> no longer implicitly enables subdomain matching. Use <code>subdomain_matching</code> instead.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>This can now also be called without a request object when the URL adapter is created for the application context.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.debug">
<code>property debug</code> </dt> <dd>
<p>Whether debug mode is enabled. When using <code>flask run</code> to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. This maps to the <a class="reference internal" href="../config/index#DEBUG" title="DEBUG"><code>DEBUG</code></a> config key. This is enabled when <a class="reference internal" href="#flask.Flask.env" title="flask.Flask.env"><code>env</code></a> is <code>'development'</code> and is overridden by the <code>FLASK_DEBUG</code> environment variable. It may not behave as expected if set in code.</p> <p><strong>Do not enable debug mode when deploying in production.</strong></p> <p>Default: <code>True</code> if <a class="reference internal" href="#flask.Flask.env" title="flask.Flask.env"><code>env</code></a> is <code>'development'</code>, or <code>False</code> otherwise.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.default_config">
<code>default_config = {'APPLICATION_ROOT': '/', 'DEBUG': None, 'ENV': None, 'EXPLAIN_TEMPLATE_LOADING': False, 'JSONIFY_MIMETYPE': 'application/json', 'JSONIFY_PRETTYPRINT_REGULAR': False, 'JSON_AS_ASCII': True, 'JSON_SORT_KEYS': True, 'MAX_CONTENT_LENGTH': None, 'MAX_COOKIE_SIZE': 4093, 'PERMANENT_SESSION_LIFETIME': datetime.timedelta(days=31), 'PREFERRED_URL_SCHEME': 'http', 'PRESERVE_CONTEXT_ON_EXCEPTION': None, 'PROPAGATE_EXCEPTIONS': None, 'SECRET_KEY': None, 'SEND_FILE_MAX_AGE_DEFAULT': datetime.timedelta(seconds=43200), 'SERVER_NAME': None, 'SESSION_COOKIE_DOMAIN': None, 'SESSION_COOKIE_HTTPONLY': True, 'SESSION_COOKIE_NAME': 'session', 'SESSION_COOKIE_PATH': None, 'SESSION_COOKIE_SAMESITE': None, 'SESSION_COOKIE_SECURE': False, 'SESSION_REFRESH_EACH_REQUEST': True, 'TEMPLATES_AUTO_RELOAD': None, 'TESTING': False, 'TRAP_BAD_REQUEST_ERRORS': None, 'TRAP_HTTP_EXCEPTIONS': False, 'USE_X_SENDFILE': False}</code> </dt> <dd>
<p>Default configuration parameters.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.dispatch_request">
<code>dispatch_request()</code> </dt> <dd>
<p>Does the request dispatching. Matches the URL and returns the return value of the view or error handler. This does not have to be a response object. In order to convert the return value to a proper response object, call <a class="reference internal" href="#flask.make_response" title="flask.make_response"><code>make_response()</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.7: </span>This no longer does the exception handling, this code was moved to the new <a class="reference internal" href="#flask.Flask.full_dispatch_request" title="flask.Flask.full_dispatch_request"><code>full_dispatch_request()</code></a>.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.do_teardown_appcontext">
<code>do_teardown_appcontext(exc=&lt;object object&gt;)</code> </dt> <dd>
<p>Called right before the application context is popped.</p> <p>When handling a request, the application context is popped after the request context. See <a class="reference internal" href="#flask.Flask.do_teardown_request" title="flask.Flask.do_teardown_request"><code>do_teardown_request()</code></a>.</p> <p>This calls all functions decorated with <a class="reference internal" href="#flask.Flask.teardown_appcontext" title="flask.Flask.teardown_appcontext"><code>teardown_appcontext()</code></a>. Then the <a class="reference internal" href="#flask.appcontext_tearing_down" title="flask.appcontext_tearing_down"><code>appcontext_tearing_down</code></a> signal is sent.</p> <p>This is called by <a class="reference internal" href="#flask.ctx.AppContext.pop" title="flask.ctx.AppContext.pop"><code>AppContext.pop()</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.do_teardown_request">
<code>do_teardown_request(exc=&lt;object object&gt;)</code> </dt> <dd>
<p>Called after the request is dispatched and the response is returned, right before the request context is popped.</p> <p>This calls all functions decorated with <a class="reference internal" href="#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><code>teardown_request()</code></a>, and <a class="reference internal" href="#flask.Blueprint.teardown_request" title="flask.Blueprint.teardown_request"><code>Blueprint.teardown_request()</code></a> if a blueprint handled the request. Finally, the <a class="reference internal" href="#flask.request_tearing_down" title="flask.request_tearing_down"><code>request_tearing_down</code></a> signal is sent.</p> <p>This is called by <a class="reference internal" href="#flask.ctx.RequestContext.pop" title="flask.ctx.RequestContext.pop"><code>RequestContext.pop()</code></a>, which may be delayed during testing to maintain access to resources.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>exc</strong> – An unhandled exception raised while dispatching the request. Detected from the current exception information if not passed. Passed to each teardown function.</p> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>Added the <code>exc</code> argument.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.endpoint">
<code>endpoint(endpoint)</code> </dt> <dd>
<p>A decorator to register a function as an endpoint. Example:</p> <pre data-language="python">@app.endpoint('example.endpoint')
def example():
    return "example"
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>endpoint</strong> – the name of the endpoint</p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.env">
<code>env</code> </dt> <dd>
<p>What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. This maps to the <a class="reference internal" href="../config/index#ENV" title="ENV"><code>ENV</code></a> config key. This is set by the <code id="index-0">FLASK_ENV</code> environment variable and may not behave as expected if set in code.</p> <p><strong>Do not enable development when deploying in production.</strong></p> <p>Default: <code>'production'</code></p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.error_handler_spec">
<code>error_handler_spec = None</code> </dt> <dd>
<p>A dictionary of all registered error handlers. The key is <code>None</code> for error handlers active on the application, otherwise the key is the name of the blueprint. Each key points to another dictionary where the key is the status code of the http exception. The special key <code>None</code> points to a list of tuples where the first item is the class for the instance check and the second the error handler function.</p> <p>To register an error handler, use the <a class="reference internal" href="#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><code>errorhandler()</code></a> decorator.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.errorhandler">
<code>errorhandler(code_or_exception)</code> </dt> <dd>
<p>Register a function to handle errors by code or exception class.</p> <p>A decorator that is used to register a function given an error code. Example:</p> <pre data-language="python">@app.errorhandler(404)
def page_not_found(error):
    return 'This page does not exist', 404
</pre> <p>You can also register handlers for arbitrary exceptions:</p> <pre data-language="python">@app.errorhandler(DatabaseError)
def special_exception_handler(error):
    return 'Database connection failed', 500
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7: </span>Use <a class="reference internal" href="#flask.Flask.register_error_handler" title="flask.Flask.register_error_handler"><code>register_error_handler()</code></a> instead of modifying <a class="reference internal" href="#flask.Flask.error_handler_spec" title="flask.Flask.error_handler_spec"><code>error_handler_spec</code></a> directly, for application wide error handlers.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.7: </span>One can now additionally also register custom exception types that do not necessarily have to be a subclass of the <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException" title="(in Werkzeug v1.0.x)"><code>HTTPException</code></a> class.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>code_or_exception</strong> – the code as integer for the handler, or an arbitrary exception</p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.extensions">
<code>extensions = None</code> </dt> <dd>
<p>a place where extensions can store application specific state. For example this is where an extension could store database engines and similar things. For backwards compatibility extensions should register themselves like this:</p> <pre data-language="python">if not hasattr(app, 'extensions'):
    app.extensions = {}
app.extensions['extensionname'] = SomeObject()
</pre> <p>The key must match the name of the extension module. For example in case of a “Flask-Foo” extension in <code>flask_foo</code>, the key would be <code>'foo'</code>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.full_dispatch_request">
<code>full_dispatch_request()</code> </dt> <dd>
<p>Dispatches the request and on top of that performs request pre and postprocessing as well as HTTP exception catching and error handling.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.get_send_file_max_age">
<code>get_send_file_max_age(filename)</code> </dt> <dd>
<p>Provides default cache_timeout for the <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a> functions.</p> <p>By default, this function returns <code>SEND_FILE_MAX_AGE_DEFAULT</code> from the configuration of <a class="reference internal" href="#flask.current_app" title="flask.current_app"><code>current_app</code></a>.</p> <p>Static file functions such as <a class="reference internal" href="#flask.send_from_directory" title="flask.send_from_directory"><code>send_from_directory()</code></a> use this function, and <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a> calls this function on <a class="reference internal" href="#flask.current_app" title="flask.current_app"><code>current_app</code></a> when the given cache_timeout is <code>None</code>. If a cache_timeout is given in <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a>, that timeout is used; otherwise, this method is called.</p> <p>This allows subclasses to change the behavior when sending files based on the filename. For example, to set the cache timeout for .js files to 60 seconds:</p> <pre data-language="python">class MyFlask(flask.Flask):
    def get_send_file_max_age(self, name):
        if name.lower().endswith('.js'):
            return 60
        return flask.Flask.get_send_file_max_age(self, name)
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.got_first_request">
<code>property got_first_request</code> </dt> <dd>
<p>This attribute is set to <code>True</code> if the application started handling the first request.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.handle_exception">
<code>handle_exception(e)</code> </dt> <dd>
<p>Handle an exception that did not have an error handler associated with it, or that was raised from an error handler. This always causes a 500 <code>InternalServerError</code>.</p> <p>Always sends the <a class="reference internal" href="#flask.got_request_exception" title="flask.got_request_exception"><code>got_request_exception</code></a> signal.</p> <p>If <a class="reference internal" href="#flask.Flask.propagate_exceptions" title="flask.Flask.propagate_exceptions"><code>propagate_exceptions</code></a> is <code>True</code>, such as in debug mode, the error will be re-raised so that the debugger can display it. Otherwise, the original exception is logged, and an <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.InternalServerError" title="(in Werkzeug v1.0.x)"><code>InternalServerError</code></a> is returned.</p> <p>If an error handler is registered for <code>InternalServerError</code> or <code>500</code>, it will be used. For consistency, the handler will always receive the <code>InternalServerError</code>. The original unhandled exception is available as <code>e.original_exception</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Prior to Werkzeug 1.0.0, <code>InternalServerError</code> will not always have an <code>original_exception</code> attribute. Use <code>getattr(e, "original_exception", None)</code> to simulate the behavior for compatibility.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.1.0: </span>Always passes the <code>InternalServerError</code> instance to the handler, setting <code>original_exception</code> to the unhandled error.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.1.0: </span><code>after_request</code> functions and other finalization is done even for the default 500 response when there is no handler.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.3.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.handle_http_exception">
<code>handle_http_exception(e)</code> </dt> <dd>
<p>Handles an HTTP exception. By default this will invoke the registered error handlers and fall back to returning the exception as response.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0.3: </span><code>RoutingException</code>, used internally for actions such as slash redirects during routing, is not passed to error handlers.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>Exceptions are looked up by code <em>and</em> by MRO, so <code>HTTPExcpetion</code> subclasses can be handled with a catch-all handler for the base <code>HTTPException</code>.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.3.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.handle_url_build_error">
<code>handle_url_build_error(error, endpoint, values)</code> </dt> <dd>
<p>Handle <code>BuildError</code> on <a class="reference internal" href="#flask.url_for" title="flask.url_for"><code>url_for()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.handle_user_exception">
<code>handle_user_exception(e)</code> </dt> <dd>
<p>This method is called whenever an exception occurs that should be handled. A special case is <code>HTTPException</code> which is forwarded to the <a class="reference internal" href="#flask.Flask.handle_http_exception" title="flask.Flask.handle_http_exception"><code>handle_http_exception()</code></a> method. This function will either return a response value or reraise the exception with the same traceback.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>Key errors raised from request data like <code>form</code> show the bad key in debug mode rather than a generic bad request message.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.has_static_folder">
<code>property has_static_folder</code> </dt> <dd>
<p>This is <code>True</code> if the package bound object’s container has a folder for static files.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.import_name">
<code>import_name = None</code> </dt> <dd>
<p>The name of the package or module that this app belongs to. Do not change this once it is set by the constructor.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.inject_url_defaults">
<code>inject_url_defaults(endpoint, values)</code> </dt> <dd>
<p>Injects the URL defaults for the given endpoint directly into the values dictionary passed. This is used internally and automatically called on URL building.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.instance_path">
<code>instance_path = None</code> </dt> <dd>
<p>Holds the path to the instance folder.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.iter_blueprints">
<code>iter_blueprints()</code> </dt> <dd>
<p>Iterates over all blueprints by the order they were registered.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.jinja_env">
<code>jinja_env</code> </dt> <dd>
<p>The Jinja environment used to load templates.</p> <p>The environment is created the first time this property is accessed. Changing <a class="reference internal" href="#flask.Flask.jinja_options" title="flask.Flask.jinja_options"><code>jinja_options</code></a> after that will have no effect.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.jinja_environment">
<code>jinja_environment</code> </dt> <dd>
<p>alias of <code>flask.templating.Environment</code></p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.jinja_loader">
<code>jinja_loader</code> </dt> <dd>
<p>The Jinja loader for this package bound object.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.jinja_options">
<code>jinja_options = {'extensions': ['jinja2.ext.autoescape', 'jinja2.ext.with_']}</code> </dt> <dd>
<p>Options that are passed to the Jinja environment in <a class="reference internal" href="#flask.Flask.create_jinja_environment" title="flask.Flask.create_jinja_environment"><code>create_jinja_environment()</code></a>. Changing these options after the environment is created (accessing <a class="reference internal" href="#flask.Flask.jinja_env" title="flask.Flask.jinja_env"><code>jinja_env</code></a>) will have no effect.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.1.0: </span>This is a <code>dict</code> instead of an <code>ImmutableDict</code> to allow easier configuration.</p> </div> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.json_decoder">
<code>json_decoder</code> </dt> <dd>
<p>alias of <a class="reference internal" href="#flask.json.JSONDecoder" title="flask.json.JSONDecoder"><code>flask.json.JSONDecoder</code></a></p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.json_encoder">
<code>json_encoder</code> </dt> <dd>
<p>alias of <a class="reference internal" href="#flask.json.JSONEncoder" title="flask.json.JSONEncoder"><code>flask.json.JSONEncoder</code></a></p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.log_exception">
<code>log_exception(exc_info)</code> </dt> <dd>
<p>Logs an exception. This is called by <a class="reference internal" href="#flask.Flask.handle_exception" title="flask.Flask.handle_exception"><code>handle_exception()</code></a> if debugging is disabled and right before the handler is called. The default implementation logs the exception as error on the <a class="reference internal" href="#flask.Flask.logger" title="flask.Flask.logger"><code>logger</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.logger">
<code>logger</code> </dt> <dd>
<p>A standard Python <a class="reference external" href="https://docs.python.org/3/library/logging.html#logging.Logger" title="(in Python v3.9)"><code>Logger</code></a> for the app, with the same name as <a class="reference internal" href="#flask.Flask.name" title="flask.Flask.name"><code>name</code></a>.</p> <p>In debug mode, the logger’s <code>level</code> will be set to <code>DEBUG</code>.</p> <p>If there are no handlers configured, a default handler will be added. See <a class="reference internal" href="../logging/index"><span class="doc">Logging</span></a> for more information.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.1.0: </span>The logger takes the same name as <a class="reference internal" href="#flask.Flask.name" title="flask.Flask.name"><code>name</code></a> rather than hard-coding <code>"flask.app"</code>.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0.0: </span>Behavior was simplified. The logger is always named <code>"flask.app"</code>. The level is only set during configuration, it doesn’t check <code>app.debug</code> each time. Only one format is used, not different ones depending on <code>app.debug</code>. No handlers are removed, and a handler is only added if no handlers are already configured.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.3.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.make_config">
<code>make_config(instance_relative=False)</code> </dt> <dd>
<p>Used to create the config attribute by the Flask constructor. The <code>instance_relative</code> parameter is passed in from the constructor of Flask (there named <code>instance_relative_config</code>) and indicates if the config should be relative to the instance path or the root path of the application.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.make_default_options_response">
<code>make_default_options_response()</code> </dt> <dd>
<p>This method is called to create the default <code>OPTIONS</code> response. This can be changed through subclassing to change the default behavior of <code>OPTIONS</code> responses.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.make_null_session">
<code>make_null_session()</code> </dt> <dd>
<p>Creates a new instance of a missing session. Instead of overriding this method we recommend replacing the <a class="reference internal" href="#flask.Flask.session_interface" title="flask.Flask.session_interface"><code>session_interface</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.make_response">
<code>make_response(rv)</code> </dt> <dd>
<p>Convert the return value from a view function to an instance of <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><code>response_class</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>rv</strong> – </p>
<p>the return value from the view function. The view function must return a response. Returning <code>None</code>, or the view ending without returning, is not allowed. The following types are allowed for <code>view_rv</code>:</p> <dl class="simple"> <dt>
<code>str (unicode in Python 2)</code> </dt>
<dd>
<p>A response object is created with the string encoded to UTF-8 as the body.</p> </dd> <dt>
<code>bytes (str in Python 2)</code> </dt>
<dd>
<p>A response object is created with the bytes as the body.</p> </dd> <dt>
<code>dict</code> </dt>
<dd>
<p>A dictionary that will be jsonify’d before being returned.</p> </dd> <dt>
<code>tuple</code> </dt>
<dd>
<p>Either <code>(body, status, headers)</code>, <code>(body, status)</code>, or <code>(body, headers)</code>, where <code>body</code> is any of the other types allowed here, <code>status</code> is a string or an integer, and <code>headers</code> is a dictionary or a list of <code>(key, value)</code> tuples. If <code>body</code> is a <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><code>response_class</code></a> instance, <code>status</code> overwrites the exiting value and <code>headers</code> are extended.</p> </dd> <dt>
 <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><code>response_class</code></a>
</dt>
<dd>
<p>The object is returned unchanged.</p> </dd> <dt>
<code>other Response class</code> </dt>
<dd>
<p>The object is coerced to <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><code>response_class</code></a>.</p> </dd> <dt>
 <a class="reference external" href="https://docs.python.org/3/library/functions.html#callable" title="(in Python v3.9)"><code>callable()</code></a>
</dt>
<dd>
<p>The function is called as a WSGI application. The result is used to create a response object.</p> </dd> </dl> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>Previously a tuple was interpreted as the arguments for the response object.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.make_shell_context">
<code>make_shell_context()</code> </dt> <dd>
<p>Returns the shell context for an interactive shell for this application. This runs all the registered shell context processors.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.name">
<code>name</code> </dt> <dd>
<p>The name of the application. This is usually the import name with the difference that it’s guessed from the run file if the import name is main. This name is used as a display name when Flask needs the name of the application. It can be set and overridden to change the value.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.open_instance_resource">
<code>open_instance_resource(resource, mode='rb')</code> </dt> <dd>
<p>Opens a resource from the application’s instance folder (<a class="reference internal" href="#flask.Flask.instance_path" title="flask.Flask.instance_path"><code>instance_path</code></a>). Otherwise works like <a class="reference internal" href="#flask.Flask.open_resource" title="flask.Flask.open_resource"><code>open_resource()</code></a>. Instance resources can also be opened for writing.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>resource</strong> – the name of the resource. To access resources within subfolders use forward slashes as separator.</li> <li>
<strong>mode</strong> – resource file opening mode, default is ‘rb’.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.open_resource">
<code>open_resource(resource, mode='rb')</code> </dt> <dd>
<p>Opens a resource from the application’s resource folder. To see how this works, consider the following folder structure:</p> <pre data-language="python">/myapplication.py
/schema.sql
/static
    /style.css
/templates
    /layout.html
    /index.html
</pre> <p>If you want to open the <code>schema.sql</code> file you would do the following:</p> <pre data-language="python">with app.open_resource('schema.sql') as f:
    contents = f.read()
    do_something_with(contents)
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>resource</strong> – the name of the resource. To access resources within subfolders use forward slashes as separator.</li> <li>
<strong>mode</strong> – Open file in this mode. Only reading is supported, valid values are “r” (or “rt”) and “rb”.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.open_session">
<code>open_session(request)</code> </dt> <dd>
<p>Creates or opens a new session. Default implementation stores all session data in a signed cookie. This requires that the <a class="reference internal" href="#flask.Flask.secret_key" title="flask.Flask.secret_key"><code>secret_key</code></a> is set. Instead of overriding this method we recommend replacing the <a class="reference internal" href="#flask.Flask.session_interface" title="flask.Flask.session_interface"><code>session_interface</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>request</strong> – an instance of <a class="reference internal" href="#flask.Flask.request_class" title="flask.Flask.request_class"><code>request_class</code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.permanent_session_lifetime">
<code>permanent_session_lifetime</code> </dt> <dd>
<p>A <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.9)"><code>timedelta</code></a> which is used to set the expiration date of a permanent session. The default is 31 days which makes a permanent session survive for roughly one month.</p> <p>This attribute can also be configured from the config with the <code>PERMANENT_SESSION_LIFETIME</code> configuration key. Defaults to <code>timedelta(days=31)</code></p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.preprocess_request">
<code>preprocess_request()</code> </dt> <dd>
<p>Called before the request is dispatched. Calls <a class="reference internal" href="#flask.Flask.url_value_preprocessors" title="flask.Flask.url_value_preprocessors"><code>url_value_preprocessors</code></a> registered with the app and the current blueprint (if any). Then calls <a class="reference internal" href="#flask.Flask.before_request_funcs" title="flask.Flask.before_request_funcs"><code>before_request_funcs</code></a> registered with the app and the blueprint.</p> <p>If any <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><code>before_request()</code></a> handler returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.preserve_context_on_exception">
<code>property preserve_context_on_exception</code> </dt> <dd>
<p>Returns the value of the <code>PRESERVE_CONTEXT_ON_EXCEPTION</code> configuration value in case it’s set, otherwise a sensible default is returned.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.process_response">
<code>process_response(response)</code> </dt> <dd>
<p>Can be overridden in order to modify the response object before it’s sent to the WSGI server. By default this will call all the <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><code>after_request()</code></a> decorated functions.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>As of Flask 0.5 the functions registered for after request execution are called in reverse order of registration.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>response</strong> – a <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><code>response_class</code></a> object.</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a new response object or the same, has to be an instance of <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><code>response_class</code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.propagate_exceptions">
<code>property propagate_exceptions</code> </dt> <dd>
<p>Returns the value of the <code>PROPAGATE_EXCEPTIONS</code> configuration value in case it’s set, otherwise a sensible default is returned.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.register_blueprint">
<code>register_blueprint(blueprint, **options)</code> </dt> <dd>
<p>Register a <a class="reference internal" href="#flask.Blueprint" title="flask.Blueprint"><code>Blueprint</code></a> on the application. Keyword arguments passed to this method will override the defaults set on the blueprint.</p> <p>Calls the blueprint’s <a class="reference internal" href="#flask.Blueprint.register" title="flask.Blueprint.register"><code>register()</code></a> method after recording the blueprint in the application’s <a class="reference internal" href="#flask.Flask.blueprints" title="flask.Flask.blueprints"><code>blueprints</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>blueprint</strong> – The blueprint to register.</li> <li>
<strong>url_prefix</strong> – Blueprint routes will be prefixed with this.</li> <li>
<strong>subdomain</strong> – Blueprint routes will match on this subdomain.</li> <li>
<strong>url_defaults</strong> – Blueprint routes will use these default values for view arguments.</li> <li>
<strong>options</strong> – Additional keyword arguments are passed to <a class="reference internal" href="#flask.blueprints.BlueprintSetupState" title="flask.blueprints.BlueprintSetupState"><code>BlueprintSetupState</code></a>. They can be accessed in <a class="reference internal" href="#flask.Blueprint.record" title="flask.Blueprint.record"><code>record()</code></a> callbacks.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.register_error_handler">
<code>register_error_handler(code_or_exception, f)</code> </dt> <dd>
<p>Alternative error attach function to the <a class="reference internal" href="#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><code>errorhandler()</code></a> decorator that is more straightforward to use for non decorator usage.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.request_class">
<code>request_class</code> </dt> <dd>
<p>alias of <code>flask.wrappers.Request</code></p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.request_context">
<code>request_context(environ)</code> </dt> <dd>
<p>Create a <a class="reference internal" href="#flask.ctx.RequestContext" title="flask.ctx.RequestContext"><code>RequestContext</code></a> representing a WSGI environment. Use a <code>with</code> block to push the context, which will make <a class="reference internal" href="#flask.request" title="flask.request"><code>request</code></a> point at this request.</p> <p>See <a class="reference internal" href="../reqcontext/index"><span class="doc">The Request Context</span></a>.</p> <p>Typically you should not call this from your own code. A request context is automatically pushed by the <a class="reference internal" href="#flask.Flask.wsgi_app" title="flask.Flask.wsgi_app"><code>wsgi_app()</code></a> when handling a request. Use <a class="reference internal" href="#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code>test_request_context()</code></a> to create an environment and context instead of this method.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>environ</strong> – a WSGI environment</p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.response_class">
<code>response_class</code> </dt> <dd>
<p>alias of <code>flask.wrappers.Response</code></p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.root_path">
<code>root_path = None</code> </dt> <dd>
<p>Absolute path to the package on the filesystem. Used to look up resources contained in the package.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.route">
<code>route(rule, **options)</code> </dt> <dd>
<p>A decorator that is used to register a view function for a given URL rule. This does the same thing as <a class="reference internal" href="#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><code>add_url_rule()</code></a> but is intended for decorator usage:</p> <pre data-language="python">@app.route('/')
def index():
    return 'Hello World'
</pre> <p>For more information refer to <a class="reference internal" href="#url-route-registrations"><span class="std std-ref">URL Route Registrations</span></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>rule</strong> – the URL rule as string</li> <li>
<strong>endpoint</strong> – the endpoint for the registered URL rule. Flask itself assumes the name of the view function as endpoint</li> <li>
<strong>options</strong> – the options to be forwarded to the underlying <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule" title="(in Werkzeug v1.0.x)"><code>Rule</code></a> object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to (<code>GET</code>, <code>POST</code> etc.). By default a rule just listens for <code>GET</code> (and implicitly <code>HEAD</code>). Starting with Flask 0.6, <code>OPTIONS</code> is implicitly added and handled by the standard request handling.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.run">
<code>run(host=None, port=None, debug=None, load_dotenv=True, **options)</code> </dt> <dd>
<p>Runs the application on a local development server.</p> <p>Do not use <code>run()</code> in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see <a class="reference internal" href="../deploying/index#deployment"><span class="std std-ref">Deployment Options</span></a> for WSGI server recommendations.</p> <p>If the <a class="reference internal" href="#flask.Flask.debug" title="flask.Flask.debug"><code>debug</code></a> flag is set the server will automatically reload for code changes and show a debugger in case an exception happened.</p> <p>If you want to run the application in debug mode, but disable the code execution on the interactive debugger, you can pass <code>use_evalex=False</code> as parameter. This will keep the debugger’s traceback screen active, but disable code execution.</p> <p>It is not recommended to use this function for development with automatic reloading as this is badly supported. Instead you should be using the <strong class="command">flask</strong> command line script’s <code>run</code> support.</p> <div class="admonition-keep-in-mind admonition"> <p class="admonition-title">Keep in Mind</p> <p>Flask will suppress any server error with a generic error page unless it is in debug mode. As such to enable just the interactive debugger without the code reloading, you have to invoke <a class="reference internal" href="#flask.Flask.run" title="flask.Flask.run"><code>run()</code></a> with <code>debug=True</code> and <code>use_reloader=False</code>. Setting <code>use_debugger</code> to <code>True</code> without being in debug mode won’t catch any exceptions because there won’t be any to catch.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>host</strong> – the hostname to listen on. Set this to <code>'0.0.0.0'</code> to have the server available externally as well. Defaults to <code>'127.0.0.1'</code> or the host in the <code>SERVER_NAME</code> config variable if present.</li> <li>
<strong>port</strong> – the port of the webserver. Defaults to <code>5000</code> or the port defined in the <code>SERVER_NAME</code> config variable if present.</li> <li>
<strong>debug</strong> – if given, enable or disable debug mode. See <a class="reference internal" href="#flask.Flask.debug" title="flask.Flask.debug"><code>debug</code></a>.</li> <li>
<strong>load_dotenv</strong> – Load the nearest <code>.env</code> and <code>.flaskenv</code> files to set environment variables. Will also change the working directory to the directory containing the first file found.</li> <li>
<strong>options</strong> – the options to be forwarded to the underlying Werkzeug server. See <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/serving/#werkzeug.serving.run_simple" title="(in Werkzeug v1.0.x)"><code>werkzeug.serving.run_simple()</code></a> for more information.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>If installed, python-dotenv will be used to load environment variables from <code>.env</code> and <code>.flaskenv</code> files.</p> <p>If set, the <code id="index-1">FLASK_ENV</code> and <code id="index-2">FLASK_DEBUG</code> environment variables will override <a class="reference internal" href="#flask.Flask.env" title="flask.Flask.env"><code>env</code></a> and <a class="reference internal" href="#flask.Flask.debug" title="flask.Flask.debug"><code>debug</code></a>.</p> <p>Threaded mode is enabled by default.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.10: </span>The default port is now picked from the <code>SERVER_NAME</code> variable.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.save_session">
<code>save_session(session, response)</code> </dt> <dd>
<p>Saves the session if it needs updates. For the default implementation, check <a class="reference internal" href="#flask.Flask.open_session" title="flask.Flask.open_session"><code>open_session()</code></a>. Instead of overriding this method we recommend replacing the <a class="reference internal" href="#flask.Flask.session_interface" title="flask.Flask.session_interface"><code>session_interface</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>session</strong> – the session to be saved (a <code>SecureCookie</code> object)</li> <li>
<strong>response</strong> – an instance of <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><code>response_class</code></a>
</li> </ul> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.secret_key">
<code>secret_key</code> </dt> <dd>
<p>If a secret key is set, cryptographic components can use this to sign cookies and other things. Set this to a complex random value when you want to use the secure cookie for instance.</p> <p>This attribute can also be configured from the config with the <a class="reference internal" href="../config/index#SECRET_KEY" title="SECRET_KEY"><code>SECRET_KEY</code></a> configuration key. Defaults to <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.select_jinja_autoescape">
<code>select_jinja_autoescape(filename)</code> </dt> <dd>
<p>Returns <code>True</code> if autoescaping should be active for the given template name. If no template name is given, returns <code>True</code>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.send_file_max_age_default">
<code>send_file_max_age_default</code> </dt> <dd>
<p>A <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.9)"><code>timedelta</code></a> which is used as default cache_timeout for the <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a> functions. The default is 12 hours.</p> <p>This attribute can also be configured from the config with the <code>SEND_FILE_MAX_AGE_DEFAULT</code> configuration key. This configuration variable can also be set with an integer value used as seconds. Defaults to <code>timedelta(hours=12)</code></p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.send_static_file">
<code>send_static_file(filename)</code> </dt> <dd>
<p>Function used internally to send static files from the static folder to the browser.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.session_cookie_name">
<code>session_cookie_name</code> </dt> <dd>
<p>The secure cookie uses this for the name of the session cookie.</p> <p>This attribute can also be configured from the config with the <code>SESSION_COOKIE_NAME</code> configuration key. Defaults to <code>'session'</code></p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.session_interface">
<code>session_interface = &lt;flask.sessions.SecureCookieSessionInterface object&gt;</code> </dt> <dd>
<p>the session interface to use. By default an instance of <a class="reference internal" href="#flask.sessions.SecureCookieSessionInterface" title="flask.sessions.SecureCookieSessionInterface"><code>SecureCookieSessionInterface</code></a> is used here.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.shell_context_processor">
<code>shell_context_processor(f)</code> </dt> <dd>
<p>Registers a shell context processor function.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.shell_context_processors">
<code>shell_context_processors = None</code> </dt> <dd>
<p>A list of shell context processor functions that should be run when a shell context is created.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.should_ignore_error">
<code>should_ignore_error(error)</code> </dt> <dd>
<p>This is called to figure out if an error should be ignored or not as far as the teardown system is concerned. If this function returns <code>True</code> then the teardown handlers will not be passed the error.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.static_folder">
<code>property static_folder</code> </dt> <dd>
<p>The absolute path to the configured static folder.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.static_url_path">
<code>property static_url_path</code> </dt> <dd>
<p>The URL prefix that the static route will be accessible from.</p> <p>If it was not configured during init, it is derived from <a class="reference internal" href="#flask.Flask.static_folder" title="flask.Flask.static_folder"><code>static_folder</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.teardown_appcontext">
<code>teardown_appcontext(f)</code> </dt> <dd>
<p>Registers a function to be called when the application context ends. These functions are typically also called when the request context is popped.</p> <p>Example:</p> <pre data-language="python">ctx = app.app_context()
ctx.push()
...
ctx.pop()
</pre> <p>When <code>ctx.pop()</code> is executed in the above example, the teardown functions are called just before the app context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.</p> <p>Since a request context typically also manages an application context it would also be called when you pop a request context.</p> <p>When a teardown function was called because of an unhandled exception it will be passed an error object. If an <a class="reference internal" href="#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><code>errorhandler()</code></a> is registered, it will handle the exception and the teardown will not receive it.</p> <p>The return values of teardown functions are ignored.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.teardown_appcontext_funcs">
<code>teardown_appcontext_funcs = None</code> </dt> <dd>
<p>A list of functions that are called when the application context is destroyed. Since the application context is also torn down if the request ends this is the place to store code that disconnects from databases.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.teardown_request">
<code>teardown_request(f)</code> </dt> <dd>
<p>Register a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed.</p> <p>Example:</p> <pre data-language="python">ctx = app.test_request_context()
ctx.push()
...
ctx.pop()
</pre> <p>When <code>ctx.pop()</code> is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.</p> <p>Generally teardown functions must take every necessary step to avoid that they will fail. If they do execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors.</p> <p>When a teardown function was called because of an exception it will be passed an error object.</p> <p>The return values of teardown functions are ignored.</p> <div class="admonition-debug-note admonition"> <p class="admonition-title">Debug Note</p> <p>In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the <code>PRESERVE_CONTEXT_ON_EXCEPTION</code> configuration variable.</p> </div> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.teardown_request_funcs">
<code>teardown_request_funcs = None</code> </dt> <dd>
<p>A dictionary with lists of functions that are called after each request, even if an exception has occurred. The key of the dictionary is the name of the blueprint this function is active for, <code>None</code> for all requests. These functions are not allowed to modify the request, and their return values are ignored. If an exception occurred while processing the request, it gets passed to each teardown_request function. To register a function here, use the <a class="reference internal" href="#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><code>teardown_request()</code></a> decorator.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.template_context_processors">
<code>template_context_processors = None</code> </dt> <dd>
<p>A dictionary with list of functions that are called without argument to populate the template context. The key of the dictionary is the name of the blueprint this function is active for, <code>None</code> for all requests. Each returns a dictionary that the template context is updated with. To register a function here, use the <a class="reference internal" href="#flask.Flask.context_processor" title="flask.Flask.context_processor"><code>context_processor()</code></a> decorator.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.template_filter">
<code>template_filter(name=None)</code> </dt> <dd>
<p>A decorator that is used to register custom template filter. You can specify a name for the filter, otherwise the function name will be used. Example:</p> <pre data-language="python">@app.template_filter()
def reverse(s):
    return s[::-1]
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the filter, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.template_folder">
<code>template_folder = None</code> </dt> <dd>
<p>Location of the template files to be added to the template lookup. <code>None</code> if templates should not be added.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.template_global">
<code>template_global(name=None)</code> </dt> <dd>
<p>A decorator that is used to register a custom template global function. You can specify a name for the global function, otherwise the function name will be used. Example:</p> <pre data-language="python">@app.template_global()
def double(n):
    return 2 * n
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the global function, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.template_test">
<code>template_test(name=None)</code> </dt> <dd>
<p>A decorator that is used to register custom template test. You can specify a name for the test, otherwise the function name will be used. Example:</p> <pre data-language="python">@app.template_test()
def is_prime(n):
    if n == 2:
        return True
    for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
        if n % i == 0:
            return False
    return True
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the test, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.templates_auto_reload">
<code>property templates_auto_reload</code> </dt> <dd>
<p>Reload templates when they are changed. Used by <a class="reference internal" href="#flask.Flask.create_jinja_environment" title="flask.Flask.create_jinja_environment"><code>create_jinja_environment()</code></a>.</p> <p>This attribute can be configured with <a class="reference internal" href="../config/index#TEMPLATES_AUTO_RELOAD" title="TEMPLATES_AUTO_RELOAD"><code>TEMPLATES_AUTO_RELOAD</code></a>. If not set, it will be enabled in debug mode.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 1.0: </span>This property was added but the underlying config and behavior already existed.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.test_cli_runner">
<code>test_cli_runner(**kwargs)</code> </dt> <dd>
<p>Create a CLI runner for testing CLI commands. See <a class="reference internal" href="../testing/index#testing-cli"><span class="std std-ref">Testing CLI Commands</span></a>.</p> <p>Returns an instance of <a class="reference internal" href="#flask.Flask.test_cli_runner_class" title="flask.Flask.test_cli_runner_class"><code>test_cli_runner_class</code></a>, by default <a class="reference internal" href="#flask.testing.FlaskCliRunner" title="flask.testing.FlaskCliRunner"><code>FlaskCliRunner</code></a>. The Flask app object is passed as the first argument.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.test_cli_runner_class">
<code>test_cli_runner_class = None</code> </dt> <dd>
<p>The <a class="reference external" href="https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner" title="(in Click v7.x)"><code>CliRunner</code></a> subclass, by default <a class="reference internal" href="#flask.testing.FlaskCliRunner" title="flask.testing.FlaskCliRunner"><code>FlaskCliRunner</code></a> that is used by <a class="reference internal" href="#flask.Flask.test_cli_runner" title="flask.Flask.test_cli_runner"><code>test_cli_runner()</code></a>. Its <code>__init__</code> method should take a Flask app object as the first argument.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.test_client">
<code>test_client(use_cookies=True, **kwargs)</code> </dt> <dd>
<p>Creates a test client for this application. For information about unit testing head over to <a class="reference internal" href="../testing/index#testing"><span class="std std-ref">Testing Flask Applications</span></a>.</p> <p>Note that if you are testing for assertions or exceptions in your application code, you must set <code>app.testing = True</code> in order for the exceptions to propagate to the test client. Otherwise, the exception will be handled by the application (not visible to the test client) and the only indication of an AssertionError or other exception will be a 500 status code response to the test client. See the <a class="reference internal" href="#flask.Flask.testing" title="flask.Flask.testing"><code>testing</code></a> attribute. For example:</p> <pre data-language="python">app.testing = True
client = app.test_client()
</pre> <p>The test client can be used in a <code>with</code> block to defer the closing down of the context until the end of the <code>with</code> block. This is useful if you want to access the context locals for testing:</p> <pre data-language="python">with app.test_client() as c:
    rv = c.get('/?vodka=42')
    assert request.args['vodka'] == '42'
</pre> <p>Additionally, you may pass optional keyword arguments that will then be passed to the application’s <a class="reference internal" href="#flask.Flask.test_client_class" title="flask.Flask.test_client_class"><code>test_client_class</code></a> constructor. For example:</p> <pre data-language="python">from flask.testing import FlaskClient

class CustomClient(FlaskClient):
    def __init__(self, *args, **kwargs):
        self._authentication = kwargs.pop("authentication")
        super(CustomClient,self).__init__( *args, **kwargs)

app.test_client_class = CustomClient
client = app.test_client(authentication='Basic ....')
</pre> <p>See <a class="reference internal" href="#flask.testing.FlaskClient" title="flask.testing.FlaskClient"><code>FlaskClient</code></a> for more information.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.11: </span>Added <code>**kwargs</code> to support passing additional keyword arguments to the constructor of <a class="reference internal" href="#flask.Flask.test_client_class" title="flask.Flask.test_client_class"><code>test_client_class</code></a>.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.7: </span>The <code>use_cookies</code> parameter was added as well as the ability to override the client to be used by setting the <a class="reference internal" href="#flask.Flask.test_client_class" title="flask.Flask.test_client_class"><code>test_client_class</code></a> attribute.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.4: </span>added support for <code>with</code> block usage for the client.</p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.test_client_class">
<code>test_client_class = None</code> </dt> <dd>
<p>the test client that is used with when <code>test_client</code> is used.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.test_request_context">
<code>test_request_context(*args, **kwargs)</code> </dt> <dd>
<p>Create a <a class="reference internal" href="#flask.ctx.RequestContext" title="flask.ctx.RequestContext"><code>RequestContext</code></a> for a WSGI environment created from the given values. This is mostly useful during testing, where you may want to run a function that uses request data without dispatching a full request.</p> <p>See <a class="reference internal" href="../reqcontext/index"><span class="doc">The Request Context</span></a>.</p> <p>Use a <code>with</code> block to push the context, which will make <a class="reference internal" href="#flask.request" title="flask.request"><code>request</code></a> point at the request for the created environment.</p> <pre data-language="python">with test_request_context(...):
    generate_report()
</pre> <p>When using the shell, it may be easier to push and pop the context manually to avoid indentation.</p> <pre data-language="python">ctx = app.test_request_context(...)
ctx.push()
...
ctx.pop()
</pre> <p>Takes the same arguments as Werkzeug’s <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder" title="(in Werkzeug v1.0.x)"><code>EnvironBuilder</code></a>, with some defaults from the application. See the linked Werkzeug docs for most of the available arguments. Flask-specific behavior is listed here.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>path</strong> – URL path being requested.</li> <li>
<strong>base_url</strong> – Base URL where the app is being served, which <code>path</code> is relative to. If not given, built from <a class="reference internal" href="../config/index#PREFERRED_URL_SCHEME" title="PREFERRED_URL_SCHEME"><code>PREFERRED_URL_SCHEME</code></a>, <code>subdomain</code>, <a class="reference internal" href="../config/index#SERVER_NAME" title="SERVER_NAME"><code>SERVER_NAME</code></a>, and <a class="reference internal" href="../config/index#APPLICATION_ROOT" title="APPLICATION_ROOT"><code>APPLICATION_ROOT</code></a>.</li> <li>
<strong>subdomain</strong> – Subdomain name to append to <a class="reference internal" href="../config/index#SERVER_NAME" title="SERVER_NAME"><code>SERVER_NAME</code></a>.</li> <li>
<strong>url_scheme</strong> – Scheme to use instead of <a class="reference internal" href="../config/index#PREFERRED_URL_SCHEME" title="PREFERRED_URL_SCHEME"><code>PREFERRED_URL_SCHEME</code></a>.</li> <li>
<strong>data</strong> – The request body, either as a string or a dict of form keys and values.</li> <li>
<strong>json</strong> – If given, this is serialized as JSON and passed as <code>data</code>. Also defaults <code>content_type</code> to <code>application/json</code>.</li> <li>
<strong>args</strong> – other positional arguments passed to <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder" title="(in Werkzeug v1.0.x)"><code>EnvironBuilder</code></a>.</li> <li>
<strong>kwargs</strong> – other keyword arguments passed to <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder" title="(in Werkzeug v1.0.x)"><code>EnvironBuilder</code></a>.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.testing">
<code>testing</code> </dt> <dd>
<p>The testing flag. Set this to <code>True</code> to enable the test mode of Flask extensions (and in the future probably also Flask itself). For example this might activate test helpers that have an additional runtime cost which should not be enabled by default.</p> <p>If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the default it’s implicitly enabled.</p> <p>This attribute can also be configured from the config with the <code>TESTING</code> configuration key. Defaults to <code>False</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.trap_http_exception">
<code>trap_http_exception(e)</code> </dt> <dd>
<p>Checks if an HTTP exception should be trapped or not. By default this will return <code>False</code> for all exceptions except for a bad request key error if <code>TRAP_BAD_REQUEST_ERRORS</code> is set to <code>True</code>. It also returns <code>True</code> if <code>TRAP_HTTP_EXCEPTIONS</code> is set to <code>True</code>.</p> <p>This is called for all HTTP exceptions raised by a view function. If it returns <code>True</code> for any exception the error handler for this exception is not called and it shows up as regular exception in the traceback. This is helpful for debugging implicitly raised HTTP exceptions.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>Bad request errors are not trapped by default in debug mode.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.update_template_context">
<code>update_template_context(context)</code> </dt> <dd>
<p>Update the template context with some commonly used variables. This injects request, session, config and g into the template context as well as everything template context processors want to inject. Note that the as of Flask 0.6, the original values in the context will not be overridden if a context processor decides to return a value with the same key.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>context</strong> – the context as a dictionary that is updated in place to add extra variables.</p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.url_build_error_handlers">
<code>url_build_error_handlers = None</code> </dt> <dd>
<p>A list of functions that are called when <a class="reference internal" href="#flask.url_for" title="flask.url_for"><code>url_for()</code></a> raises a <code>BuildError</code>. Each function registered here is called with <code>error</code>, <code>endpoint</code> and <code>values</code>. If a function returns <code>None</code> or raises a <code>BuildError</code> the next function is tried.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.url_default_functions">
<code>url_default_functions = None</code> </dt> <dd>
<p>A dictionary with lists of functions that can be used as URL value preprocessors. The key <code>None</code> here is used for application wide callbacks, otherwise the key is the name of the blueprint. Each of these functions has the chance to modify the dictionary of URL values before they are used as the keyword arguments of the view function. For each function registered this one should also provide a <a class="reference internal" href="#flask.Flask.url_defaults" title="flask.Flask.url_defaults"><code>url_defaults()</code></a> function that adds the parameters automatically again that were removed that way.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Flask.url_defaults">
<code>url_defaults(f)</code> </dt> <dd>
<p>Callback function for URL defaults for all view functions of the application. It’s called with the endpoint and values and should update the values passed in place.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.url_map">
<code>url_map = None</code> </dt> <dd>
<p>The <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Map" title="(in Werkzeug v1.0.x)"><code>Map</code></a> for this instance. You can use this to change the routing converters after the class was created but before any routes are connected. Example:</p> <pre data-language="python">from werkzeug.routing import BaseConverter

class ListConverter(BaseConverter):
    def to_python(self, value):
        return value.split(',')
    def to_url(self, values):
        return ','.join(super(ListConverter, self).to_url(value)
                        for value in values)

app = Flask(__name__)
app.url_map.converters['list'] = ListConverter
</pre> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.url_map_class">
<code>url_map_class</code> </dt> <dd>
<p>alias of <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Map" title="(in Werkzeug v1.0.x)"><code>werkzeug.routing.Map</code></a></p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.url_rule_class">
<code>url_rule_class</code> </dt> <dd>
<p>alias of <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule" title="(in Werkzeug v1.0.x)"><code>werkzeug.routing.Rule</code></a></p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.url_value_preprocessor">
<code>url_value_preprocessor(f)</code> </dt> <dd>
<p>Register a URL value preprocessor function for all view functions in the application. These functions will be called before the <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><code>before_request()</code></a> functions.</p> <p>The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in <code>g</code> rather than pass it to every view.</p> <p>The function is passed the endpoint name and values dict. The return value is ignored.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.url_value_preprocessors">
<code>url_value_preprocessors = None</code> </dt> <dd>
<p>A dictionary with lists of functions that are called before the <a class="reference internal" href="#flask.Flask.before_request_funcs" title="flask.Flask.before_request_funcs"><code>before_request_funcs</code></a> functions. The key of the dictionary is the name of the blueprint this function is active for, or <code>None</code> for all requests. To register a function, use <a class="reference internal" href="#flask.Flask.url_value_preprocessor" title="flask.Flask.url_value_preprocessor"><code>url_value_preprocessor()</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.use_x_sendfile">
<code>use_x_sendfile</code> </dt> <dd>
<p>Enable this if you want to use the X-Sendfile feature. Keep in mind that the server has to support this. This only affects files sent with the <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a> method.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.2.</span></p> </div> </details><p>This attribute can also be configured from the config with the <code>USE_X_SENDFILE</code> configuration key. Defaults to <code>False</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Flask.view_functions">
<code>view_functions = None</code> </dt> <dd>
<p>A dictionary of all view functions registered. The keys will be function names which are also used to generate URLs and the values are the function objects themselves. To register a view function, use the <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><code>route()</code></a> decorator.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Flask.wsgi_app">
<code>wsgi_app(environ, start_response)</code> </dt> <dd>
<p>The actual WSGI application. This is not implemented in <code>__call__()</code> so that middlewares can be applied without losing a reference to the app object. Instead of doing this:</p> <pre data-language="python">app = MyMiddleware(app)
</pre> <p>It’s a better idea to do this instead:</p> <pre data-language="python">app.wsgi_app = MyMiddleware(app.wsgi_app)
</pre> <p>Then you still have the original application object around and can continue to call methods on it.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.7: </span>Teardown events for the request and app contexts are called even if an unhandled error occurs. Other events may not be called depending on when an error occurs during dispatch. See <a class="reference internal" href="../reqcontext/index#callbacks-and-errors"><span class="std std-ref">Callbacks and Errors</span></a>.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>environ</strong> – A WSGI environment.</li> <li>
<strong>start_response</strong> – A callable accepting a status code, a list of headers, and an optional exception context to start the response.</li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="blueprint-objects">Blueprint Objects</h2> <dl class="class"> <dt id="flask.Blueprint">
<code>class flask.Blueprint(name, import_name, static_folder=None, static_url_path=None, template_folder=None, url_prefix=None, subdomain=None, url_defaults=None, root_path=None, cli_group=&lt;object object&gt;)</code> </dt> <dd>
<p>Represents a blueprint, a collection of routes and other app-related functions that can be registered on a real application later.</p> <p>A blueprint is an object that allows defining application functions without requiring an application object ahead of time. It uses the same decorators as <a class="reference internal" href="#flask.Flask" title="flask.Flask"><code>Flask</code></a>, but defers the need for an application by recording them for later registration.</p> <p>Decorating a function with a blueprint creates a deferred function that is called with <a class="reference internal" href="#flask.blueprints.BlueprintSetupState" title="flask.blueprints.BlueprintSetupState"><code>BlueprintSetupState</code></a> when the blueprint is registered on an application.</p> <p>See <a class="reference internal" href="../blueprints/index#blueprints"><span class="std std-ref">Modular Applications with Blueprints</span></a> for more information.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.1.0: </span>Blueprints have a <code>cli</code> group to register nested CLI commands. The <code>cli_group</code> parameter controls the name of the group under the <code>flask</code> command.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>name</strong> – The name of the blueprint. Will be prepended to each endpoint name.</li> <li>
<strong>import_name</strong> – The name of the blueprint package, usually <code>__name__</code>. This helps locate the <code>root_path</code> for the blueprint.</li> <li>
<strong>static_folder</strong> – A folder with static files that should be served by the blueprint’s static route. The path is relative to the blueprint’s root path. Blueprint static files are disabled by default.</li> <li>
<strong>static_url_path</strong> – The url to serve static files from. Defaults to <code>static_folder</code>. If the blueprint does not have a <code>url_prefix</code>, the app’s static route will take precedence, and the blueprint’s static files won’t be accessible.</li> <li>
<strong>template_folder</strong> – A folder with templates that should be added to the app’s template search path. The path is relative to the blueprint’s root path. Blueprint templates are disabled by default. Blueprint templates have a lower precedence than those in the app’s templates folder.</li> <li>
<strong>url_prefix</strong> – A path to prepend to all of the blueprint’s URLs, to make them distinct from the rest of the app’s routes.</li> <li>
<strong>subdomain</strong> – A subdomain that blueprint routes will match on by default.</li> <li>
<strong>url_defaults</strong> – A dict of default values that blueprint routes will receive by default.</li> <li>
<strong>root_path</strong> – By default, the blueprint will automatically this based on <code>import_name</code>. In certain situations this automatic detection can fail, so the path can be specified manually instead.</li> </ul> </dd> </dl> <dl class="method"> <dt id="flask.Blueprint.add_app_template_filter">
<code>add_app_template_filter(f, name=None)</code> </dt> <dd>
<p>Register a custom template filter, available application wide. Like <a class="reference internal" href="#flask.Flask.add_template_filter" title="flask.Flask.add_template_filter"><code>Flask.add_template_filter()</code></a> but for a blueprint. Works exactly like the <a class="reference internal" href="#flask.Blueprint.app_template_filter" title="flask.Blueprint.app_template_filter"><code>app_template_filter()</code></a> decorator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the filter, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.add_app_template_global">
<code>add_app_template_global(f, name=None)</code> </dt> <dd>
<p>Register a custom template global, available application wide. Like <a class="reference internal" href="#flask.Flask.add_template_global" title="flask.Flask.add_template_global"><code>Flask.add_template_global()</code></a> but for a blueprint. Works exactly like the <a class="reference internal" href="#flask.Blueprint.app_template_global" title="flask.Blueprint.app_template_global"><code>app_template_global()</code></a> decorator.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the global, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.add_app_template_test">
<code>add_app_template_test(f, name=None)</code> </dt> <dd>
<p>Register a custom template test, available application wide. Like <a class="reference internal" href="#flask.Flask.add_template_test" title="flask.Flask.add_template_test"><code>Flask.add_template_test()</code></a> but for a blueprint. Works exactly like the <a class="reference internal" href="#flask.Blueprint.app_template_test" title="flask.Blueprint.app_template_test"><code>app_template_test()</code></a> decorator.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the test, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.add_url_rule">
<code>add_url_rule(rule, endpoint=None, view_func=None, **options)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><code>Flask.add_url_rule()</code></a> but for a blueprint. The endpoint for the <a class="reference internal" href="#flask.url_for" title="flask.url_for"><code>url_for()</code></a> function is prefixed with the name of the blueprint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.after_app_request">
<code>after_app_request(f)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><code>Flask.after_request()</code></a> but for a blueprint. Such a function is executed after each request, even if outside of the blueprint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.after_request">
<code>after_request(f)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><code>Flask.after_request()</code></a> but for a blueprint. This function is only executed after each request that is handled by a function of that blueprint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.app_context_processor">
<code>app_context_processor(f)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.context_processor" title="flask.Flask.context_processor"><code>Flask.context_processor()</code></a> but for a blueprint. Such a function is executed each request, even if outside of the blueprint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.app_errorhandler">
<code>app_errorhandler(code)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><code>Flask.errorhandler()</code></a> but for a blueprint. This handler is used for all requests, even if outside of the blueprint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.app_template_filter">
<code>app_template_filter(name=None)</code> </dt> <dd>
<p>Register a custom template filter, available application wide. Like <a class="reference internal" href="#flask.Flask.template_filter" title="flask.Flask.template_filter"><code>Flask.template_filter()</code></a> but for a blueprint.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the filter, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.app_template_global">
<code>app_template_global(name=None)</code> </dt> <dd>
<p>Register a custom template global, available application wide. Like <a class="reference internal" href="#flask.Flask.template_global" title="flask.Flask.template_global"><code>Flask.template_global()</code></a> but for a blueprint.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the global, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.app_template_test">
<code>app_template_test(name=None)</code> </dt> <dd>
<p>Register a custom template test, available application wide. Like <a class="reference internal" href="#flask.Flask.template_test" title="flask.Flask.template_test"><code>Flask.template_test()</code></a> but for a blueprint.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – the optional name of the test, otherwise the function name will be used.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.app_url_defaults">
<code>app_url_defaults(f)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#flask.Blueprint.url_defaults" title="flask.Blueprint.url_defaults"><code>url_defaults()</code></a> but application wide.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.app_url_value_preprocessor">
<code>app_url_value_preprocessor(f)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#flask.Blueprint.url_value_preprocessor" title="flask.Blueprint.url_value_preprocessor"><code>url_value_preprocessor()</code></a> but application wide.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.before_app_first_request">
<code>before_app_first_request(f)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.before_first_request" title="flask.Flask.before_first_request"><code>Flask.before_first_request()</code></a>. Such a function is executed before the first request to the application.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.before_app_request">
<code>before_app_request(f)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><code>Flask.before_request()</code></a>. Such a function is executed before each request, even if outside of a blueprint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.before_request">
<code>before_request(f)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><code>Flask.before_request()</code></a> but for a blueprint. This function is only executed before each request that is handled by a function of that blueprint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.context_processor">
<code>context_processor(f)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.context_processor" title="flask.Flask.context_processor"><code>Flask.context_processor()</code></a> but for a blueprint. This function is only executed for requests handled by a blueprint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.endpoint">
<code>endpoint(endpoint)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.endpoint" title="flask.Flask.endpoint"><code>Flask.endpoint()</code></a> but for a blueprint. This does not prefix the endpoint with the blueprint name, this has to be done explicitly by the user of this method. If the endpoint is prefixed with a <code>.</code> it will be registered to the current blueprint, otherwise it’s an application independent endpoint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.errorhandler">
<code>errorhandler(code_or_exception)</code> </dt> <dd>
<p>Registers an error handler that becomes active for this blueprint only. Please be aware that routing does not happen local to a blueprint so an error handler for 404 usually is not handled by a blueprint unless it is caused inside a view function. Another special case is the 500 internal server error which is always looked up from the application.</p> <p>Otherwise works as the <a class="reference internal" href="#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><code>errorhandler()</code></a> decorator of the <a class="reference internal" href="#flask.Flask" title="flask.Flask"><code>Flask</code></a> object.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.get_send_file_max_age">
<code>get_send_file_max_age(filename)</code> </dt> <dd>
<p>Provides default cache_timeout for the <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a> functions.</p> <p>By default, this function returns <code>SEND_FILE_MAX_AGE_DEFAULT</code> from the configuration of <a class="reference internal" href="#flask.current_app" title="flask.current_app"><code>current_app</code></a>.</p> <p>Static file functions such as <a class="reference internal" href="#flask.send_from_directory" title="flask.send_from_directory"><code>send_from_directory()</code></a> use this function, and <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a> calls this function on <a class="reference internal" href="#flask.current_app" title="flask.current_app"><code>current_app</code></a> when the given cache_timeout is <code>None</code>. If a cache_timeout is given in <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a>, that timeout is used; otherwise, this method is called.</p> <p>This allows subclasses to change the behavior when sending files based on the filename. For example, to set the cache timeout for .js files to 60 seconds:</p> <pre data-language="python">class MyFlask(flask.Flask):
    def get_send_file_max_age(self, name):
        if name.lower().endswith('.js'):
            return 60
        return flask.Flask.get_send_file_max_age(self, name)
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.has_static_folder">
<code>property has_static_folder</code> </dt> <dd>
<p>This is <code>True</code> if the package bound object’s container has a folder for static files.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Blueprint.import_name">
<code>import_name = None</code> </dt> <dd>
<p>The name of the package or module that this app belongs to. Do not change this once it is set by the constructor.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Blueprint.jinja_loader">
<code>jinja_loader</code> </dt> <dd>
<p>The Jinja loader for this package bound object.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Blueprint.json_decoder">
<code>json_decoder = None</code> </dt> <dd>
<p>Blueprint local JSON decoder class to use. Set to <code>None</code> to use the app’s <code>json_decoder</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Blueprint.json_encoder">
<code>json_encoder = None</code> </dt> <dd>
<p>Blueprint local JSON decoder class to use. Set to <code>None</code> to use the app’s <code>json_encoder</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.make_setup_state">
<code>make_setup_state(app, options, first_registration=False)</code> </dt> <dd>
<p>Creates an instance of <a class="reference internal" href="#flask.blueprints.BlueprintSetupState" title="flask.blueprints.BlueprintSetupState"><code>BlueprintSetupState()</code></a> object that is later passed to the register callback functions. Subclasses can override this to return a subclass of the setup state.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.open_resource">
<code>open_resource(resource, mode='rb')</code> </dt> <dd>
<p>Opens a resource from the application’s resource folder. To see how this works, consider the following folder structure:</p> <pre data-language="python">/myapplication.py
/schema.sql
/static
    /style.css
/templates
    /layout.html
    /index.html
</pre> <p>If you want to open the <code>schema.sql</code> file you would do the following:</p> <pre data-language="python">with app.open_resource('schema.sql') as f:
    contents = f.read()
    do_something_with(contents)
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>resource</strong> – the name of the resource. To access resources within subfolders use forward slashes as separator.</li> <li>
<strong>mode</strong> – Open file in this mode. Only reading is supported, valid values are “r” (or “rt”) and “rb”.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.record">
<code>record(func)</code> </dt> <dd>
<p>Registers a function that is called when the blueprint is registered on the application. This function is called with the state as argument as returned by the <a class="reference internal" href="#flask.Blueprint.make_setup_state" title="flask.Blueprint.make_setup_state"><code>make_setup_state()</code></a> method.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.record_once">
<code>record_once(func)</code> </dt> <dd>
<p>Works like <a class="reference internal" href="#flask.Blueprint.record" title="flask.Blueprint.record"><code>record()</code></a> but wraps the function in another function that will ensure the function is only called once. If the blueprint is registered a second time on the application, the function passed is not called.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.register">
<code>register(app, options, first_registration=False)</code> </dt> <dd>
<p>Called by <a class="reference internal" href="#flask.Flask.register_blueprint" title="flask.Flask.register_blueprint"><code>Flask.register_blueprint()</code></a> to register all views and callbacks registered on the blueprint with the application. Creates a <a class="reference internal" href="#flask.blueprints.BlueprintSetupState" title="flask.blueprints.BlueprintSetupState"><code>BlueprintSetupState</code></a> and calls each <a class="reference internal" href="#flask.Blueprint.record" title="flask.Blueprint.record"><code>record()</code></a> callback with it.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>app</strong> – The application this blueprint is being registered with.</li> <li>
<strong>options</strong> – Keyword arguments forwarded from <a class="reference internal" href="#flask.Flask.register_blueprint" title="flask.Flask.register_blueprint"><code>register_blueprint()</code></a>.</li> <li>
<strong>first_registration</strong> – Whether this is the first time this blueprint has been registered on the application.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.register_error_handler">
<code>register_error_handler(code_or_exception, f)</code> </dt> <dd>
<p>Non-decorator version of the <a class="reference internal" href="#flask.Blueprint.errorhandler" title="flask.Blueprint.errorhandler"><code>errorhandler()</code></a> error attach function, akin to the <a class="reference internal" href="#flask.Flask.register_error_handler" title="flask.Flask.register_error_handler"><code>register_error_handler()</code></a> application-wide function of the <a class="reference internal" href="#flask.Flask" title="flask.Flask"><code>Flask</code></a> object but for error handlers limited to this blueprint.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Blueprint.root_path">
<code>root_path = None</code> </dt> <dd>
<p>Absolute path to the package on the filesystem. Used to look up resources contained in the package.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.route">
<code>route(rule, **options)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><code>Flask.route()</code></a> but for a blueprint. The endpoint for the <a class="reference internal" href="#flask.url_for" title="flask.url_for"><code>url_for()</code></a> function is prefixed with the name of the blueprint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.send_static_file">
<code>send_static_file(filename)</code> </dt> <dd>
<p>Function used internally to send static files from the static folder to the browser.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.static_folder">
<code>property static_folder</code> </dt> <dd>
<p>The absolute path to the configured static folder.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.static_url_path">
<code>property static_url_path</code> </dt> <dd>
<p>The URL prefix that the static route will be accessible from.</p> <p>If it was not configured during init, it is derived from <a class="reference internal" href="#flask.Blueprint.static_folder" title="flask.Blueprint.static_folder"><code>static_folder</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.teardown_app_request">
<code>teardown_app_request(f)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><code>Flask.teardown_request()</code></a> but for a blueprint. Such a function is executed when tearing down each request, even if outside of the blueprint.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.teardown_request">
<code>teardown_request(f)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><code>Flask.teardown_request()</code></a> but for a blueprint. This function is only executed when tearing down requests handled by a function of that blueprint. Teardown request functions are executed when the request context is popped, even when no actual request was performed.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Blueprint.template_folder">
<code>template_folder = None</code> </dt> <dd>
<p>Location of the template files to be added to the template lookup. <code>None</code> if templates should not be added.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.url_defaults">
<code>url_defaults(f)</code> </dt> <dd>
<p>Callback function for URL defaults for this blueprint. It’s called with the endpoint and values and should update the values passed in place.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Blueprint.url_value_preprocessor">
<code>url_value_preprocessor(f)</code> </dt> <dd>
<p>Registers a function as URL value preprocessor for this blueprint. It’s called before the view functions are called and can modify the url values provided.</p> </dd>
</dl> </dd>
</dl>   <h2 id="incoming-request-data">Incoming Request Data</h2> <dl class="class"> <dt id="flask.Request">
<code>class flask.Request(environ, populate_request=True, shallow=False)</code> </dt> <dd>
<p>The request object used by default in Flask. Remembers the matched endpoint and view arguments.</p> <p>It is what ends up as <a class="reference internal" href="#flask.request" title="flask.request"><code>request</code></a>. If you want to replace the request object used you can subclass this and set <a class="reference internal" href="#flask.Flask.request_class" title="flask.Flask.request_class"><code>request_class</code></a> to your subclass.</p> <p>The request object is a <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.Request" title="(in Werkzeug v1.0.x)"><code>Request</code></a> subclass and provides all of the attributes Werkzeug defines plus a few Flask specific ones.</p> <dl class="attribute"> <dt id="flask.Request.environ">
<code>environ</code> </dt> <dd>
<p>The underlying WSGI environment.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.path">
<code>path</code> </dt> 
</dl> <dl class="attribute"> <dt id="flask.Request.full_path">
<code>full_path</code> </dt> 
</dl> <dl class="attribute"> <dt id="flask.Request.script_root">
<code>script_root</code> </dt> 
</dl> <dl class="attribute"> <dt id="flask.Request.url">
<code>url</code> </dt> 
</dl> <dl class="attribute"> <dt id="flask.Request.base_url">
<code>base_url</code> </dt> 
</dl> <dl class="attribute"> <dt id="flask.Request.url_root">
<code>url_root</code> </dt> <dd>
<p>Provides different ways to look at the current <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3987.html" id="index-3"><strong>RFC 3987</strong></a>. Imagine your application is listening on the following application root:</p> <pre data-language="python">http://www.example.com/myapplication
</pre> <p>And a user requests the following URI:</p> <pre data-language="python">http://www.example.com/myapplication/%CF%80/page.html?x=y
</pre> <p>In this case the values of the above mentioned attributes would be the following:</p> <table class="docutils align-default">   <tr>
<td><p><code>path</code></p></td> <td><p><code>u'/π/page.html'</code></p></td> </tr> <tr>
<td><p><code>full_path</code></p></td> <td><p><code>u'/π/page.html?x=y'</code></p></td> </tr> <tr>
<td><p><code>script_root</code></p></td> <td><p><code>u'/myapplication'</code></p></td> </tr> <tr>
<td><p><code>base_url</code></p></td> <td><p><code>u'http://www.example.com/myapplication/π/page.html'</code></p></td> </tr> <tr>
<td><p><code>url</code></p></td> <td><p><code>u'http://www.example.com/myapplication/π/page.html?x=y'</code></p></td> </tr> <tr>
<td><p><code>url_root</code></p></td> <td><p><code>u'http://www.example.com/myapplication/'</code></p></td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="flask.Request.accept_charsets">
<code>property accept_charsets</code> </dt> <dd>
<p>List of charsets this client supports as <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.CharsetAccept" title="(in Werkzeug v1.0.x)"><code>CharsetAccept</code></a> object.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.accept_encodings">
<code>property accept_encodings</code> </dt> <dd>
<p>List of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at <code>accept_charset</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.accept_languages">
<code>property accept_languages</code> </dt> <dd>
<p>List of languages this client accepts as <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.LanguageAccept" title="(in Werkzeug v1.0.x)"><code>LanguageAccept</code></a> object.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.accept_mimetypes">
<code>property accept_mimetypes</code> </dt> <dd>
<p>List of mimetypes this client supports as <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MIMEAccept" title="(in Werkzeug v1.0.x)"><code>MIMEAccept</code></a> object.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.access_control_request_headers">
<code>access_control_request_headers</code> </dt> <dd>
<p>Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set <code>access_control_allow_headers</code> on the response to indicate which headers are allowed.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.access_control_request_method">
<code>access_control_request_method</code> </dt> <dd>
<p>Sent with a preflight request to indicate which method will be used for the cross origin request. Set <code>access_control_allow_methods</code> on the response to indicate which methods are allowed.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.access_route">
<code>property access_route</code> </dt> <dd>
<p>If a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.application">
<code>classmethod application(f)</code> </dt> <dd>
<p>Decorate a function as responder that accepts the request as the last argument. This works like the <code>responder()</code> decorator but the function is passed the request object as the last argument and the request object will be closed automatically:</p> <pre data-language="python">@Request.application
def my_wsgi_app(request):
    return Response('Hello World!')
</pre> <p>As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>f</strong> – the WSGI callable to decorate</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a new WSGI callable</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Request.args">
<code>property args</code> </dt> <dd>
<p>The parsed URL parameters (the part in the URL after the question mark).</p> <p>By default an <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict" title="(in Werkzeug v1.0.x)"><code>ImmutableMultiDict</code></a> is returned from this function. This can be changed by setting <a class="reference internal" href="#flask.Request.parameter_storage_class" title="flask.Request.parameter_storage_class"><code>parameter_storage_class</code></a> to a different type. This might be necessary if the order of the form data is important.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.authorization">
<code>property authorization</code> </dt> <dd>
<p>The <code>Authorization</code> object in parsed form.</p> </dd>
</dl> <dl class="method"> <dt>
<code>property base_url</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Request.url" title="flask.Request.url"><code>url</code></a> but without the querystring See also: <code>trusted_hosts</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.blueprint">
<code>property blueprint</code> </dt> <dd>
<p>The name of the current blueprint</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.cache_control">
<code>property cache_control</code> </dt> <dd>
<p>A <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.RequestCacheControl" title="(in Werkzeug v1.0.x)"><code>RequestCacheControl</code></a> object for the incoming cache control headers.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.close">
<code>close()</code> </dt> <dd>
<p>Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Request.content_encoding">
<code>content_encoding</code> </dt> <dd>
<p>The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Request.content_length">
<code>property content_length</code> </dt> <dd>
<p>The Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.content_md5">
<code>content_md5</code> </dt> <dd>
<p>The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Request.content_type">
<code>content_type</code> </dt> <dd>
<p>The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.cookies">
<code>property cookies</code> </dt> <dd>
<p>A <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a> with the contents of all cookies transmitted with the request.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.data">
<code>property data</code> </dt> <dd>
<p>Contains the incoming request data as string in case it came with a mimetype Werkzeug does not handle.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.date">
<code>date</code> </dt> <dd>
<p>The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.dict_storage_class">
<code>dict_storage_class</code> </dt> <dd>
<p>alias of <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict" title="(in Werkzeug v1.0.x)"><code>werkzeug.datastructures.ImmutableMultiDict</code></a></p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.endpoint">
<code>property endpoint</code> </dt> <dd>
<p>The endpoint that matched the request. This in combination with <a class="reference internal" href="#flask.Request.view_args" title="flask.Request.view_args"><code>view_args</code></a> can be used to reconstruct the same or a modified URL. If an exception happened when matching, this will be <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.files">
<code>property files</code> </dt> <dd>
<p><a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MultiDict" title="(in Werkzeug v1.0.x)"><code>MultiDict</code></a> object containing all uploaded files. Each key in <a class="reference internal" href="#flask.Request.files" title="flask.Request.files"><code>files</code></a> is the name from the <code>&lt;input type="file" name=""&gt;</code>. Each value in <a class="reference internal" href="#flask.Request.files" title="flask.Request.files"><code>files</code></a> is a Werkzeug <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage" title="(in Werkzeug v1.0.x)"><code>FileStorage</code></a> object.</p> <p>It basically behaves like a standard file object you know from Python, with the difference that it also has a <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save" title="(in Werkzeug v1.0.x)"><code>save()</code></a> function that can store the file on the filesystem.</p> <p>Note that <a class="reference internal" href="#flask.Request.files" title="flask.Request.files"><code>files</code></a> will only contain data if the request method was POST, PUT or PATCH and the <code>&lt;form&gt;</code> that posted to the request had <code>enctype="multipart/form-data"</code>. It will be empty otherwise.</p> <p>See the <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MultiDict" title="(in Werkzeug v1.0.x)"><code>MultiDict</code></a> / <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage" title="(in Werkzeug v1.0.x)"><code>FileStorage</code></a> documentation for more details about the used data structure.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.form">
<code>property form</code> </dt> <dd>
<p>The form parameters. By default an <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict" title="(in Werkzeug v1.0.x)"><code>ImmutableMultiDict</code></a> is returned from this function. This can be changed by setting <a class="reference internal" href="#flask.Request.parameter_storage_class" title="flask.Request.parameter_storage_class"><code>parameter_storage_class</code></a> to a different type. This might be necessary if the order of the form data is important.</p> <p>Please keep in mind that file uploads will not end up here, but instead in the <a class="reference internal" href="#flask.Request.files" title="flask.Request.files"><code>files</code></a> attribute.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests.</p> </div> </details>
</dd>
</dl> <dl class="attribute"> <dt id="flask.Request.form_data_parser_class">
<code>form_data_parser_class</code> </dt> <dd>
<p>alias of <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/http/#werkzeug.formparser.FormDataParser" title="(in Werkzeug v1.0.x)"><code>werkzeug.formparser.FormDataParser</code></a></p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.from_values">
<code>classmethod from_values(*args, **kwargs)</code> </dt> <dd>
<p>Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (<code>Client</code>) that allows to create multipart requests, support for cookies etc.</p> <p>This accepts the same options as the <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder" title="(in Werkzeug v1.0.x)"><code>EnvironBuilder</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>This method now accepts the same arguments as <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder" title="(in Werkzeug v1.0.x)"><code>EnvironBuilder</code></a>. Because of this the <code>environ</code> parameter is now called <code>environ_overrides</code>.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>request object</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt>
<code>property full_path</code> </dt> <dd>
<p>Requested path as unicode, including the query string.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.get_data">
<code>get_data(cache=True, as_text=False, parse_form_data=False)</code> </dt> <dd>
<p>This reads the buffered incoming data from the client into one bytestring. By default this is cached but that behavior can be changed by setting <code>cache</code> to <code>False</code>.</p> <p>Usually it’s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server.</p> <p>Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set <code>parse_form_data</code> to <code>True</code>. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory.</p> <p>If <code>as_text</code> is set to <code>True</code> the return value will be a decoded unicode string.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Request.get_json">
<code>get_json(force=False, silent=False, cache=True)</code> </dt> <dd>
<p>Parse <a class="reference internal" href="#flask.Request.data" title="flask.Request.data"><code>data</code></a> as JSON.</p> <p>If the mimetype does not indicate JSON (<em class="mimetype">application/json</em>, see <a class="reference internal" href="#flask.Request.is_json" title="flask.Request.is_json"><code>is_json()</code></a>), this returns <code>None</code>.</p> <p>If parsing fails, <a class="reference internal" href="#flask.Request.on_json_loading_failed" title="flask.Request.on_json_loading_failed"><code>on_json_loading_failed()</code></a> is called and its return value is used as the return value.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>force</strong> – Ignore the mimetype and always try to parse JSON.</li> <li>
<strong>silent</strong> – Silence parsing errors and return <code>None</code> instead.</li> <li>
<strong>cache</strong> – Store the parsed JSON to return for subsequent calls.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Request.headers">
<code>property headers</code> </dt> <dd>
<p>The headers from the WSGI environ as immutable <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.EnvironHeaders" title="(in Werkzeug v1.0.x)"><code>EnvironHeaders</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.host">
<code>property host</code> </dt> <dd>
<p>Just the host including the port if available. See also: <code>trusted_hosts</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.host_url">
<code>property host_url</code> </dt> <dd>
<p>Just the host with scheme as IRI. See also: <code>trusted_hosts</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.if_match">
<code>property if_match</code> </dt> <dd>
<p>An object containing all the etags in the <code>If-Match</code> header.</p> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ETags" title="(in Werkzeug v1.0.x)"><code>ETags</code></a></p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Request.if_modified_since">
<code>property if_modified_since</code> </dt> <dd>
<p>The parsed <code>If-Modified-Since</code> header as datetime object.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.if_none_match">
<code>property if_none_match</code> </dt> <dd>
<p>An object containing all the etags in the <code>If-None-Match</code> header.</p> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ETags" title="(in Werkzeug v1.0.x)"><code>ETags</code></a></p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Request.if_range">
<code>property if_range</code> </dt> <dd>
<p>The parsed <code>If-Range</code> header.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.IfRange" title="(in Werkzeug v1.0.x)"><code>IfRange</code></a></p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Request.if_unmodified_since">
<code>property if_unmodified_since</code> </dt> <dd>
<p>The parsed <code>If-Unmodified-Since</code> header as datetime object.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.is_json">
<code>property is_json</code> </dt> <dd>
<p>Check if the mimetype indicates JSON data, either <em class="mimetype">application/json</em> or <em class="mimetype">application/*+json</em>.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.is_multiprocess">
<code>is_multiprocess</code> </dt> <dd>
<p>boolean that is <code>True</code> if the application is served by a WSGI server that spawns multiple processes.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.is_multithread">
<code>is_multithread</code> </dt> <dd>
<p>boolean that is <code>True</code> if the application is served by a multithreaded WSGI server.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.is_run_once">
<code>is_run_once</code> </dt> <dd>
<p>boolean that is <code>True</code> if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it’s not guaranteed that the execution only happens one time.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.is_secure">
<code>property is_secure</code> </dt> <dd>
<p><code>True</code> if the request is secure.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.json">
<code>property json</code> </dt> <dd>
<p>The parsed JSON data if <a class="reference internal" href="#flask.Request.mimetype" title="flask.Request.mimetype"><code>mimetype</code></a> indicates JSON (<em class="mimetype">application/json</em>, see <a class="reference internal" href="#flask.Request.is_json" title="flask.Request.is_json"><code>is_json()</code></a>).</p> <p>Calls <a class="reference internal" href="#flask.Request.get_json" title="flask.Request.get_json"><code>get_json()</code></a> with default arguments.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.json_module">
<code>json_module = &lt;module 'flask.json' from '/home/docs/checkouts/readthedocs.org/user_builds/flask/envs/1.1.x/lib/python3.7/site-packages/Flask-1.1.2-py3.7.egg/flask/json/__init__.py'&gt;</code> </dt> 
</dl> <dl class="attribute"> <dt id="flask.Request.list_storage_class">
<code>list_storage_class</code> </dt> <dd>
<p>alias of <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableList" title="(in Werkzeug v1.0.x)"><code>werkzeug.datastructures.ImmutableList</code></a></p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.make_form_data_parser">
<code>make_form_data_parser()</code> </dt> <dd>
<p>Creates the form data parser. Instantiates the <a class="reference internal" href="#flask.Request.form_data_parser_class" title="flask.Request.form_data_parser_class"><code>form_data_parser_class</code></a> with some parameters.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Request.max_content_length">
<code>property max_content_length</code> </dt> <dd>
<p>Read-only view of the <code>MAX_CONTENT_LENGTH</code> config key.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.max_forwards">
<code>max_forwards</code> </dt> <dd>
<p>The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.method">
<code>method</code> </dt> <dd>
<p>The request method. (For example <code>'GET'</code> or <code>'POST'</code>).</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.mimetype">
<code>property mimetype</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.Request.content_type" title="flask.Request.content_type"><code>content_type</code></a>, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is <code>text/HTML; charset=utf-8</code> the mimetype would be <code>'text/html'</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.mimetype_params">
<code>property mimetype_params</code> </dt> <dd>
<p>The mimetype parameters as dict. For example if the content type is <code>text/html; charset=utf-8</code> the params would be <code>{'charset': 'utf-8'}</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.on_json_loading_failed">
<code>on_json_loading_failed(e)</code> </dt> <dd>
<p>Called if <a class="reference internal" href="#flask.Request.get_json" title="flask.Request.get_json"><code>get_json()</code></a> parsing fails and isn’t silenced. If this method returns a value, it is used as the return value for <a class="reference internal" href="#flask.Request.get_json" title="flask.Request.get_json"><code>get_json()</code></a>. The default implementation raises <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.BadRequest" title="(in Werkzeug v1.0.x)"><code>BadRequest</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.origin">
<code>origin</code> </dt> <dd>
<p>The host that the request originated from. Set <code>access_control_allow_origin</code> on the response to indicate which origins are allowed.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.parameter_storage_class">
<code>parameter_storage_class</code> </dt> <dd>
<p>alias of <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict" title="(in Werkzeug v1.0.x)"><code>werkzeug.datastructures.ImmutableMultiDict</code></a></p> </dd>
</dl> <dl class="method"> <dt>
<code>property path</code> </dt> <dd>
<p>Requested path as unicode. This works a bit like the regular path info in the WSGI environment but will always include a leading slash, even if the URL root is accessed.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.pragma">
<code>property pragma</code> </dt> <dd>
<p>The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.query_string">
<code>query_string</code> </dt> <dd>
<p>The URL parameters as raw bytestring.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.range">
<code>property range</code> </dt> <dd>
<p>The parsed <code>Range</code> header.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.Range" title="(in Werkzeug v1.0.x)"><code>Range</code></a></p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.referrer">
<code>referrer</code> </dt> <dd>
<p>The Referer[sic] request-header field allows the client to specify, for the server’s benefit, the address (URI) of the resource from which the Request-URI was obtained (the “referrer”, although the header field is misspelled).</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.remote_addr">
<code>property remote_addr</code> </dt> <dd>
<p>The remote address of the client.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.remote_user">
<code>remote_user</code> </dt> <dd>
<p>If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.routing_exception">
<code>routing_exception = None</code> </dt> <dd>
<p>If matching the URL failed, this is the exception that will be raised / was raised as part of the request handling. This is usually a <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.NotFound" title="(in Werkzeug v1.0.x)"><code>NotFound</code></a> exception or something similar.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.scheme">
<code>scheme</code> </dt> <dd>
<p>URL scheme (http or https).</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt>
<code>property script_root</code> </dt> <dd>
<p>The root path of the script without the trailing slash.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.stream">
<code>property stream</code> </dt> <dd>
<p>If the incoming form data was not encoded with a known mimetype the data is stored unmodified in this stream for consumption. Most of the time it is a better idea to use <a class="reference internal" href="#flask.Request.data" title="flask.Request.data"><code>data</code></a> which will give you that data as a string. The stream only returns the data once.</p> <p>Unlike <code>input_stream</code> this stream is properly guarded that you can’t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>This stream is now always available but might be consumed by the form parser later on. Previously the stream was only set if no parsing happened.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt>
<code>property url</code> </dt> <dd>
<p>The reconstructed current URL as IRI. See also: <code>trusted_hosts</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.url_charset">
<code>property url_charset</code> </dt> <dd>
<p>The charset that is assumed for URLs. Defaults to the value of <code>charset</code>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt>
<code>property url_root</code> </dt> <dd>
<p>The full URL root (with hostname), this is the application root as IRI. See also: <code>trusted_hosts</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.url_rule">
<code>url_rule = None</code> </dt> <dd>
<p>The internal URL rule that matched the request. This can be useful to inspect which methods are allowed for the URL from a before/after handler (<code>request.url_rule.methods</code>) etc. Though if the request’s method was invalid for the URL rule, the valid list is available in <code>routing_exception.valid_methods</code> instead (an attribute of the Werkzeug exception <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.MethodNotAllowed" title="(in Werkzeug v1.0.x)"><code>MethodNotAllowed</code></a>) because the request was never internally bound.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Request.user_agent">
<code>property user_agent</code> </dt> <dd>
<p>The current user agent.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.values">
<code>property values</code> </dt> <dd>
<p>A <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.CombinedMultiDict" title="(in Werkzeug v1.0.x)"><code>werkzeug.datastructures.CombinedMultiDict</code></a> that combines <a class="reference internal" href="#flask.Request.args" title="flask.Request.args"><code>args</code></a> and <a class="reference internal" href="#flask.Request.form" title="flask.Request.form"><code>form</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Request.view_args">
<code>view_args = None</code> </dt> <dd>
<p>A dict of view arguments that matched the request. If an exception happened when matching, this will be <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Request.want_form_data_parsed">
<code>property want_form_data_parsed</code> </dt> <dd>
<p>Returns True if the request method carries content. As of Werkzeug 0.9 this will be the case if a content type is transmitted.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> </dd>
</dl> <dl class="attribute"> <dt id="flask.request">
<code>flask.request</code> </dt> <dd>
<p>To access incoming request data, you can use the global <code>request</code> object. Flask parses incoming request data for you and gives you access to it through that global object. Internally Flask makes sure that you always get the correct data for the active thread if you are in a multithreaded environment.</p> <p>This is a proxy. See <a class="reference internal" href="../reqcontext/index#notes-on-proxies"><span class="std std-ref">Notes On Proxies</span></a> for more information.</p> <p>The request object is an instance of a <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.Request" title="(in Werkzeug v1.0.x)"><code>Request</code></a> subclass and provides all of the attributes Werkzeug defines. This just shows a quick overview of the most important ones.</p> </dd>
</dl>   <h2 id="response-objects">Response Objects</h2> <dl class="class"> <dt id="flask.Response">
<code>class flask.Response(response=None, status=None, headers=None, mimetype=None, content_type=None, direct_passthrough=False)</code> </dt> <dd>
<p>The response object that is used by default in Flask. Works like the response object from Werkzeug but is set to have an HTML mimetype by default. Quite often you don’t have to create this object yourself because <a class="reference internal" href="#flask.Flask.make_response" title="flask.Flask.make_response"><code>make_response()</code></a> will take care of that for you.</p> <p>If you want to replace the response object used you can subclass this and set <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><code>response_class</code></a> to your subclass.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>JSON support is added to the response, like the request. This is useful when testing to get the test client response data as JSON.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>Added <a class="reference internal" href="#flask.Response.max_cookie_size" title="flask.Response.max_cookie_size"><code>max_cookie_size</code></a>.</p> </div> </details><dl class="attribute"> <dt id="flask.Response.headers">
<code>headers</code> </dt> <dd>
<p>A <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.Headers" title="(in Werkzeug v1.0.x)"><code>Headers</code></a> object representing the response headers.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Response.status">
<code>status</code> </dt> <dd>
<p>A string with a response status.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.Response.status_code">
<code>status_code</code> </dt> <dd>
<p>The response status as integer.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Response.data">
<code>property data</code> </dt> <dd>
<p>A descriptor that calls <code>get_data()</code> and <code>set_data()</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Response.get_json">
<code>get_json(force=False, silent=False, cache=True)</code> </dt> <dd>
<p>Parse <a class="reference internal" href="#flask.Response.data" title="flask.Response.data"><code>data</code></a> as JSON.</p> <p>If the mimetype does not indicate JSON (<em class="mimetype">application/json</em>, see <a class="reference internal" href="#flask.Response.is_json" title="flask.Response.is_json"><code>is_json()</code></a>), this returns <code>None</code>.</p> <p>If parsing fails, <code>on_json_loading_failed()</code> is called and its return value is used as the return value.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>force</strong> – Ignore the mimetype and always try to parse JSON.</li> <li>
<strong>silent</strong> – Silence parsing errors and return <code>None</code> instead.</li> <li>
<strong>cache</strong> – Store the parsed JSON to return for subsequent calls.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Response.is_json">
<code>property is_json</code> </dt> <dd>
<p>Check if the mimetype indicates JSON data, either <em class="mimetype">application/json</em> or <em class="mimetype">application/*+json</em>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Response.max_cookie_size">
<code>property max_cookie_size</code> </dt> <dd>
<p>Read-only view of the <a class="reference internal" href="../config/index#MAX_COOKIE_SIZE" title="MAX_COOKIE_SIZE"><code>MAX_COOKIE_SIZE</code></a> config key.</p> <p>See <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.BaseResponse.max_cookie_size" title="(in Werkzeug v1.0.x)"><code>max_cookie_size</code></a> in Werkzeug’s docs.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Response.mimetype">
<code>property mimetype</code> </dt> <dd>
<p>The mimetype (content type without charset etc.)</p> </dd>
</dl> <dl class="method"> <dt id="flask.Response.set_cookie">
<code>set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)</code> </dt> <dd>
<p>Sets a cookie. The parameters are the same as in the cookie <code>Morsel</code> object in the Python standard library but it accepts unicode data, too.</p> <p>A warning is raised if the size of the cookie header exceeds <a class="reference internal" href="#flask.Response.max_cookie_size" title="flask.Response.max_cookie_size"><code>max_cookie_size</code></a>, but the header will still be set.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – the key (name) of the cookie to be set.</li> <li>
<strong>value</strong> – the value of the cookie.</li> <li>
<strong>max_age</strong> – should be a number of seconds, or <code>None</code> (default) if the cookie should last only as long as the client’s browser session.</li> <li>
<strong>expires</strong> – should be a <code>datetime</code> object or UNIX timestamp.</li> <li>
<strong>path</strong> – limits the cookie to a given path, per default it will span the whole domain.</li> <li>
<strong>domain</strong> – if you want to set a cross-domain cookie. For example, <code>domain=".example.com"</code> will set a cookie that is readable by the domain <code>www.example.com</code>, <code>foo.example.com</code> etc. Otherwise, a cookie will only be readable by the domain that set it.</li> <li>
<strong>secure</strong> – If <code>True</code>, the cookie will only be available via HTTPS</li> <li>
<strong>httponly</strong> – disallow JavaScript to access the cookie. This is an extension to the cookie standard and probably not supported by all browsers.</li> <li>
<strong>samesite</strong> – Limits the scope of the cookie such that it will only be attached to requests if those requests are “same-site”.</li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="sessions">Sessions</h2> <p>If you have set <a class="reference internal" href="#flask.Flask.secret_key" title="flask.Flask.secret_key"><code>Flask.secret_key</code></a> (or configured it from <a class="reference internal" href="../config/index#SECRET_KEY" title="SECRET_KEY"><code>SECRET_KEY</code></a>) you can use sessions in Flask applications. A session makes it possible to remember information from one request to another. The way Flask does this is by using a signed cookie. The user can look at the session contents, but can’t modify it unless they know the secret key, so make sure to set that to something complex and unguessable.</p> <p>To access the current session you can use the <a class="reference internal" href="#flask.session" title="flask.session"><code>session</code></a> object:</p> <dl class="class"> <dt id="flask.session">
<code>class flask.session</code> </dt> <dd>
<p>The session object works pretty much like an ordinary dict, with the difference that it keeps track of modifications.</p> <p>This is a proxy. See <a class="reference internal" href="../reqcontext/index#notes-on-proxies"><span class="std std-ref">Notes On Proxies</span></a> for more information.</p> <p>The following attributes are interesting:</p> <dl class="attribute"> <dt id="flask.session.new">
<code>new</code> </dt> <dd>
<p><code>True</code> if the session is new, <code>False</code> otherwise.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.session.modified">
<code>modified</code> </dt> <dd>
<p><code>True</code> if the session object detected a modification. Be advised that modifications on mutable structures are not picked up automatically, in that situation you have to explicitly set the attribute to <code>True</code> yourself. Here an example:</p> <pre data-language="python"># this change is not picked up because a mutable object (here
# a list) is changed.
session['objects'].append(42)
# so mark it as modified yourself
session.modified = True
</pre> </dd>
</dl> <dl class="attribute"> <dt id="flask.session.permanent">
<code>permanent</code> </dt> <dd>
<p>If set to <code>True</code> the session lives for <a class="reference internal" href="#flask.Flask.permanent_session_lifetime" title="flask.Flask.permanent_session_lifetime"><code>permanent_session_lifetime</code></a> seconds. The default is 31 days. If set to <code>False</code> (which is the default) the session will be deleted when the user closes the browser.</p> </dd>
</dl> </dd>
</dl>   <h2 id="session-interface">Session Interface</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details><p>The session interface provides a simple way to replace the session implementation that Flask is using.</p> <dl class="class"> <dt id="flask.sessions.SessionInterface">
<code>class flask.sessions.SessionInterface</code> </dt> <dd>
<p>The basic interface you have to implement in order to replace the default session interface which uses werkzeug’s securecookie implementation. The only methods you have to implement are <a class="reference internal" href="#flask.sessions.SessionInterface.open_session" title="flask.sessions.SessionInterface.open_session"><code>open_session()</code></a> and <a class="reference internal" href="#flask.sessions.SessionInterface.save_session" title="flask.sessions.SessionInterface.save_session"><code>save_session()</code></a>, the others have useful defaults which you don’t need to change.</p> <p>The session object returned by the <a class="reference internal" href="#flask.sessions.SessionInterface.open_session" title="flask.sessions.SessionInterface.open_session"><code>open_session()</code></a> method has to provide a dictionary like interface plus the properties and methods from the <a class="reference internal" href="#flask.sessions.SessionMixin" title="flask.sessions.SessionMixin"><code>SessionMixin</code></a>. We recommend just subclassing a dict and adding that mixin:</p> <pre data-language="python">class Session(dict, SessionMixin):
    pass
</pre> <p>If <a class="reference internal" href="#flask.sessions.SessionInterface.open_session" title="flask.sessions.SessionInterface.open_session"><code>open_session()</code></a> returns <code>None</code> Flask will call into <a class="reference internal" href="#flask.sessions.SessionInterface.make_null_session" title="flask.sessions.SessionInterface.make_null_session"><code>make_null_session()</code></a> to create a session that acts as replacement if the session support cannot work because some requirement is not fulfilled. The default <a class="reference internal" href="#flask.sessions.NullSession" title="flask.sessions.NullSession"><code>NullSession</code></a> class that is created will complain that the secret key was not set.</p> <p>To replace the session interface on an application all you have to do is to assign <a class="reference internal" href="#flask.Flask.session_interface" title="flask.Flask.session_interface"><code>flask.Flask.session_interface</code></a>:</p> <pre data-language="python">app = Flask(__name__)
app.session_interface = MySessionInterface()
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details><dl class="method"> <dt id="flask.sessions.SessionInterface.get_cookie_domain">
<code>get_cookie_domain(app)</code> </dt> <dd>
<p>Returns the domain that should be set for the session cookie.</p> <p>Uses <code>SESSION_COOKIE_DOMAIN</code> if it is configured, otherwise falls back to detecting the domain based on <code>SERVER_NAME</code>.</p> <p>Once detected (or if not set at all), <code>SESSION_COOKIE_DOMAIN</code> is updated to avoid re-running the logic.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionInterface.get_cookie_httponly">
<code>get_cookie_httponly(app)</code> </dt> <dd>
<p>Returns True if the session cookie should be httponly. This currently just returns the value of the <code>SESSION_COOKIE_HTTPONLY</code> config var.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionInterface.get_cookie_path">
<code>get_cookie_path(app)</code> </dt> <dd>
<p>Returns the path for which the cookie should be valid. The default implementation uses the value from the <code>SESSION_COOKIE_PATH</code> config var if it’s set, and falls back to <code>APPLICATION_ROOT</code> or uses <code>/</code> if it’s <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionInterface.get_cookie_samesite">
<code>get_cookie_samesite(app)</code> </dt> <dd>
<p>Return <code>'Strict'</code> or <code>'Lax'</code> if the cookie should use the <code>SameSite</code> attribute. This currently just returns the value of the <a class="reference internal" href="../config/index#SESSION_COOKIE_SAMESITE" title="SESSION_COOKIE_SAMESITE"><code>SESSION_COOKIE_SAMESITE</code></a> setting.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionInterface.get_cookie_secure">
<code>get_cookie_secure(app)</code> </dt> <dd>
<p>Returns True if the cookie should be secure. This currently just returns the value of the <code>SESSION_COOKIE_SECURE</code> setting.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionInterface.get_expiration_time">
<code>get_expiration_time(app, session)</code> </dt> <dd>
<p>A helper method that returns an expiration date for the session or <code>None</code> if the session is linked to the browser session. The default implementation returns now + the permanent session lifetime configured on the application.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionInterface.is_null_session">
<code>is_null_session(obj)</code> </dt> <dd>
<p>Checks if a given object is a null session. Null sessions are not asked to be saved.</p> <p>This checks if the object is an instance of <a class="reference internal" href="#flask.sessions.SessionInterface.null_session_class" title="flask.sessions.SessionInterface.null_session_class"><code>null_session_class</code></a> by default.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionInterface.make_null_session">
<code>make_null_session(app)</code> </dt> <dd>
<p>Creates a null session which acts as a replacement object if the real session support could not be loaded due to a configuration error. This mainly aids the user experience because the job of the null session is to still support lookup without complaining but modifications are answered with a helpful error message of what failed.</p> <p>This creates an instance of <a class="reference internal" href="#flask.sessions.SessionInterface.null_session_class" title="flask.sessions.SessionInterface.null_session_class"><code>null_session_class</code></a> by default.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.sessions.SessionInterface.null_session_class">
<code>null_session_class</code> </dt> <dd>
<p><a class="reference internal" href="#flask.sessions.SessionInterface.make_null_session" title="flask.sessions.SessionInterface.make_null_session"><code>make_null_session()</code></a> will look here for the class that should be created when a null session is requested. Likewise the <a class="reference internal" href="#flask.sessions.SessionInterface.is_null_session" title="flask.sessions.SessionInterface.is_null_session"><code>is_null_session()</code></a> method will perform a typecheck against this type.</p> <p>alias of <a class="reference internal" href="#flask.sessions.NullSession" title="flask.sessions.NullSession"><code>NullSession</code></a></p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionInterface.open_session">
<code>open_session(app, request)</code> </dt> <dd>
<p>This method has to be implemented and must either return <code>None</code> in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on <a class="reference internal" href="#flask.sessions.SessionMixin" title="flask.sessions.SessionMixin"><code>SessionMixin</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.sessions.SessionInterface.pickle_based">
<code>pickle_based = False</code> </dt> <dd>
<p>A flag that indicates if the session interface is pickle based. This can be used by Flask extensions to make a decision in regards to how to deal with the session object.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionInterface.save_session">
<code>save_session(app, session, response)</code> </dt> <dd>
<p>This is called for actual sessions returned by <a class="reference internal" href="#flask.sessions.SessionInterface.open_session" title="flask.sessions.SessionInterface.open_session"><code>open_session()</code></a> at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionInterface.should_set_cookie">
<code>should_set_cookie(app, session)</code> </dt> <dd>
<p>Used by session backends to determine if a <code>Set-Cookie</code> header should be set for this session cookie for this response. If the session has been modified, the cookie is set. If the session is permanent and the <code>SESSION_REFRESH_EACH_REQUEST</code> config is true, the cookie is always set.</p> <p>This check is usually skipped if the session was deleted.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="flask.sessions.SecureCookieSessionInterface">
<code>class flask.sessions.SecureCookieSessionInterface</code> </dt> <dd>
<p>The default session interface that stores sessions in signed cookies through the <code>itsdangerous</code> module.</p> <dl class="method"> <dt id="flask.sessions.SecureCookieSessionInterface.digest_method">
<code>static digest_method()</code> </dt> <dd>
<p>the hash function to use for the signature. The default is sha1</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.sessions.SecureCookieSessionInterface.key_derivation">
<code>key_derivation = 'hmac'</code> </dt> <dd>
<p>the name of the itsdangerous supported key derivation. The default is hmac.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SecureCookieSessionInterface.open_session">
<code>open_session(app, request)</code> </dt> <dd>
<p>This method has to be implemented and must either return <code>None</code> in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on <a class="reference internal" href="#flask.sessions.SessionMixin" title="flask.sessions.SessionMixin"><code>SessionMixin</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.sessions.SecureCookieSessionInterface.salt">
<code>salt = 'cookie-session'</code> </dt> <dd>
<p>the salt that should be applied on top of the secret key for the signing of cookie based sessions.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SecureCookieSessionInterface.save_session">
<code>save_session(app, session, response)</code> </dt> <dd>
<p>This is called for actual sessions returned by <a class="reference internal" href="#flask.sessions.SecureCookieSessionInterface.open_session" title="flask.sessions.SecureCookieSessionInterface.open_session"><code>open_session()</code></a> at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.sessions.SecureCookieSessionInterface.serializer">
<code>serializer = &lt;flask.json.tag.TaggedJSONSerializer object&gt;</code> </dt> <dd>
<p>A python serializer for the payload. The default is a compact JSON derived serializer with support for some extra Python types such as datetime objects or tuples.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.sessions.SecureCookieSessionInterface.session_class">
<code>session_class</code> </dt> <dd>
<p>alias of <a class="reference internal" href="#flask.sessions.SecureCookieSession" title="flask.sessions.SecureCookieSession"><code>SecureCookieSession</code></a></p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="flask.sessions.SecureCookieSession">
<code>class flask.sessions.SecureCookieSession(initial=None)</code> </dt> <dd>
<p>Base class for sessions based on signed cookies.</p> <p>This session backend will set the <a class="reference internal" href="#flask.sessions.SecureCookieSession.modified" title="flask.sessions.SecureCookieSession.modified"><code>modified</code></a> and <a class="reference internal" href="#flask.sessions.SecureCookieSession.accessed" title="flask.sessions.SecureCookieSession.accessed"><code>accessed</code></a> attributes. It cannot reliably track whether a session is new (vs. empty), so <code>new</code> remains hard coded to <code>False</code>.</p> <dl class="attribute"> <dt id="flask.sessions.SecureCookieSession.accessed">
<code>accessed = False</code> </dt> <dd>
<p>header, which allows caching proxies to cache different pages for different users.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SecureCookieSession.get">
<code>get(key, default=None)</code> </dt> <dd>
<p>Return the value for key if key is in the dictionary, else default.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.sessions.SecureCookieSession.modified">
<code>modified = False</code> </dt> <dd>
<p>When data is changed, this is set to <code>True</code>. Only the session dictionary itself is tracked; if the session contains mutable data (for example a nested dict) then this must be set to <code>True</code> manually when modifying that data. The session cookie will only be written to the response if this is <code>True</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SecureCookieSession.setdefault">
<code>setdefault(key, default=None)</code> </dt> <dd>
<p>Insert key with a value of default if key is not in the dictionary.</p> <p>Return the value for key if key is in the dictionary, else default.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="flask.sessions.NullSession">
<code>class flask.sessions.NullSession(initial=None)</code> </dt> <dd>
<p>Class used to generate nicer error messages if sessions are not available. Will still allow read-only access to the empty session but fail on setting.</p> </dd>
</dl> <dl class="class"> <dt id="flask.sessions.SessionMixin">
<code>class flask.sessions.SessionMixin</code> </dt> <dd>
<p>Expands a basic dictionary with session attributes.</p> <dl class="attribute"> <dt id="flask.sessions.SessionMixin.accessed">
<code>accessed = True</code> </dt> <dd>
<p>Some implementations can detect when session data is read or written and set this when that happens. The mixin default is hard coded to <code>True</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.sessions.SessionMixin.modified">
<code>modified = True</code> </dt> <dd>
<p>Some implementations can detect changes to the session and set this when that happens. The mixin default is hard coded to <code>True</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.sessions.SessionMixin.permanent">
<code>property permanent</code> </dt> <dd>
<p>This reflects the <code>'_permanent'</code> key in the dict.</p> </dd>
</dl> </dd>
</dl> <div class="admonition-notice admonition"> <p class="admonition-title">Notice</p> <p>The <code>PERMANENT_SESSION_LIFETIME</code> config key can also be an integer starting with Flask 0.8. Either catch this down yourself or use the <a class="reference internal" href="#flask.Flask.permanent_session_lifetime" title="flask.Flask.permanent_session_lifetime"><code>permanent_session_lifetime</code></a> attribute on the app which converts the result to an integer automatically.</p> </div>   <h2 id="test-client">Test Client</h2> <dl class="class"> <dt id="flask.testing.FlaskClient">
<code>class flask.testing.FlaskClient(*args, **kwargs)</code> </dt> <dd>
<p>Works like a regular Werkzeug test client but has some knowledge about how Flask works to defer the cleanup of the request context stack to the end of a <code>with</code> body when used in a <code>with</code> statement. For general information about how to use this class refer to <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.Client" title="(in Werkzeug v1.0.x)"><code>werkzeug.test.Client</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.12: </span><code>app.test_client()</code> includes preset default environment, which can be set after instantiation of the <code>app.test_client()</code> object in <code>client.environ_base</code>.</p> </div> </details><p>Basic usage is outlined in the <a class="reference internal" href="../testing/index#testing"><span class="std std-ref">Testing Flask Applications</span></a> chapter.</p> <dl class="method"> <dt id="flask.testing.FlaskClient.open">
<code>open(*args, **kwargs)</code> </dt> <dd>
<p>Takes the same arguments as the <code>EnvironBuilder</code> class with some additions: You can provide a <code>EnvironBuilder</code> or a WSGI environment as only argument instead of the <code>EnvironBuilder</code> arguments and two optional keyword arguments (<code>as_tuple</code>, <code>buffered</code>) that change the type of the return value or the way the application is executed.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>If a dict is provided as file in the dict for the <code>data</code> parameter the content type has to be called <code>content_type</code> now instead of <code>mimetype</code>. This change was made for consistency with <code>werkzeug.FileWrapper</code>.</p>  <p>The <code>follow_redirects</code> parameter was added to <a class="reference internal" href="#flask.testing.FlaskClient.open" title="flask.testing.FlaskClient.open"><code>open()</code></a>.</p>  </div> </details><p>Additional parameters:</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>as_tuple</strong> – Returns a tuple in the form <code>(environ, result)</code>
</li> <li>
<strong>buffered</strong> – Set this to True to buffer the application run. This will automatically close the application for you as well.</li> <li>
<strong>follow_redirects</strong> – Set this to True if the <code>Client</code> should follow HTTP redirects.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.testing.FlaskClient.session_transaction">
<code>session_transaction(*args, **kwargs)</code> </dt> <dd>
<p>When used in combination with a <code>with</code> statement this opens a session transaction. This can be used to modify the session that the test client uses. Once the <code>with</code> block is left the session is stored back.</p> <pre data-language="python">with client.session_transaction() as session:
    session['value'] = 42
</pre> <p>Internally this is implemented by going through a temporary test request context and since session handling could depend on request variables this function accepts the same arguments as <a class="reference internal" href="#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code>test_request_context()</code></a> which are directly passed through.</p> </dd>
</dl> </dd>
</dl>   <h2 id="test-cli-runner">Test CLI Runner</h2> <dl class="class"> <dt id="flask.testing.FlaskCliRunner">
<code>class flask.testing.FlaskCliRunner(app, **kwargs)</code> </dt> <dd>
<p>A <a class="reference external" href="https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner" title="(in Click v7.x)"><code>CliRunner</code></a> for testing a Flask app’s CLI commands. Typically created using <a class="reference internal" href="#flask.Flask.test_cli_runner" title="flask.Flask.test_cli_runner"><code>test_cli_runner()</code></a>. See <a class="reference internal" href="../testing/index#testing-cli"><span class="std std-ref">Testing CLI Commands</span></a>.</p> <dl class="method"> <dt id="flask.testing.FlaskCliRunner.invoke">
<code>invoke(cli=None, args=None, **kwargs)</code> </dt> <dd>
<p>Invokes a CLI command in an isolated environment. See <a class="reference external" href="https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner.invoke" title="(in Click v7.x)"><code>CliRunner.invoke</code></a> for full method documentation. See <a class="reference internal" href="../testing/index#testing-cli"><span class="std std-ref">Testing CLI Commands</span></a> for examples.</p> <p>If the <code>obj</code> argument is not given, passes an instance of <a class="reference internal" href="#flask.cli.ScriptInfo" title="flask.cli.ScriptInfo"><code>ScriptInfo</code></a> that knows how to load the Flask app being tested.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>cli</strong> – Command object to invoke. Default is the app’s <code>cli</code> group.</li> <li>
<strong>args</strong> – List of strings to invoke the command with.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a <a class="reference external" href="https://click.palletsprojects.com/en/7.x/api/#click.testing.Result" title="(in Click v7.x)"><code>Result</code></a> object.</p> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="application-globals">Application Globals</h2> <p>To share data that is valid for one request only from one function to another, a global variable is not good enough because it would break in threaded environments. Flask provides you with a special object that ensures it is only valid for the active request and that will return different values for each request. In a nutshell: it does the right thing, like it does for <a class="reference internal" href="#flask.request" title="flask.request"><code>request</code></a> and <a class="reference internal" href="#flask.session" title="flask.session"><code>session</code></a>.</p> <dl class="data"> <dt id="flask.g">
<code>flask.g</code> </dt> <dd>
<p>A namespace object that can store data during an <a class="reference internal" href="../appcontext/index"><span class="doc">application context</span></a>. This is an instance of <a class="reference internal" href="#flask.Flask.app_ctx_globals_class" title="flask.Flask.app_ctx_globals_class"><code>Flask.app_ctx_globals_class</code></a>, which defaults to <a class="reference internal" href="#flask.ctx._AppCtxGlobals" title="flask.ctx._AppCtxGlobals"><code>ctx._AppCtxGlobals</code></a>.</p> <p>This is a good place to store resources during a request. During testing, you can use the <a class="reference internal" href="../testing/index#faking-resources"><span class="std std-ref">Faking Resources and Context</span></a> pattern to pre-configure such resources.</p> <p>This is a proxy. See <a class="reference internal" href="../reqcontext/index#notes-on-proxies"><span class="std std-ref">Notes On Proxies</span></a> for more information.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.10: </span>Bound to the application context instead of the request context.</p> </div> </details>
</dd>
</dl> <dl class="class"> <dt id="flask.ctx._AppCtxGlobals">
<code>class flask.ctx._AppCtxGlobals</code> </dt> <dd>
<p>A plain object. Used as a namespace for storing data during an application context.</p> <p>Creating an app context automatically creates this object, which is made available as the <code>g</code> proxy.</p> <dl class="describe"> <dt>
<code>'key' in g</code> </dt> <dd>
<p>Check whether an attribute is present.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details>
</dd>
</dl> <dl class="describe"> <dt>
<code>iter(g)</code> </dt> <dd>
<p>Return an iterator over the attribute names.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.ctx._AppCtxGlobals.get">
<code>get(name, default=None)</code> </dt> <dd>
<p>Get an attribute by name, or a default value. Like <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.get" title="(in Python v3.9)"><code>dict.get()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>name</strong> – Name of attribute to get.</li> <li>
<strong>default</strong> – Value to return if the attribute is not present.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.ctx._AppCtxGlobals.pop">
<code>pop(name, default=&lt;object object&gt;)</code> </dt> <dd>
<p>Get and remove an attribute by name. Like <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.pop" title="(in Python v3.9)"><code>dict.pop()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>name</strong> – Name of attribute to pop.</li> <li>
<strong>default</strong> – Value to return if the attribute is not present, instead of raise a <code>KeyError</code>.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.ctx._AppCtxGlobals.setdefault">
<code>setdefault(name, default=None)</code> </dt> <dd>
<p>Get the value of an attribute if it is present, otherwise set and return a default value. Like <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" title="(in Python v3.9)"><code>dict.setdefault()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> – Name of attribute to get.</p> </dd> <dt class="field-even">Param</dt> <dd class="field-even">
<p>default: Value to set and return if the attribute is not present.</p> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> </dd>
</dl>   <h2 id="useful-functions-and-classes">Useful Functions and Classes</h2> <dl class="data"> <dt id="flask.current_app">
<code>flask.current_app</code> </dt> <dd>
<p>A proxy to the application handling the current request. This is useful to access the application without needing to import it, or if it can’t be imported, such as when using the application factory pattern or in blueprints and extensions.</p> <p>This is only available when an <a class="reference internal" href="../appcontext/index"><span class="doc">application context</span></a> is pushed. This happens automatically during requests and CLI commands. It can be controlled manually with <a class="reference internal" href="#flask.Flask.app_context" title="flask.Flask.app_context"><code>app_context()</code></a>.</p> <p>This is a proxy. See <a class="reference internal" href="../reqcontext/index#notes-on-proxies"><span class="std std-ref">Notes On Proxies</span></a> for more information.</p> </dd>
</dl> <dl class="function"> <dt id="flask.has_request_context">
<code>flask.has_request_context()</code> </dt> <dd>
<p>If you have code that wants to test if a request context is there or not this function can be used. For instance, you may want to take advantage of request information if the request object is available, but fail silently if it is unavailable.</p> <pre data-language="python">class User(db.Model):

    def __init__(self, username, remote_addr=None):
        self.username = username
        if remote_addr is None and has_request_context():
            remote_addr = request.remote_addr
        self.remote_addr = remote_addr
</pre> <p>Alternatively you can also just test any of the context bound objects (such as <a class="reference internal" href="#flask.request" title="flask.request"><code>request</code></a> or <a class="reference internal" href="#flask.g" title="flask.g"><code>g</code></a>) for truthness:</p> <pre data-language="python">class User(db.Model):

    def __init__(self, username, remote_addr=None):
        self.username = username
        if remote_addr is None and request:
            remote_addr = request.remote_addr
        self.remote_addr = remote_addr
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="flask.copy_current_request_context">
<code>flask.copy_current_request_context(f)</code> </dt> <dd>
<p>A helper function that decorates a function to retain the current request context. This is useful when working with greenlets. The moment the function is decorated a copy of the request context is created and then pushed when the function is called. The current session is also included in the copied request context.</p> <p>Example:</p> <pre data-language="python">import gevent
from flask import copy_current_request_context

@app.route('/')
def index():
    @copy_current_request_context
    def do_some_work():
        # do some work here, it can access flask.request or
        # flask.session like you would otherwise in the view function.
        ...
    gevent.spawn(do_some_work)
    return 'Regular response'
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="flask.has_app_context">
<code>flask.has_app_context()</code> </dt> <dd>
<p>Works like <a class="reference internal" href="#flask.has_request_context" title="flask.has_request_context"><code>has_request_context()</code></a> but for the application context. You can also just do a boolean check on the <a class="reference internal" href="#flask.current_app" title="flask.current_app"><code>current_app</code></a> object instead.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="flask.url_for">
<code>flask.url_for(endpoint, **values)</code> </dt> <dd>
<p>Generates a URL to the given endpoint with the method provided.</p> <p>Variable arguments that are unknown to the target endpoint are appended to the generated URL as query arguments. If the value of a query argument is <code>None</code>, the whole pair is skipped. In case blueprints are active you can shortcut references to the same blueprint by prefixing the local endpoint with a dot (<code>.</code>).</p> <p>This will reference the index function local to the current blueprint:</p> <pre data-language="python">url_for('.index')
</pre> <p>For more information, head over to the <a class="reference internal" href="../quickstart/index#url-building"><span class="std std-ref">Quickstart</span></a>.</p> <p>Configuration values <code>APPLICATION_ROOT</code> and <code>SERVER_NAME</code> are only used when generating URLs outside of a request context.</p> <p>To integrate applications, <a class="reference internal" href="#flask.Flask" title="flask.Flask"><code>Flask</code></a> has a hook to intercept URL build errors through <a class="reference internal" href="#flask.Flask.url_build_error_handlers" title="flask.Flask.url_build_error_handlers"><code>Flask.url_build_error_handlers</code></a>. The <code>url_for</code> function results in a <code>BuildError</code> when the current app does not have a URL for the given endpoint and values. When it does, the <a class="reference internal" href="#flask.current_app" title="flask.current_app"><code>current_app</code></a> calls its <a class="reference internal" href="#flask.Flask.url_build_error_handlers" title="flask.Flask.url_build_error_handlers"><code>url_build_error_handlers</code></a> if it is not <code>None</code>, which can return a string to use as the result of <code>url_for</code> (instead of <code>url_for</code>’s default to raise the <code>BuildError</code> exception) or re-raise the exception. An example:</p> <pre data-language="python">def external_url_handler(error, endpoint, values):
    "Looks up an external URL when `url_for` cannot build a URL."
    # This is an example of hooking the build_error_handler.
    # Here, lookup_url is some utility function you've built
    # which looks up the endpoint in some external URL registry.
    url = lookup_url(endpoint, **values)
    if url is None:
        # External lookup did not have a URL.
        # Re-raise the BuildError, in context of original traceback.
        exc_type, exc_value, tb = sys.exc_info()
        if exc_value is error:
            raise exc_type, exc_value, tb
        else:
            raise error
    # url_for will use this result, instead of raising BuildError.
    return url

app.url_build_error_handlers.append(external_url_handler)
</pre> <p>Here, <code>error</code> is the instance of <code>BuildError</code>, and <code>endpoint</code> and <code>values</code> are the arguments passed into <code>url_for</code>. Note that this is for building URLs outside the current application, and not for handling 404 NotFound errors.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10: </span>The <code>_scheme</code> parameter was added.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.9: </span>The <code>_anchor</code> and <code>_method</code> parameters were added.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.9: </span>Calls <code>Flask.handle_build_error()</code> on <code>BuildError</code>.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>endpoint</strong> – the endpoint of the URL (name of the function)</li> <li>
<strong>values</strong> – the variable arguments of the URL rule</li> <li>
<strong>_external</strong> – if set to <code>True</code>, an absolute URL is generated. Server address can be changed via <code>SERVER_NAME</code> configuration variable which falls back to the <code>Host</code> header, then to the IP and port of the request.</li> <li>
<strong>_scheme</strong> – a string specifying the desired URL scheme. The <code>_external</code> parameter must be set to <code>True</code> or a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><code>ValueError</code></a> is raised. The default behavior uses the same scheme as the current request, or <code>PREFERRED_URL_SCHEME</code> from the <a class="reference internal" href="../config/index#config"><span class="std std-ref">app configuration</span></a> if no request context is available. As of Werkzeug 0.10, this also can be set to an empty string to build protocol-relative URLs.</li> <li>
<strong>_anchor</strong> – if provided this is added as anchor to the URL.</li> <li>
<strong>_method</strong> – if provided this explicitly specifies an HTTP method.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="flask.abort">
<code>flask.abort(status, *args, **kwargs)</code> </dt> <dd>
<p>Raises an <code>HTTPException</code> for the given status code or WSGI application.</p> <p>If a status code is given, it will be looked up in the list of exceptions and will raise that exception. If passed a WSGI application, it will wrap it in a proxy WSGI exception and raise that:</p> <pre data-language="python">abort(404)  # 404 Not Found
abort(Response('Hello World'))
</pre> </dd>
</dl> <dl class="function"> <dt id="flask.redirect">
<code>flask.redirect(location, code=302, Response=None)</code> </dt> <dd>
<p>Returns a response object (a WSGI application) that, if called, redirects the client to the target location. Supported codes are 301, 302, 303, 305, 307, and 308. 300 is not supported because it’s not a real redirect and 304 because it’s the answer for a request with a request with defined If-Modified-Since headers.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10: </span>The class used for the Response object can now be passed in.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.6: </span>The location can now be a unicode string that is encoded using the <code>iri_to_uri()</code> function.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>location</strong> – the location the response should redirect to.</li> <li>
<strong>code</strong> – the redirect status code. defaults to 302.</li> <li>
<strong>Response</strong> (<em>class</em>) – a Response class to use when instantiating a response. The default is <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.Response" title="(in Werkzeug v1.0.x)"><code>werkzeug.wrappers.Response</code></a> if unspecified.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="flask.make_response">
<code>flask.make_response(*args)</code> </dt> <dd>
<p>Sometimes it is necessary to set additional headers in a view. Because views do not have to return response objects but can return a value that is converted into a response object by Flask itself, it becomes tricky to add headers to it. This function can be called instead of using a return and you will get a response object which you can use to attach headers.</p> <p>If view looked like this and you want to add a new header:</p> <pre data-language="python">def index():
    return render_template('index.html', foo=42)
</pre> <p>You can now do something like this:</p> <pre data-language="python">def index():
    response = make_response(render_template('index.html', foo=42))
    response.headers['X-Parachutes'] = 'parachutes are cool'
    return response
</pre> <p>This function accepts the very same arguments you can return from a view function. This for example creates a response with a 404 error code:</p> <pre data-language="python">response = make_response(render_template('not_found.html'), 404)
</pre> <p>The other use case of this function is to force the return value of a view function into a response which is helpful with view decorators:</p> <pre data-language="python">response = make_response(view_function())
response.headers['X-Parachutes'] = 'parachutes are cool'
</pre> <p>Internally this function does the following things:</p> <ul class="simple"> <li>if no arguments are passed, it creates a new response argument</li> <li>if one argument is passed, <a class="reference internal" href="#flask.Flask.make_response" title="flask.Flask.make_response"><code>flask.Flask.make_response()</code></a> is invoked with it.</li> <li>if more than one argument is passed, the arguments are passed to the <a class="reference internal" href="#flask.Flask.make_response" title="flask.Flask.make_response"><code>flask.Flask.make_response()</code></a> function as tuple.</li> </ul> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="flask.after_this_request">
<code>flask.after_this_request(f)</code> </dt> <dd>
<p>Executes a function after this request. This is useful to modify response objects. The function is passed the response object and has to return the same or a new one.</p> <p>Example:</p> <pre data-language="python">@app.route('/')
def index():
    @after_this_request
    def add_header(response):
        response.headers['X-Foo'] = 'Parachute'
        return response
    return 'Hello World!'
</pre> <p>This is more useful if a function other than the view function wants to modify a response. For instance think of a decorator that wants to add some headers without converting the return value into a response object.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="flask.send_file">
<code>flask.send_file(filename_or_fp, mimetype=None, as_attachment=False, attachment_filename=None, add_etags=True, cache_timeout=None, conditional=False, last_modified=None)</code> </dt> <dd>
<p>Sends the contents of a file to the client. This will use the most efficient method available and configured. By default it will try to use the WSGI server’s file_wrapper support. Alternatively you can set the application’s <a class="reference internal" href="#flask.Flask.use_x_sendfile" title="flask.Flask.use_x_sendfile"><code>use_x_sendfile</code></a> attribute to <code>True</code> to directly emit an <code>X-Sendfile</code> header. This however requires support of the underlying webserver for <code>X-Sendfile</code>.</p> <p>By default it will try to guess the mimetype for you, but you can also explicitly provide one. For extra security you probably want to send certain files as attachment (HTML for instance). The mimetype guessing requires a <code>filename</code> or an <code>attachment_filename</code> to be provided.</p> <p>ETags will also be attached automatically if a <code>filename</code> is provided. You can turn this off by setting <code>add_etags=False</code>.</p> <p>If <code>conditional=True</code> and <code>filename</code> is provided, this method will try to upgrade the response stream to support range requests. This will allow the request to be answered with partial content response.</p> <p>Please never pass filenames to this function from user sources; you should use <a class="reference internal" href="#flask.send_from_directory" title="flask.send_from_directory"><code>send_from_directory()</code></a> instead.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>UTF-8 filenames, as specified in <a class="reference external" href="https://tools.ietf.org/html/rfc2231#section-4">RFC 2231</a>, are supported.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.12: </span>The filename is no longer automatically inferred from file objects. If you want to use automatic mimetype and etag support, pass a filepath via <code>filename_or_fp</code> or <code>attachment_filename</code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.12: </span>The <code>attachment_filename</code> is preferred over <code>filename</code> for MIME-type detection.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>cache_timeout pulls its default from application config, when None.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.7: </span>mimetype guessing and etag support for file objects was deprecated because it was unreliable. Pass a filename if you are able to, otherwise attach an etag yourself. This functionality will be removed in Flask 1.0</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.5: </span>The <code>add_etags</code>, <code>cache_timeout</code> and <code>conditional</code> parameters were added. The default behavior is now to attach etags.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.2.</span></p> </div> </details><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.1: </span>Filename may be a <a class="reference external" href="https://docs.python.org/3/library/os.html#os.PathLike" title="(in Python v3.9)"><code>PathLike</code></a> object.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1: </span>Partial content supports <a class="reference external" href="https://docs.python.org/3/library/io.html#io.BytesIO" title="(in Python v3.9)"><code>BytesIO</code></a>.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0.3: </span>Filenames are encoded with ASCII instead of Latin-1 for broader compatibility with WSGI servers.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>filename_or_fp</strong> – the filename of the file to send. This is relative to the <a class="reference internal" href="#flask.Flask.root_path" title="flask.Flask.root_path"><code>root_path</code></a> if a relative path is specified. Alternatively a file object might be provided in which case <code>X-Sendfile</code> might not work and fall back to the traditional method. Make sure that the file pointer is positioned at the start of data to send before calling <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a>.</li> <li>
<strong>mimetype</strong> – the mimetype of the file if provided. If a file path is given, auto detection happens as fallback, otherwise an error will be raised.</li> <li>
<strong>as_attachment</strong> – set to <code>True</code> if you want to send this file with a <code>Content-Disposition: attachment</code> header.</li> <li>
<strong>attachment_filename</strong> – the filename for the attachment if it differs from the file’s filename.</li> <li>
<strong>add_etags</strong> – set to <code>False</code> to disable attaching of etags.</li> <li>
<strong>conditional</strong> – set to <code>True</code> to enable conditional responses.</li> <li>
<strong>cache_timeout</strong> – the timeout in seconds for the headers. When <code>None</code> (default), this value is set by <a class="reference internal" href="#flask.Flask.get_send_file_max_age" title="flask.Flask.get_send_file_max_age"><code>get_send_file_max_age()</code></a> of <a class="reference internal" href="#flask.current_app" title="flask.current_app"><code>current_app</code></a>.</li> <li>
<strong>last_modified</strong> – set the <code>Last-Modified</code> header to this value, a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.9)"><code>datetime</code></a> or timestamp. If a file was passed, this overrides its mtime.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="flask.send_from_directory">
<code>flask.send_from_directory(directory, filename, **options)</code> </dt> <dd>
<p>Send a file from a given directory with <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a>. This is a secure way to quickly expose static files from an upload folder or something similar.</p> <p>Example usage:</p> <pre data-language="python">@app.route('/uploads/&lt;path:filename&gt;')
def download_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'],
                               filename, as_attachment=True)
</pre> <div class="admonition-sending-files-and-performance admonition"> <p class="admonition-title">Sending files and Performance</p> <p>It is strongly recommended to activate either <code>X-Sendfile</code> support in your webserver or (if no authentication happens) to tell the webserver to serve files for the given path on its own without calling into the web application for improved performance.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>directory</strong> – the directory where all the files are stored.</li> <li>
<strong>filename</strong> – the filename relative to that directory to download.</li> <li>
<strong>options</strong> – optional keyword arguments that are directly forwarded to <a class="reference internal" href="#flask.send_file" title="flask.send_file"><code>send_file()</code></a>.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="flask.safe_join">
<code>flask.safe_join(directory, *pathnames)</code> </dt> <dd>
<p>Safely join <code>directory</code> and zero or more untrusted <code>pathnames</code> components.</p> <p>Example usage:</p> <pre data-language="python">@app.route('/wiki/&lt;path:filename&gt;')
def wiki_page(filename):
    filename = safe_join(app.config['WIKI_FOLDER'], filename)
    with open(filename, 'rb') as fd:
        content = fd.read()  # Read and process the file content...
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>directory</strong> – the trusted base directory.</li> <li>
<strong>pathnames</strong> – the untrusted pathnames relative to that directory.</li> </ul> </dd> <dt class="field-even">Raises</dt> <dd class="field-even">
<p><a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.NotFound" title="(in Werkzeug v1.0.x)"><code>NotFound</code></a> if one or more passed paths fall out of its boundaries.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="flask.escape">
<code>flask.escape(s) → markup</code> </dt> <dd>
<p>Convert the characters &amp;, &lt;, &gt;, ‘, and ” in string s to HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. Marks return value as markup string.</p> </dd>
</dl> <dl class="class"> <dt id="flask.Markup">
<code>class flask.Markup</code> </dt> <dd>
<p>A string that is ready to be safely inserted into an HTML or XML document, either because it was escaped or because it was marked safe.</p> <p>Passing an object to the constructor converts it to text and wraps it to mark it safe without escaping. To escape the text, use the <a class="reference internal" href="#flask.escape" title="flask.escape"><code>escape()</code></a> class method instead.</p> <pre data-language="python">&gt;&gt;&gt; Markup('Hello, &lt;em&gt;World&lt;/em&gt;!')
Markup('Hello, &lt;em&gt;World&lt;/em&gt;!')
&gt;&gt;&gt; Markup(42)
Markup('42')
&gt;&gt;&gt; Markup.escape('Hello, &lt;em&gt;World&lt;/em&gt;!')
Markup('Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!')
</pre> <p>This implements the <code>__html__()</code> interface that some frameworks use. Passing an object that implements <code>__html__()</code> will wrap the output of that method, marking it safe.</p> <pre data-language="python">&gt;&gt;&gt; class Foo:
...     def __html__(self):
...         return '&lt;a href="/foo"&gt;foo&lt;/a&gt;'
...
&gt;&gt;&gt; Markup(Foo())
Markup('&lt;a href="/foo"&gt;foo&lt;/a&gt;')
</pre> <p>This is a subclass of the text type (<code>str</code> in Python 3, <code>unicode</code> in Python 2). It has the same methods as that type, but all methods escape their arguments and return a <code>Markup</code> instance.</p> <pre data-language="python">&gt;&gt;&gt; Markup('&lt;em&gt;%s&lt;/em&gt;') % 'foo &amp; bar'
Markup('&lt;em&gt;foo &amp;amp; bar&lt;/em&gt;')
&gt;&gt;&gt; Markup('&lt;em&gt;Hello&lt;/em&gt; ') + '&lt;foo&gt;'
Markup('&lt;em&gt;Hello&lt;/em&gt; &amp;lt;foo&amp;gt;')
</pre> <dl class="method"> <dt id="flask.Markup.escape">
<code>classmethod escape(s)</code> </dt> <dd>
<p>Escape a string. Calls <a class="reference internal" href="#flask.escape" title="flask.escape"><code>escape()</code></a> and ensures that for subclasses the correct type is returned.</p> </dd>
</dl> <dl class="method"> <dt id="flask.Markup.striptags">
<code>striptags()</code> </dt> <dd>
<p><a class="reference internal" href="#flask.Markup.unescape" title="flask.Markup.unescape"><code>unescape()</code></a> the markup, remove tags, and normalize whitespace to single spaces.</p> <pre data-language="python">&gt;&gt;&gt; Markup('Main &amp;raquo;        &lt;em&gt;About&lt;/em&gt;').striptags()
'Main » About'
</pre> </dd>
</dl> <dl class="method"> <dt id="flask.Markup.unescape">
<code>unescape()</code> </dt> <dd>
<p>Convert escaped markup back into a text string. This replaces HTML entities with the characters they represent.</p> <pre data-language="python">&gt;&gt;&gt; Markup('Main &amp;raquo; &lt;em&gt;About&lt;/em&gt;').unescape()
'Main » &lt;em&gt;About&lt;/em&gt;'
</pre> </dd>
</dl> </dd>
</dl>   <h2 id="message-flashing">Message Flashing</h2> <dl class="function"> <dt id="flask.flash">
<code>flask.flash(message, category='message')</code> </dt> <dd>
<p>Flashes a message to the next request. In order to remove the flashed message from the session and to display it to the user, the template has to call <a class="reference internal" href="#flask.get_flashed_messages" title="flask.get_flashed_messages"><code>get_flashed_messages()</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.3: </span><code>category</code> parameter added.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>message</strong> – the message to be flashed.</li> <li>
<strong>category</strong> – the category for the message. The following values are recommended: <code>'message'</code> for any kind of message, <code>'error'</code> for errors, <code>'info'</code> for information messages and <code>'warning'</code> for warnings. However any kind of string can be used as category.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="flask.get_flashed_messages">
<code>flask.get_flashed_messages(with_categories=False, category_filter=())</code> </dt> <dd>
<p>Pulls all flashed messages from the session and returns them. Further calls in the same request to the function will return the same messages. By default just the messages are returned, but when <code>with_categories</code> is set to <code>True</code>, the return value will be a list of tuples in the form <code>(category, message)</code> instead.</p> <p>Filter the flashed messages to one or more categories by providing those categories in <code>category_filter</code>. This allows rendering categories in separate html blocks. The <code>with_categories</code> and <code>category_filter</code> arguments are distinct:</p> <ul class="simple"> <li>
<code>with_categories</code> controls whether categories are returned with message text (<code>True</code> gives a tuple, where <code>False</code> gives just the message text).</li> <li>
<code>category_filter</code> filters the messages down to only those matching the provided categories.</li> </ul> <p>See <a class="reference internal" href="../patterns/flashing/index#message-flashing-pattern"><span class="std std-ref">Message Flashing</span></a> for examples.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span><code>category_filter</code> parameter added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.3: </span><code>with_categories</code> parameter added.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>with_categories</strong> – set to <code>True</code> to also receive categories.</li> <li>
<strong>category_filter</strong> – whitelist of categories to limit return values</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="json-support">JSON Support</h2> <p id="module-flask.json">Flask uses <code>simplejson</code> for the JSON implementation. Since simplejson is provided by both the standard library as well as extension, Flask will try simplejson first and then fall back to the stdlib json module. On top of that it will delegate access to the current application’s JSON encoders and decoders for easier customization.</p> <p>So for starters instead of doing:</p> <pre data-language="python">try:
    import simplejson as json
except ImportError:
    import json
</pre> <p>You can instead just do this:</p> <pre data-language="python">from flask import json
</pre> <p>For usage examples, read the <a class="reference external" href="https://docs.python.org/3/library/json.html#module-json" title="(in Python v3.9)"><code>json</code></a> documentation in the standard library. The following extensions are by default applied to the stdlib’s JSON module:</p> <ol class="arabic simple"> <li>
<code>datetime</code> objects are serialized as <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html" id="index-4"><strong>RFC 822</strong></a> strings.</li> <li>Any object with an <code>__html__</code> method (like <a class="reference internal" href="#flask.Markup" title="flask.Markup"><code>Markup</code></a>) will have that method called and then the return value is serialized as string.</li> </ol> <p>The <code>htmlsafe_dumps()</code> function of this json module is also available as a filter called <code>|tojson</code> in Jinja2. Note that in versions of Flask prior to Flask 0.10, you must disable escaping with <code>|safe</code> if you intend to use <code>|tojson</code> output inside <code>script</code> tags. In Flask 0.10 and above, this happens automatically (but it’s harmless to include <code>|safe</code> anyway).</p> <pre data-language="html">&lt;script type=text/javascript&gt;
    doSomethingWith({{ user.username|tojson|safe }});
&lt;/script&gt;
</pre> <div class="admonition-auto-sort-json-keys admonition"> <p class="admonition-title">Auto-Sort JSON Keys</p> <p>The configuration variable <code>JSON_SORT_KEYS</code> (<a class="reference internal" href="../config/index#config"><span class="std std-ref">Configuration Handling</span></a>) can be set to false to stop Flask from auto-sorting keys. By default sorting is enabled and outside of the app context sorting is turned on.</p> <p>Notice that disabling key sorting can cause issues when using content based HTTP caches and Python’s hash randomization feature.</p> </div> <dl class="function"> <dt id="flask.json.jsonify">
<code>flask.json.jsonify(*args, **kwargs)</code> </dt> <dd>
<p>This function wraps <a class="reference internal" href="#flask.json.dumps" title="flask.json.dumps"><code>dumps()</code></a> to add a few enhancements that make life easier. It turns the JSON output into a <a class="reference internal" href="#flask.Response" title="flask.Response"><code>Response</code></a> object with the <em class="mimetype">application/json</em> mimetype. For convenience, it also converts multiple arguments into an array or multiple keyword arguments into a dict. This means that both <code>jsonify(1,2,3)</code> and <code>jsonify([1,2,3])</code> serialize to <code>[1,2,3]</code>.</p> <p>For clarity, the JSON serialization behavior has the following differences from <a class="reference internal" href="#flask.json.dumps" title="flask.json.dumps"><code>dumps()</code></a>:</p> <ol class="arabic simple"> <li>Single argument: Passed straight through to <a class="reference internal" href="#flask.json.dumps" title="flask.json.dumps"><code>dumps()</code></a>.</li> <li>Multiple arguments: Converted to an array before being passed to <a class="reference internal" href="#flask.json.dumps" title="flask.json.dumps"><code>dumps()</code></a>.</li> <li>Multiple keyword arguments: Converted to a dict before being passed to <a class="reference internal" href="#flask.json.dumps" title="flask.json.dumps"><code>dumps()</code></a>.</li> <li>Both args and kwargs: Behavior undefined and will throw an exception.</li> </ol> <p>Example usage:</p> <pre data-language="python">from flask import jsonify

@app.route('/_get_current_user')
def get_current_user():
    return jsonify(username=g.user.username,
                   email=g.user.email,
                   id=g.user.id)
</pre> <p>This will send a JSON response like this to the browser:</p> <pre data-language="python">{
    "username": "admin",
    "email": "admin@localhost",
    "id": 42
}
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.11: </span>Added support for serializing top-level arrays. This introduces a security risk in ancient browsers. See <a class="reference internal" href="../security/index#json-security"><span class="std std-ref">JSON Security</span></a> for details.</p> </div> </details><p>This function’s response will be pretty printed if the <code>JSONIFY_PRETTYPRINT_REGULAR</code> config parameter is set to True or the Flask app is running in debug mode. Compressed (not pretty) formatting currently means no indents and no spaces after separators.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.2.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="flask.json.dumps">
<code>flask.json.dumps(obj, app=None, **kwargs)</code> </dt> <dd>
<p>Serialize <code>obj</code> to a JSON-formatted string. If there is an app context pushed, use the current app’s configured encoder (<a class="reference internal" href="#flask.Flask.json_encoder" title="flask.Flask.json_encoder"><code>json_encoder</code></a>), or fall back to the default <a class="reference internal" href="#flask.json.JSONEncoder" title="flask.json.JSONEncoder"><code>JSONEncoder</code></a>.</p> <p>Takes the same arguments as the built-in <a class="reference external" href="https://docs.python.org/3/library/json.html#json.dumps" title="(in Python v3.9)"><code>json.dumps()</code></a>, and does some extra configuration based on the application. If the simplejson package is installed, it is preferred.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>obj</strong> – Object to serialize to JSON.</li> <li>
<strong>app</strong> – App instance to use to configure the JSON encoder. Uses <code>current_app</code> if not given, and falls back to the default encoder when not in an app context.</li> <li>
<strong>kwargs</strong> – Extra arguments passed to <a class="reference external" href="https://docs.python.org/3/library/json.html#json.dumps" title="(in Python v3.9)"><code>json.dumps()</code></a>.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0.3: </span><code>app</code> can be passed directly, rather than requiring an app context for configuration.</p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="flask.json.dump">
<code>flask.json.dump(obj, fp, app=None, **kwargs)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.json.dumps" title="flask.json.dumps"><code>dumps()</code></a> but writes into a file object.</p> </dd>
</dl> <dl class="function"> <dt id="flask.json.loads">
<code>flask.json.loads(s, app=None, **kwargs)</code> </dt> <dd>
<p>Deserialize an object from a JSON-formatted string <code>s</code>. If there is an app context pushed, use the current app’s configured decoder (<a class="reference internal" href="#flask.Flask.json_decoder" title="flask.Flask.json_decoder"><code>json_decoder</code></a>), or fall back to the default <a class="reference internal" href="#flask.json.JSONDecoder" title="flask.json.JSONDecoder"><code>JSONDecoder</code></a>.</p> <p>Takes the same arguments as the built-in <a class="reference external" href="https://docs.python.org/3/library/json.html#json.loads" title="(in Python v3.9)"><code>json.loads()</code></a>, and does some extra configuration based on the application. If the simplejson package is installed, it is preferred.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>s</strong> – JSON string to deserialize.</li> <li>
<strong>app</strong> – App instance to use to configure the JSON decoder. Uses <code>current_app</code> if not given, and falls back to the default encoder when not in an app context.</li> <li>
<strong>kwargs</strong> – Extra arguments passed to <a class="reference external" href="https://docs.python.org/3/library/json.html#json.dumps" title="(in Python v3.9)"><code>json.dumps()</code></a>.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0.3: </span><code>app</code> can be passed directly, rather than requiring an app context for configuration.</p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="flask.json.load">
<code>flask.json.load(fp, app=None, **kwargs)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#flask.json.loads" title="flask.json.loads"><code>loads()</code></a> but reads from a file object.</p> </dd>
</dl> <dl class="class"> <dt id="flask.json.JSONEncoder">
<code>class flask.json.JSONEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)</code> </dt> <dd>
<p>The default Flask JSON encoder. This one extends the default encoder by also supporting <code>datetime</code>, <code>UUID</code>, <code>dataclasses</code>, and <code>Markup</code> objects.</p> <p><code>datetime</code> objects are serialized as RFC 822 datetime strings. This is the same as the HTTP date format.</p> <p>In order to support more data types, override the <a class="reference internal" href="#flask.json.JSONEncoder.default" title="flask.json.JSONEncoder.default"><code>default()</code></a> method.</p> <dl class="method"> <dt id="flask.json.JSONEncoder.default">
<code>default(o)</code> </dt> <dd>
<p>Implement this method in a subclass such that it returns a serializable object for <code>o</code>, or calls the base implementation (to raise a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.9)"><code>TypeError</code></a>).</p> <p>For example, to support arbitrary iterators, you could implement default like this:</p> <pre data-language="python">def default(self, o):
    try:
        iterable = iter(o)
    except TypeError:
        pass
    else:
        return list(iterable)
    return JSONEncoder.default(self, o)
</pre> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="flask.json.JSONDecoder">
<code>class flask.json.JSONDecoder(*, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True, object_pairs_hook=None)</code> </dt> <dd>
<p>The default JSON decoder. This one does not change the behavior from the default simplejson decoder. Consult the <a class="reference external" href="https://docs.python.org/3/library/json.html#module-json" title="(in Python v3.9)"><code>json</code></a> documentation for more information. This decoder is not only used for the load functions of this module but also <a class="reference internal" href="#flask.Request" title="flask.Request"><code>Request</code></a>.</p> </dd>
</dl>  <h3 id="tagged-json">Tagged JSON</h3> <p>A compact representation for lossless serialization of non-standard JSON types. <a class="reference internal" href="#flask.sessions.SecureCookieSessionInterface" title="flask.sessions.SecureCookieSessionInterface"><code>SecureCookieSessionInterface</code></a> uses this to serialize the session data, but it may be useful in other places. It can be extended to support other types.</p> <dl class="class"> <dt id="flask.json.tag.TaggedJSONSerializer">
<code>class flask.json.tag.TaggedJSONSerializer</code> </dt> <dd>
<p>Serializer that uses a tag system to compactly represent objects that are not JSON types. Passed as the intermediate serializer to <code>itsdangerous.Serializer</code>.</p> <p>The following extra types are supported:</p> <ul class="simple"> <li><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a></li> <li><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)"><code>tuple</code></a></li> <li><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.9)"><code>bytes</code></a></li> <li><a class="reference internal" href="#flask.Markup" title="flask.Markup"><code>Markup</code></a></li> <li><a class="reference external" href="https://docs.python.org/3/library/uuid.html#uuid.UUID" title="(in Python v3.9)"><code>UUID</code></a></li> <li><a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.9)"><code>datetime</code></a></li> </ul> <dl class="attribute"> <dt id="flask.json.tag.TaggedJSONSerializer.default_tags">
<code>default_tags = [&lt;class 'flask.json.tag.TagDict'&gt;, &lt;class 'flask.json.tag.PassDict'&gt;, &lt;class 'flask.json.tag.TagTuple'&gt;, &lt;class 'flask.json.tag.PassList'&gt;, &lt;class 'flask.json.tag.TagBytes'&gt;, &lt;class 'flask.json.tag.TagMarkup'&gt;, &lt;class 'flask.json.tag.TagUUID'&gt;, &lt;class 'flask.json.tag.TagDateTime'&gt;]</code> </dt> <dd>
<p>Tag classes to bind when creating the serializer. Other tags can be added later using <a class="reference internal" href="#flask.json.tag.TaggedJSONSerializer.register" title="flask.json.tag.TaggedJSONSerializer.register"><code>register()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.json.tag.TaggedJSONSerializer.dumps">
<code>dumps(value)</code> </dt> <dd>
<p>Tag the value and dump it to a compact JSON string.</p> </dd>
</dl> <dl class="method"> <dt id="flask.json.tag.TaggedJSONSerializer.loads">
<code>loads(value)</code> </dt> <dd>
<p>Load data from a JSON string and deserialized any tagged objects.</p> </dd>
</dl> <dl class="method"> <dt id="flask.json.tag.TaggedJSONSerializer.register">
<code>register(tag_class, force=False, index=None)</code> </dt> <dd>
<p>Register a new tag with this serializer.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>tag_class</strong> – tag class to register. Will be instantiated with this serializer instance.</li> <li>
<strong>force</strong> – overwrite an existing tag. If false (default), a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.9)"><code>KeyError</code></a> is raised.</li> <li>
<strong>index</strong> – index to insert the new tag in the tag order. Useful when the new tag is a special case of an existing tag. If <code>None</code> (default), the tag is appended to the end of the order.</li> </ul> </dd> <dt class="field-even">Raises</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.9)"><strong>KeyError</strong></a> – if the tag key is already registered and <code>force</code> is not true.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.json.tag.TaggedJSONSerializer.tag">
<code>tag(value)</code> </dt> <dd>
<p>Convert a value to a tagged representation if necessary.</p> </dd>
</dl> <dl class="method"> <dt id="flask.json.tag.TaggedJSONSerializer.untag">
<code>untag(value)</code> </dt> <dd>
<p>Convert a tagged representation back to the original type.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="flask.json.tag.JSONTag">
<code>class flask.json.tag.JSONTag(serializer)</code> </dt> <dd>
<p>Base class for defining type tags for <a class="reference internal" href="#flask.json.tag.TaggedJSONSerializer" title="flask.json.tag.TaggedJSONSerializer"><code>TaggedJSONSerializer</code></a>.</p> <dl class="method"> <dt id="flask.json.tag.JSONTag.check">
<code>check(value)</code> </dt> <dd>
<p>Check if the given value should be tagged by this tag.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.json.tag.JSONTag.key">
<code>key = None</code> </dt> <dd>
<p>The tag to mark the serialized object with. If <code>None</code>, this tag is only used as an intermediate step during tagging.</p> </dd>
</dl> <dl class="method"> <dt id="flask.json.tag.JSONTag.tag">
<code>tag(value)</code> </dt> <dd>
<p>Convert the value to a valid JSON type and add the tag structure around it.</p> </dd>
</dl> <dl class="method"> <dt id="flask.json.tag.JSONTag.to_json">
<code>to_json(value)</code> </dt> <dd>
<p>Convert the Python object to an object that is a valid JSON type. The tag will be added later.</p> </dd>
</dl> <dl class="method"> <dt id="flask.json.tag.JSONTag.to_python">
<code>to_python(value)</code> </dt> <dd>
<p>Convert the JSON representation back to the correct type. The tag will already be removed.</p> </dd>
</dl> </dd>
</dl> <p>Let’s seen an example that adds support for <a class="reference external" href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" title="(in Python v3.9)"><code>OrderedDict</code></a>. Dicts don’t have an order in Python or JSON, so to handle this we will dump the items as a list of <code>[key, value]</code> pairs. Subclass <a class="reference internal" href="#flask.json.tag.JSONTag" title="flask.json.tag.JSONTag"><code>JSONTag</code></a> and give it the new key <code>' od'</code> to identify the type. The session serializer processes dicts first, so insert the new tag at the front of the order since <code>OrderedDict</code> must be processed before <code>dict</code>.</p> <pre data-language="python">from flask.json.tag import JSONTag

class TagOrderedDict(JSONTag):
    __slots__ = ('serializer',)
    key = ' od'

    def check(self, value):
        return isinstance(value, OrderedDict)

    def to_json(self, value):
        return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]

    def to_python(self, value):
        return OrderedDict(value)

app.session_interface.serializer.register(TagOrderedDict, index=0)
</pre>    <h2 id="template-rendering">Template Rendering</h2> <dl class="function"> <dt id="flask.render_template">
<code>flask.render_template(template_name_or_list, **context)</code> </dt> <dd>
<p>Renders a template from the template folder with the given context.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>template_name_or_list</strong> – the name of the template to be rendered, or an iterable with template names the first one existing will be rendered</li> <li>
<strong>context</strong> – the variables that should be available in the context of the template.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="flask.render_template_string">
<code>flask.render_template_string(source, **context)</code> </dt> <dd>
<p>Renders a template from the given template source string with the given context. Template variables will be autoescaped.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>source</strong> – the source code of the template to be rendered</li> <li>
<strong>context</strong> – the variables that should be available in the context of the template.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="flask.get_template_attribute">
<code>flask.get_template_attribute(template_name, attribute)</code> </dt> <dd>
<p>Loads a macro (or variable) a template exports. This can be used to invoke a macro from within Python code. If you for example have a template named <code>_cider.html</code> with the following contents:</p> <pre data-language="html">{% macro hello(name) %}Hello {{ name }}!{% endmacro %}
</pre> <p>You can access this from Python code like this:</p> <pre data-language="python">hello = get_template_attribute('_cider.html', 'hello')
return hello('World')
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.2.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>template_name</strong> – the name of the template</li> <li>
<strong>attribute</strong> – the name of the variable of macro to access</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="configuration">Configuration</h2> <dl class="class"> <dt id="flask.Config">
<code>class flask.Config(root_path, defaults=None)</code> </dt> <dd>
<p>Works exactly like a dict but provides ways to fill it from files or special dictionaries. There are two common patterns to populate the config.</p> <p>Either you can fill the config from a config file:</p> <pre data-language="python">app.config.from_pyfile('yourconfig.cfg')
</pre> <p>Or alternatively you can define the configuration options in the module that calls <a class="reference internal" href="#flask.Config.from_object" title="flask.Config.from_object"><code>from_object()</code></a> or provide an import path to a module that should be loaded. It is also possible to tell it to use the same module and with that provide the configuration values just before the call:</p> <pre data-language="python">DEBUG = True
SECRET_KEY = 'development key'
app.config.from_object(__name__)
</pre> <p>In both cases (loading from any Python file or loading from modules), only uppercase keys are added to the config. This makes it possible to use lowercase values in the config file for temporary values that are not added to the config or to define the config keys in the same file that implements the application.</p> <p>Probably the most interesting way to load configurations is from an environment variable pointing to a file:</p> <pre data-language="python">app.config.from_envvar('YOURAPPLICATION_SETTINGS')
</pre> <p>In this case before launching the application you have to set this environment variable to the file you want to use. On Linux and OS X use the export statement:</p> <pre data-language="python">export YOURAPPLICATION_SETTINGS='/path/to/config/file'
</pre> <p>On windows use <code>set</code> instead.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>root_path</strong> – path to which files are read relative from. When the config object is created by the application, this is the application’s <a class="reference internal" href="#flask.Flask.root_path" title="flask.Flask.root_path"><code>root_path</code></a>.</li> <li>
<strong>defaults</strong> – an optional dictionary of default values</li> </ul> </dd> </dl> <dl class="method"> <dt id="flask.Config.from_envvar">
<code>from_envvar(variable_name, silent=False)</code> </dt> <dd>
<p>Loads a configuration from an environment variable pointing to a configuration file. This is basically just a shortcut with nicer error messages for this line of code:</p> <pre data-language="python">app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>variable_name</strong> – name of the environment variable</li> <li>
<strong>silent</strong> – set to <code>True</code> if you want silent failure for missing files.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>bool. <code>True</code> if able to load config, <code>False</code> otherwise.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Config.from_json">
<code>from_json(filename, silent=False)</code> </dt> <dd>
<p>Updates the values in the config from a JSON file. This function behaves as if the JSON object was a dictionary and passed to the <a class="reference internal" href="#flask.Config.from_mapping" title="flask.Config.from_mapping"><code>from_mapping()</code></a> function.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>filename</strong> – the filename of the JSON file. This can either be an absolute filename or a filename relative to the root path.</li> <li>
<strong>silent</strong> – set to <code>True</code> if you want silent failure for missing files.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Config.from_mapping">
<code>from_mapping(*mapping, **kwargs)</code> </dt> <dd>
<p>Updates the config like <code>update()</code> ignoring items with non-upper keys.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Config.from_object">
<code>from_object(obj)</code> </dt> <dd>
<p>Updates the values from the given object. An object can be of one of the following two types:</p> <ul class="simple"> <li>a string: in this case the object with that name will be imported</li> <li>an actual object reference: that object is used directly</li> </ul> <p>Objects are usually either modules or classes. <a class="reference internal" href="#flask.Config.from_object" title="flask.Config.from_object"><code>from_object()</code></a> loads only the uppercase attributes of the module/class. A <code>dict</code> object will not work with <a class="reference internal" href="#flask.Config.from_object" title="flask.Config.from_object"><code>from_object()</code></a> because the keys of a <code>dict</code> are not attributes of the <code>dict</code> class.</p> <p>Example of module-based configuration:</p> <pre data-language="python">app.config.from_object('yourapplication.default_config')
from yourapplication import default_config
app.config.from_object(default_config)
</pre> <p>Nothing is done to the object before loading. If the object is a class and has <code>@property</code> attributes, it needs to be instantiated before being passed to this method.</p> <p>You should not use this function to load the actual configuration but rather configuration defaults. The actual config should be loaded with <a class="reference internal" href="#flask.Config.from_pyfile" title="flask.Config.from_pyfile"><code>from_pyfile()</code></a> and ideally from a location not within the package because the package might be installed system wide.</p> <p>See <a class="reference internal" href="../config/index#config-dev-prod"><span class="std std-ref">Development / Production</span></a> for an example of class-based configuration using <a class="reference internal" href="#flask.Config.from_object" title="flask.Config.from_object"><code>from_object()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>obj</strong> – an import name or object</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="flask.Config.from_pyfile">
<code>from_pyfile(filename, silent=False)</code> </dt> <dd>
<p>Updates the values in the config from a Python file. This function behaves as if the file was imported as module with the <a class="reference internal" href="#flask.Config.from_object" title="flask.Config.from_object"><code>from_object()</code></a> function.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>filename</strong> – the filename of the config. This can either be an absolute filename or a filename relative to the root path.</li> <li>
<strong>silent</strong> – set to <code>True</code> if you want silent failure for missing files.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7: </span><code>silent</code> parameter.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.Config.get_namespace">
<code>get_namespace(namespace, lowercase=True, trim_namespace=True)</code> </dt> <dd>
<p>Returns a dictionary containing a subset of configuration options that match the specified namespace/prefix. Example usage:</p> <pre data-language="python">app.config['IMAGE_STORE_TYPE'] = 'fs'
app.config['IMAGE_STORE_PATH'] = '/var/app/images'
app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'
image_store_config = app.config.get_namespace('IMAGE_STORE_')
</pre> <p>The resulting dictionary <code>image_store_config</code> would look like:</p> <pre data-language="python">{
    'type': 'fs',
    'path': '/var/app/images',
    'base_url': 'http://img.website.com'
}
</pre> <p>This is often useful when configuration options map directly to keyword arguments in functions or class constructors.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>namespace</strong> – a configuration namespace</li> <li>
<strong>lowercase</strong> – a flag indicating if the keys of the resulting dictionary should be lowercase</li> <li>
<strong>trim_namespace</strong> – a flag indicating if the keys of the resulting dictionary should not include the namespace</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.11.</span></p> </div> </details>
</dd>
</dl> </dd>
</dl>   <h2 id="stream-helpers">Stream Helpers</h2> <dl class="function"> <dt id="flask.stream_with_context">
<code>flask.stream_with_context(generator_or_function)</code> </dt> <dd>
<p>Request contexts disappear when the response is started on the server. This is done for efficiency reasons and to make it less likely to encounter memory leaks with badly written WSGI middlewares. The downside is that if you are using streamed responses, the generator cannot access request bound information any more.</p> <p>This function however can help you keep the context around for longer:</p> <pre data-language="python">from flask import stream_with_context, request, Response

@app.route('/stream')
def streamed_response():
    @stream_with_context
    def generate():
        yield 'Hello '
        yield request.args['name']
        yield '!'
    return Response(generate())
</pre> <p>Alternatively it can also be used around a specific generator:</p> <pre data-language="python">from flask import stream_with_context, request, Response

@app.route('/stream')
def streamed_response():
    def generate():
        yield 'Hello '
        yield request.args['name']
        yield '!'
    return Response(stream_with_context(generate()))
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl>   <h2 id="useful-internals">Useful Internals</h2> <dl class="class"> <dt id="flask.ctx.RequestContext">
<code>class flask.ctx.RequestContext(app, environ, request=None, session=None)</code> </dt> <dd>
<p>The request context contains all request relevant information. It is created at the beginning of the request and pushed to the <code>_request_ctx_stack</code> and removed at the end of it. It will create the URL adapter and request object for the WSGI environment provided.</p> <p>Do not attempt to use this class directly, instead use <a class="reference internal" href="#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code>test_request_context()</code></a> and <a class="reference internal" href="#flask.Flask.request_context" title="flask.Flask.request_context"><code>request_context()</code></a> to create this object.</p> <p>When the request context is popped, it will evaluate all the functions registered on the application for teardown execution (<a class="reference internal" href="#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><code>teardown_request()</code></a>).</p> <p>The request context is automatically popped at the end of the request for you. In debug mode the request context is kept around if exceptions happen so that interactive debuggers have a chance to introspect the data. With 0.4 this can also be forced for requests that did not fail and outside of <code>DEBUG</code> mode. By setting <code>'flask._preserve_context'</code> to <code>True</code> on the WSGI environment the context will not pop itself at the end of the request. This is used by the <a class="reference internal" href="#flask.Flask.test_client" title="flask.Flask.test_client"><code>test_client()</code></a> for example to implement the deferred cleanup functionality.</p> <p>You might find this helpful for unittests where you need the information from the context local around for a little longer. Make sure to properly <code>pop()</code> the stack yourself in that situation, otherwise your unittests will leak memory.</p> <dl class="method"> <dt id="flask.ctx.RequestContext.copy">
<code>copy()</code> </dt> <dd>
<p>Creates a copy of this request context with the same request object. This can be used to move a request context to a different greenlet. Because the actual request object is the same this cannot be used to move a request context to a different thread unless access to the request object is locked.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.1: </span>The current session object is used instead of reloading the original data. This prevents <code>flask.session</code> pointing to an out-of-date object.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.ctx.RequestContext.match_request">
<code>match_request()</code> </dt> <dd>
<p>Can be overridden by a subclass to hook into the matching of the request.</p> </dd>
</dl> <dl class="method"> <dt id="flask.ctx.RequestContext.pop">
<code>pop(exc=&lt;object object&gt;)</code> </dt> <dd>
<p>Pops the request context and unbinds it by doing that. This will also trigger the execution of functions registered by the <a class="reference internal" href="#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><code>teardown_request()</code></a> decorator.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>Added the <code>exc</code> argument.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.ctx.RequestContext.push">
<code>push()</code> </dt> <dd>
<p>Binds the request context to the current context.</p> </dd>
</dl> </dd>
</dl> <dl class="data"> <dt id="flask._request_ctx_stack">
<code>flask._request_ctx_stack</code> </dt> <dd>
<p>The internal <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalStack" title="(in Werkzeug v1.0.x)"><code>LocalStack</code></a> that holds <a class="reference internal" href="#flask.ctx.RequestContext" title="flask.ctx.RequestContext"><code>RequestContext</code></a> instances. Typically, the <a class="reference internal" href="#flask.request" title="flask.request"><code>request</code></a> and <a class="reference internal" href="#flask.session" title="flask.session"><code>session</code></a> proxies should be accessed instead of the stack. It may be useful to access the stack in extension code.</p> <p>The following attributes are always present on each layer of the stack:</p> <dl class="simple"> <dt>
<code>app</code> </dt>
<dd>
<p>the active Flask application.</p> </dd> <dt>
<code>url_adapter</code> </dt>
<dd>
<p>the URL adapter that was used to match the request.</p> </dd> <dt>
<code>request</code> </dt>
<dd>
<p>the current request object.</p> </dd> <dt>
<code>session</code> </dt>
<dd>
<p>the active session object.</p> </dd> <dt>
<code>g</code> </dt>
<dd>
<p>an object with all the attributes of the <a class="reference internal" href="#flask.g" title="flask.g"><code>flask.g</code></a> object.</p> </dd> <dt>
<code>flashes</code> </dt>
<dd>
<p>an internal cache for the flashed messages.</p> </dd> </dl> <p>Example usage:</p> <pre data-language="python">from flask import _request_ctx_stack

def get_session():
    ctx = _request_ctx_stack.top
    if ctx is not None:
        return ctx.session
</pre> </dd>
</dl> <dl class="class"> <dt id="flask.ctx.AppContext">
<code>class flask.ctx.AppContext(app)</code> </dt> <dd>
<p>The application context binds an application object implicitly to the current thread or greenlet, similar to how the <a class="reference internal" href="#flask.ctx.RequestContext" title="flask.ctx.RequestContext"><code>RequestContext</code></a> binds request information. The application context is also implicitly created if a request context is created but the application is not on top of the individual application context.</p> <dl class="method"> <dt id="flask.ctx.AppContext.pop">
<code>pop(exc=&lt;object object&gt;)</code> </dt> <dd>
<p>Pops the app context.</p> </dd>
</dl> <dl class="method"> <dt id="flask.ctx.AppContext.push">
<code>push()</code> </dt> <dd>
<p>Binds the app context to the current context.</p> </dd>
</dl> </dd>
</dl> <dl class="data"> <dt id="flask._app_ctx_stack">
<code>flask._app_ctx_stack</code> </dt> <dd>
<p>The internal <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalStack" title="(in Werkzeug v1.0.x)"><code>LocalStack</code></a> that holds <a class="reference internal" href="#flask.ctx.AppContext" title="flask.ctx.AppContext"><code>AppContext</code></a> instances. Typically, the <a class="reference internal" href="#flask.current_app" title="flask.current_app"><code>current_app</code></a> and <a class="reference internal" href="#flask.g" title="flask.g"><code>g</code></a> proxies should be accessed instead of the stack. Extensions can access the contexts on the stack as a namespace to store data.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="class"> <dt id="flask.blueprints.BlueprintSetupState">
<code>class flask.blueprints.BlueprintSetupState(blueprint, app, options, first_registration)</code> </dt> <dd>
<p>Temporary holder object for registering a blueprint with the application. An instance of this class is created by the <a class="reference internal" href="#flask.Blueprint.make_setup_state" title="flask.Blueprint.make_setup_state"><code>make_setup_state()</code></a> method and later passed to all register callback functions.</p> <dl class="method"> <dt id="flask.blueprints.BlueprintSetupState.add_url_rule">
<code>add_url_rule(rule, endpoint=None, view_func=None, **options)</code> </dt> <dd>
<p>A helper method to register a rule (and optionally a view function) to the application. The endpoint is automatically prefixed with the blueprint’s name.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.blueprints.BlueprintSetupState.app">
<code>app = None</code> </dt> <dd>
<p>a reference to the current application</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.blueprints.BlueprintSetupState.blueprint">
<code>blueprint = None</code> </dt> <dd>
<p>a reference to the blueprint that created this setup state.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.blueprints.BlueprintSetupState.first_registration">
<code>first_registration = None</code> </dt> <dd>
<p>as blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.blueprints.BlueprintSetupState.options">
<code>options = None</code> </dt> <dd>
<p>a dictionary with all options that were passed to the <a class="reference internal" href="#flask.Flask.register_blueprint" title="flask.Flask.register_blueprint"><code>register_blueprint()</code></a> method.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.blueprints.BlueprintSetupState.subdomain">
<code>subdomain = None</code> </dt> <dd>
<p>The subdomain that the blueprint should be active for, <code>None</code> otherwise.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.blueprints.BlueprintSetupState.url_defaults">
<code>url_defaults = None</code> </dt> <dd>
<p>A dictionary with URL defaults that is added to each and every URL that was defined with the blueprint.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.blueprints.BlueprintSetupState.url_prefix">
<code>url_prefix = None</code> </dt> <dd>
<p>The prefix that should be used for all URLs defined on the blueprint.</p> </dd>
</dl> </dd>
</dl>   <h2 id="core-signals-list">Signals</h2> <details class="changelog" id="signals"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details><dl class="data"> <dt id="flask.signals.signals_available">
<code>signals.signals_available</code> </dt> <dd>
<p><code>True</code> if the signaling system is available. This is the case when <a class="reference external" href="https://pypi.org/project/blinker/">blinker</a> is installed.</p> </dd>
</dl> <p>The following signals exist in Flask:</p> <dl class="data"> <dt id="flask.template_rendered">
<code>flask.template_rendered</code> </dt> <dd>
<p>This signal is sent when a template was successfully rendered. The signal is invoked with the instance of the template as <code>template</code> and the context as dictionary (named <code>context</code>).</p> <p>Example subscriber:</p> <pre data-language="python">def log_template_renders(sender, template, context, **extra):
    sender.logger.debug('Rendering template "%s" with context %s',
                        template.name or 'string template',
                        context)

from flask import template_rendered
template_rendered.connect(log_template_renders, app)
</pre> </dd>
</dl> <dl class="data"> <dt>
<code>flask.before_render_template</code> </dt> <dd>
<p>This signal is sent before template rendering process. The signal is invoked with the instance of the template as <code>template</code> and the context as dictionary (named <code>context</code>).</p> <p>Example subscriber:</p> <pre data-language="python">def log_template_renders(sender, template, context, **extra):
    sender.logger.debug('Rendering template "%s" with context %s',
                        template.name or 'string template',
                        context)

from flask import before_render_template
before_render_template.connect(log_template_renders, app)
</pre> </dd>
</dl> <dl class="data"> <dt id="flask.request_started">
<code>flask.request_started</code> </dt> <dd>
<p>This signal is sent when the request context is set up, before any request processing happens. Because the request context is already bound, the subscriber can access the request with the standard global proxies such as <a class="reference internal" href="#flask.request" title="flask.request"><code>request</code></a>.</p> <p>Example subscriber:</p> <pre data-language="python">def log_request(sender, **extra):
    sender.logger.debug('Request context is set up')

from flask import request_started
request_started.connect(log_request, app)
</pre> </dd>
</dl> <dl class="data"> <dt id="flask.request_finished">
<code>flask.request_finished</code> </dt> <dd>
<p>This signal is sent right before the response is sent to the client. It is passed the response to be sent named <code>response</code>.</p> <p>Example subscriber:</p> <pre data-language="python">def log_response(sender, response, **extra):
    sender.logger.debug('Request context is about to close down.  '
                        'Response: %s', response)

from flask import request_finished
request_finished.connect(log_response, app)
</pre> </dd>
</dl> <dl class="data"> <dt id="flask.got_request_exception">
<code>flask.got_request_exception</code> </dt> <dd>
<p>This signal is sent when an exception happens during request processing. It is sent <em>before</em> the standard exception handling kicks in and even in debug mode, where no exception handling happens. The exception itself is passed to the subscriber as <code>exception</code>.</p> <p>Example subscriber:</p> <pre data-language="python">def log_exception(sender, exception, **extra):
    sender.logger.debug('Got exception during processing: %s', exception)

from flask import got_request_exception
got_request_exception.connect(log_exception, app)
</pre> </dd>
</dl> <dl class="data"> <dt id="flask.request_tearing_down">
<code>flask.request_tearing_down</code> </dt> <dd>
<p>This signal is sent when the request is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on.</p> <p>Example subscriber:</p> <pre data-language="python">def close_db_connection(sender, **extra):
    session.close()

from flask import request_tearing_down
request_tearing_down.connect(close_db_connection, app)
</pre> <p>As of Flask 0.9, this will also be passed an <code>exc</code> keyword argument that has a reference to the exception that caused the teardown if there was one.</p> </dd>
</dl> <dl class="data"> <dt id="flask.appcontext_tearing_down">
<code>flask.appcontext_tearing_down</code> </dt> <dd>
<p>This signal is sent when the app context is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on.</p> <p>Example subscriber:</p> <pre data-language="python">def close_db_connection(sender, **extra):
    session.close()

from flask import appcontext_tearing_down
appcontext_tearing_down.connect(close_db_connection, app)
</pre> <p>This will also be passed an <code>exc</code> keyword argument that has a reference to the exception that caused the teardown if there was one.</p> </dd>
</dl> <dl class="data"> <dt id="flask.appcontext_pushed">
<code>flask.appcontext_pushed</code> </dt> <dd>
<p>This signal is sent when an application context is pushed. The sender is the application. This is usually useful for unittests in order to temporarily hook in information. For instance it can be used to set a resource early onto the <code>g</code> object.</p> <p>Example usage:</p> <pre data-language="python">from contextlib import contextmanager
from flask import appcontext_pushed

@contextmanager
def user_set(app, user):
    def handler(sender, **kwargs):
        g.user = user
    with appcontext_pushed.connected_to(handler, app):
        yield
</pre> <p>And in the testcode:</p> <pre data-language="python">def test_user_me(self):
    with user_set(app, 'john'):
        c = app.test_client()
        resp = c.get('/users/me')
        assert resp.data == 'username=john'
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details>
</dd>
</dl> <dl class="data"> <dt id="flask.appcontext_popped">
<code>flask.appcontext_popped</code> </dt> <dd>
<p>This signal is sent when an application context is popped. The sender is the application. This usually falls in line with the <a class="reference internal" href="#flask.appcontext_tearing_down" title="flask.appcontext_tearing_down"><code>appcontext_tearing_down</code></a> signal.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details>
</dd>
</dl> <dl class="data"> <dt id="flask.message_flashed">
<code>flask.message_flashed</code> </dt> <dd>
<p>This signal is sent when the application is flashing a message. The messages is sent as <code>message</code> keyword argument and the category as <code>category</code>.</p> <p>Example subscriber:</p> <pre data-language="python">recorded = []
def record(sender, message, category, **extra):
    recorded.append((message, category))

from flask import message_flashed
message_flashed.connect(record, app)
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details>
</dd>
</dl> <dl class="class"> <dt id="flask.signals.Namespace">
<code>class signals.Namespace</code> </dt> <dd>
<p>An alias for <a class="reference external" href="https://pythonhosted.org/blinker/index.html#blinker.base.Namespace" title="(in Blinker v1.4)"><code>blinker.base.Namespace</code></a> if blinker is available, otherwise a dummy class that creates fake signals. This class is available for Flask extensions that want to provide the same fallback system as Flask itself.</p> <dl class="method"> <dt id="flask.signals.Namespace.signal">
<code>signal(name, doc=None)</code> </dt> <dd>
<p>Creates a new signal for this namespace if blinker is available, otherwise returns a fake signal that has a send method that will do nothing but will fail with a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.9)"><code>RuntimeError</code></a> for all other operations, including connecting.</p> </dd>
</dl> </dd>
</dl>   <h2 id="id2">Class-Based Views</h2> <details class="changelog" id="class-based-views"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details><dl class="class"> <dt id="flask.views.View">
<code>class flask.views.View</code> </dt> <dd>
<p>Alternative way to use view functions. A subclass has to implement <a class="reference internal" href="#flask.views.View.dispatch_request" title="flask.views.View.dispatch_request"><code>dispatch_request()</code></a> which is called with the view arguments from the URL routing system. If <a class="reference internal" href="#flask.views.View.methods" title="flask.views.View.methods"><code>methods</code></a> is provided the methods do not have to be passed to the <a class="reference internal" href="#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><code>add_url_rule()</code></a> method explicitly:</p> <pre data-language="python">class MyView(View):
    methods = ['GET']

    def dispatch_request(self, name):
        return 'Hello %s!' % name

app.add_url_rule('/hello/&lt;name&gt;', view_func=MyView.as_view('myview'))
</pre> <p>When you want to decorate a pluggable view you will have to either do that when the view function is created (by wrapping the return value of <a class="reference internal" href="#flask.views.View.as_view" title="flask.views.View.as_view"><code>as_view()</code></a>) or you can use the <a class="reference internal" href="#flask.views.View.decorators" title="flask.views.View.decorators"><code>decorators</code></a> attribute:</p> <pre data-language="python">class SecretView(View):
    methods = ['GET']
    decorators = [superuser_required]

    def dispatch_request(self):
        ...
</pre> <p>The decorators stored in the decorators list are applied one after another when the view function is created. Note that you can <em>not</em> use the class based decorators since those would decorate the view class and not the generated view function!</p> <dl class="method"> <dt id="flask.views.View.as_view">
<code>classmethod as_view(name, *class_args, **class_kwargs)</code> </dt> <dd>
<p>Converts the class into an actual view function that can be used with the routing system. Internally this generates a function on the fly which will instantiate the <a class="reference internal" href="#flask.views.View" title="flask.views.View"><code>View</code></a> on each request and call the <a class="reference internal" href="#flask.views.View.dispatch_request" title="flask.views.View.dispatch_request"><code>dispatch_request()</code></a> method on it.</p> <p>The arguments passed to <a class="reference internal" href="#flask.views.View.as_view" title="flask.views.View.as_view"><code>as_view()</code></a> are forwarded to the constructor of the class.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.views.View.decorators">
<code>decorators = ()</code> </dt> <dd>
<p>The canonical way to decorate class-based views is to decorate the return value of as_view(). However since this moves parts of the logic from the class declaration to the place where it’s hooked into the routing system.</p> <p>You can place one or more decorators in this list and whenever the view function is created the result is automatically decorated.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="flask.views.View.dispatch_request">
<code>dispatch_request()</code> </dt> <dd>
<p>Subclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.views.View.methods">
<code>methods = None</code> </dt> <dd>
<p>A list of methods this view can handle.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.views.View.provide_automatic_options">
<code>provide_automatic_options = None</code> </dt> <dd>
<p>Setting this disables or force-enables the automatic options handling.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="flask.views.MethodView">
<code>class flask.views.MethodView</code> </dt> <dd>
<p>A class-based view that dispatches request methods to the corresponding class methods. For example, if you implement a <code>get</code> method, it will be used to handle <code>GET</code> requests.</p> <pre data-language="python">class CounterAPI(MethodView):
    def get(self):
        return session.get('counter', 0)

    def post(self):
        session['counter'] = session.get('counter', 0) + 1
        return 'OK'

app.add_url_rule('/counter', view_func=CounterAPI.as_view('counter'))
</pre> <dl class="method"> <dt id="flask.views.MethodView.dispatch_request">
<code>dispatch_request(*args, **kwargs)</code> </dt> <dd>
<p>Subclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.</p> </dd>
</dl> </dd>
</dl>   <h2 id="id3">URL Route Registrations</h2> <p id="url-route-registrations">Generally there are three ways to define rules for the routing system:</p> <ol class="arabic simple"> <li>You can use the <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><code>flask.Flask.route()</code></a> decorator.</li> <li>You can use the <a class="reference internal" href="#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><code>flask.Flask.add_url_rule()</code></a> function.</li> <li>You can directly access the underlying Werkzeug routing system which is exposed as <a class="reference internal" href="#flask.Flask.url_map" title="flask.Flask.url_map"><code>flask.Flask.url_map</code></a>.</li> </ol> <p>Variable parts in the route can be specified with angular brackets (<code>/user/&lt;username&gt;</code>). By default a variable part in the URL accepts any string without a slash however a different converter can be specified as well by using <code>&lt;converter:name&gt;</code>.</p> <p>Variable parts are passed to the view function as keyword arguments.</p> <p>The following converters are available:</p> <table class="docutils align-default">   <tr>
<td><p><code>string</code></p></td> <td><p>accepts any text without a slash (the default)</p></td> </tr> <tr>
<td><p><code>int</code></p></td> <td><p>accepts integers</p></td> </tr> <tr>
<td><p><code>float</code></p></td> <td><p>like <code>int</code> but for floating point values</p></td> </tr> <tr>
<td><p><code>path</code></p></td> <td><p>like the default but also accepts slashes</p></td> </tr> <tr>
<td><p><code>any</code></p></td> <td><p>matches one of the items provided</p></td> </tr> <tr>
<td><p><code>uuid</code></p></td> <td><p>accepts UUID strings</p></td> </tr>  </table> <p>Custom converters can be defined using <a class="reference internal" href="#flask.Flask.url_map" title="flask.Flask.url_map"><code>flask.Flask.url_map</code></a>.</p> <p>Here are some examples:</p> <pre data-language="python">@app.route('/')
def index():
    pass

@app.route('/&lt;username&gt;')
def show_user(username):
    pass

@app.route('/post/&lt;int:post_id&gt;')
def show_post(post_id):
    pass
</pre> <p>An important detail to keep in mind is how Flask deals with trailing slashes. The idea is to keep each URL unique so the following rules apply:</p> <ol class="arabic simple"> <li>If a rule ends with a slash and is requested without a slash by the user, the user is automatically redirected to the same page with a trailing slash attached.</li> <li>If a rule does not end with a trailing slash and the user requests the page with a trailing slash, a 404 not found is raised.</li> </ol> <p>This is consistent with how web servers deal with static files. This also makes it possible to use relative link targets safely.</p> <p>You can also define multiple rules for the same function. They have to be unique however. Defaults can also be specified. Here for example is a definition for a URL that accepts an optional page:</p> <pre data-language="python">@app.route('/users/', defaults={'page': 1})
@app.route('/users/page/&lt;int:page&gt;')
def show_users(page):
    pass
</pre> <p>This specifies that <code>/users/</code> will be the URL for page one and <code>/users/page/N</code> will be the URL for page <code>N</code>.</p> <p>If a URL contains a default value, it will be redirected to its simpler form with a 301 redirect. In the above example, <code>/users/page/1</code> will be redirected to <code>/users/</code>. If your route handles <code>GET</code> and <code>POST</code> requests, make sure the default route only handles <code>GET</code>, as redirects can’t preserve form data.</p> <pre data-language="python">@app.route('/region/', defaults={'id': 1})
@app.route('/region/&lt;int:id&gt;', methods=['GET', 'POST'])
def region(id):
   pass
</pre> <p>Here are the parameters that <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><code>route()</code></a> and <a class="reference internal" href="#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><code>add_url_rule()</code></a> accept. The only difference is that with the route parameter the view function is defined with the decorator instead of the <code>view_func</code> parameter.</p> <table class="docutils align-default">   <tr>
<td><p><code>rule</code></p></td> <td><p>the URL rule as string</p></td> </tr> <tr>
<td><p><code>endpoint</code></p></td> <td><p>the endpoint for the registered URL rule. Flask itself assumes that the name of the view function is the name of the endpoint if not explicitly stated.</p></td> </tr> <tr>
<td><p><code>view_func</code></p></td> <td><p>the function to call when serving a request to the provided endpoint. If this is not provided one can specify the function later by storing it in the <a class="reference internal" href="#flask.Flask.view_functions" title="flask.Flask.view_functions"><code>view_functions</code></a> dictionary with the endpoint as key.</p></td> </tr> <tr>
<td><p><code>defaults</code></p></td> <td><p>A dictionary with defaults for this rule. See the example above for how defaults work.</p></td> </tr> <tr>
<td><p><code>subdomain</code></p></td> <td><p>specifies the rule for the subdomain in case subdomain matching is in use. If not specified the default subdomain is assumed.</p></td> </tr> <tr>
<td><p><code>**options</code></p></td> <td><p>the options to be forwarded to the underlying <a class="reference external" href="https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule" title="(in Werkzeug v1.0.x)"><code>Rule</code></a> object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to (<code>GET</code>, <code>POST</code> etc.). By default a rule just listens for <code>GET</code> (and implicitly <code>HEAD</code>). Starting with Flask 0.6, <code>OPTIONS</code> is implicitly added and handled by the standard request handling. They have to be specified as keyword arguments.</p></td> </tr>  </table>   <h2 id="view-func-options">View Function Options</h2> <p id="view-function-options">For internal usage the view functions can have some attributes attached to customize behavior the view function would normally not have control over. The following attributes can be provided optionally to either override some defaults to <a class="reference internal" href="#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><code>add_url_rule()</code></a> or general behavior:</p> <ul class="simple"> <li>
<code>__name__</code>: The name of a function is by default used as endpoint. If endpoint is provided explicitly this value is used. Additionally this will be prefixed with the name of the blueprint by default which cannot be customized from the function itself.</li> <li>
<code>methods</code>: If methods are not provided when the URL rule is added, Flask will look on the view function object itself if a <code>methods</code> attribute exists. If it does, it will pull the information for the methods from there.</li> <li>
<code>provide_automatic_options</code>: if this attribute is set Flask will either force enable or disable the automatic implementation of the HTTP <code>OPTIONS</code> response. This can be useful when working with decorators that want to customize the <code>OPTIONS</code> response on a per-view basis.</li> <li>
<code>required_methods</code>: if this attribute is set, Flask will always add these methods when registering a URL rule even if the methods were explicitly overridden in the <code>route()</code> call.</li> </ul> <p>Full example:</p> <pre data-language="python">def index():
    if request.method == 'OPTIONS':
        # custom options handling here
        ...
    return 'Hello World!'
index.provide_automatic_options = False
index.methods = ['GET', 'OPTIONS']

app.add_url_rule('/', index)
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8: </span>The <code>provide_automatic_options</code> functionality was added.</p> </div> </details>  <h2 id="command-line-interface">Command Line Interface</h2> <dl class="class"> <dt id="flask.cli.FlaskGroup">
<code>class flask.cli.FlaskGroup(add_default_commands=True, create_app=None, add_version_option=True, load_dotenv=True, set_debug_flag=True, **extra)</code> </dt> <dd>
<p>Special subclass of the <a class="reference internal" href="#flask.cli.AppGroup" title="flask.cli.AppGroup"><code>AppGroup</code></a> group that supports loading more commands from the configured Flask app. Normally a developer does not have to interface with this class but there are some very advanced use cases for which it makes sense to create an instance of this.</p> <p>For information as of why this is useful see <a class="reference internal" href="../cli/index#custom-scripts"><span class="std std-ref">Custom Scripts</span></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>add_default_commands</strong> – if this is True then the default run and shell commands will be added.</li> <li>
<strong>add_version_option</strong> – adds the <code>--version</code> option.</li> <li>
<strong>create_app</strong> – an optional callback that is passed the script info and returns the loaded app.</li> <li>
<strong>load_dotenv</strong> – Load the nearest <code>.env</code> and <code>.flaskenv</code> files to set environment variables. Will also change the working directory to the directory containing the first file found.</li> <li>
<strong>set_debug_flag</strong> – Set the app’s debug flag based on the active environment</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>If installed, python-dotenv will be used to load environment variables from <code>.env</code> and <code>.flaskenv</code> files.</p> </div> </details><dl class="method"> <dt id="flask.cli.FlaskGroup.get_command">
<code>get_command(ctx, name)</code> </dt> <dd>
<p>Given a context and a command name, this returns a <code>Command</code> object if it exists or returns <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.cli.FlaskGroup.list_commands">
<code>list_commands(ctx)</code> </dt> <dd>
<p>Returns a list of subcommand names in the order they should appear.</p> </dd>
</dl> <dl class="method"> <dt id="flask.cli.FlaskGroup.main">
<code>main(*args, **kwargs)</code> </dt> <dd>
<p>This is the way to invoke a script with all the bells and whistles as a command line application. This will always terminate the application after a call. If this is not wanted, <code>SystemExit</code> needs to be caught.</p> <p>This method is also available by directly calling the instance of a <code>Command</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.0: </span>Added the <code>standalone_mode</code> flag to control the standalone mode.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>args</strong> – the arguments that should be used for parsing. If not provided, <code>sys.argv[1:]</code> is used.</li> <li>
<strong>prog_name</strong> – the program name that should be used. By default the program name is constructed by taking the file name from <code>sys.argv[0]</code>.</li> <li>
<strong>complete_var</strong> – the environment variable that controls the bash completion support. The default is <code>"_&lt;prog_name&gt;_COMPLETE"</code> with prog_name in uppercase.</li> <li>
<strong>standalone_mode</strong> – the default behavior is to invoke the script in standalone mode. Click will then handle exceptions and convert them into error messages and the function will never return but shut down the interpreter. If this is set to <code>False</code> they will be propagated to the caller and the return value of this function is the return value of <code>invoke()</code>.</li> <li>
<strong>extra</strong> – extra keyword arguments are forwarded to the context constructor. See <code>Context</code> for more information.</li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="flask.cli.AppGroup">
<code>class flask.cli.AppGroup(name=None, commands=None, **attrs)</code> </dt> <dd>
<p>This works similar to a regular click <a class="reference external" href="https://click.palletsprojects.com/en/7.x/api/#click.Group" title="(in Click v7.x)"><code>Group</code></a> but it changes the behavior of the <a class="reference internal" href="#flask.cli.AppGroup.command" title="flask.cli.AppGroup.command"><code>command()</code></a> decorator so that it automatically wraps the functions in <a class="reference internal" href="#flask.cli.with_appcontext" title="flask.cli.with_appcontext"><code>with_appcontext()</code></a>.</p> <p>Not to be confused with <a class="reference internal" href="#flask.cli.FlaskGroup" title="flask.cli.FlaskGroup"><code>FlaskGroup</code></a>.</p> <dl class="method"> <dt id="flask.cli.AppGroup.command">
<code>command(*args, **kwargs)</code> </dt> <dd>
<p>This works exactly like the method of the same name on a regular <a class="reference external" href="https://click.palletsprojects.com/en/7.x/api/#click.Group" title="(in Click v7.x)"><code>click.Group</code></a> but it wraps callbacks in <a class="reference internal" href="#flask.cli.with_appcontext" title="flask.cli.with_appcontext"><code>with_appcontext()</code></a> unless it’s disabled by passing <code>with_appcontext=False</code>.</p> </dd>
</dl> <dl class="method"> <dt id="flask.cli.AppGroup.group">
<code>group(*args, **kwargs)</code> </dt> <dd>
<p>This works exactly like the method of the same name on a regular <a class="reference external" href="https://click.palletsprojects.com/en/7.x/api/#click.Group" title="(in Click v7.x)"><code>click.Group</code></a> but it defaults the group class to <a class="reference internal" href="#flask.cli.AppGroup" title="flask.cli.AppGroup"><code>AppGroup</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="flask.cli.ScriptInfo">
<code>class flask.cli.ScriptInfo(app_import_path=None, create_app=None, set_debug_flag=True)</code> </dt> <dd>
<p>Helper object to deal with Flask applications. This is usually not necessary to interface with as it’s used internally in the dispatching to click. In future versions of Flask this object will most likely play a bigger role. Typically it’s created automatically by the <a class="reference internal" href="#flask.cli.FlaskGroup" title="flask.cli.FlaskGroup"><code>FlaskGroup</code></a> but you can also manually create it and pass it onwards as click object.</p> <dl class="attribute"> <dt id="flask.cli.ScriptInfo.app_import_path">
<code>app_import_path = None</code> </dt> <dd>
<p>Optionally the import path for the Flask application.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.cli.ScriptInfo.create_app">
<code>create_app = None</code> </dt> <dd>
<p>Optionally a function that is passed the script info to create the instance of the application.</p> </dd>
</dl> <dl class="attribute"> <dt id="flask.cli.ScriptInfo.data">
<code>data = None</code> </dt> <dd>
<p>A dictionary with arbitrary data that can be associated with this script info.</p> </dd>
</dl> <dl class="method"> <dt id="flask.cli.ScriptInfo.load_app">
<code>load_app()</code> </dt> <dd>
<p>Loads the Flask app (if not yet loaded) and returns it. Calling this multiple times will just result in the already loaded app to be returned.</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="flask.cli.load_dotenv">
<code>flask.cli.load_dotenv(path=None)</code> </dt> <dd>
<p>Load “dotenv” files in order of precedence to set environment variables.</p> <p>If an env var is already set it is not overwritten, so earlier files in the list are preferred over later files.</p> <p>Changes the current working directory to the location of the first file found, with the assumption that it is in the top level project directory and will be where the Python path should import local packages from.</p> <p>This is a no-op if <a class="reference external" href="https://github.com/theskumar/python-dotenv#readme">python-dotenv</a> is not installed.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>path</strong> – Load the file at this location instead of searching.</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p><code>True</code> if a file was loaded.</p> </dd> </dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.1.0: </span>Returns <code>False</code> when python-dotenv is not installed, or when the given path isn’t a file.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="flask.cli.with_appcontext">
<code>flask.cli.with_appcontext(f)</code> </dt> <dd>
<p>Wraps a callback so that it’s guaranteed to be executed with the script’s application context. If callbacks are registered directly to the <code>app.cli</code> object then they are wrapped with this function by default unless it’s disabled.</p> </dd>
</dl> <dl class="function"> <dt id="flask.cli.pass_script_info">
<code>flask.cli.pass_script_info(f)</code> </dt> <dd>
<p>Marks a function so that an instance of <a class="reference internal" href="#flask.cli.ScriptInfo" title="flask.cli.ScriptInfo"><code>ScriptInfo</code></a> is passed as first argument to the click callback.</p> </dd>
</dl> <dl class="data"> <dt id="flask.cli.run_command">
<code>flask.cli.run_command = &lt;Command run&gt;</code> </dt> <dd>
<p>Run a local development server.</p> <p>This server is for development purposes only. It does not provide the stability, security, or performance of production WSGI servers.</p> <p>The reloader and debugger are enabled by default if FLASK_ENV=development or FLASK_DEBUG=1.</p> </dd>
</dl> <dl class="data"> <dt id="flask.cli.shell_command">
<code>flask.cli.shell_command = &lt;Command shell&gt;</code> </dt> <dd>
<p>Run an interactive Python shell in the context of a given Flask application. The application will populate the default namespace of this shell according to it’s configuration.</p> <p>This is useful for executing small snippets of management code without having to manually configure the application.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2020 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://flask.palletsprojects.com/en/1.1.x/api/" class="_attribution-link">https://flask.palletsprojects.com/en/1.1.x/api/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
